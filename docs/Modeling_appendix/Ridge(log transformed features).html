<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>ridge(log-transformed-features – Statisitical Learning for Data Mining Project Portfolio</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-6bd9cfa162949bde0a231f530c97869d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Statisitical Learning for Data Mining Project Portfolio</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../project1.html"> 
<span class="menu-text">Bias and Variance in Linear Regression</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../project2.html"> 
<span class="menu-text">Ensemble Learning Techniques for Fair Classification</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../project3.html"> 
<span class="menu-text">Forecasting Property Valuations in a Mid-Sized U.S. City:A SHAP-Gain Feature Selection and ElasticNet-Ensembled Approach with Optuna-Tuned XGBoost</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<div id="f975dfdf" class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co"># ===== Load Data =====</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>folder_path <span class="op">=</span> Path(<span class="st">"data"</span>)  <span class="co"># Make sure there's a 'data/' folder next to this script</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>building_years <span class="op">=</span> []</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>):</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.read_csv(folder_path <span class="op">/</span> <span class="ss">f'building_details_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">.csv'</span>)  <span class="co"># FIXED</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'year'</span>] <span class="op">=</span> year</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    building_years.append(df)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>building_all <span class="op">=</span> pd.concat(building_years, ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>building_all <span class="op">=</span> building_all.drop_duplicates(subset<span class="op">=</span>[<span class="st">'acct'</span>, <span class="st">'year'</span>], keep<span class="op">=</span><span class="st">'first'</span>)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>pivoted <span class="op">=</span> building_all.pivot(index<span class="op">=</span><span class="st">'acct'</span>, columns<span class="op">=</span><span class="st">'year'</span>)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>pivoted.columns <span class="op">=</span> [<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> col, year <span class="kw">in</span> pivoted.columns]</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>pivoted <span class="op">=</span> pivoted.reset_index()</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>train <span class="op">=</span> pd.read_csv(folder_path <span class="op">/</span> <span class="st">'assessment_history_train.csv'</span>)  <span class="co"># FIXED</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>test <span class="op">=</span> pd.read_csv(folder_path <span class="op">/</span> <span class="st">'assessment_history_test.csv'</span>)    <span class="co"># FIXED</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> train.merge(pivoted, on<span class="op">=</span><span class="st">'acct'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> test.merge(pivoted, on<span class="op">=</span><span class="st">'acct'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2274541461.py:18: DtypeWarning: Columns (14) have mixed types. Specify dtype option on import or set low_memory=False.
  df = pd.read_csv(folder_path + f'building_details_{year}.csv')
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2274541461.py:30: DtypeWarning: Columns (21,23,25,27) have mixed types. Specify dtype option on import or set low_memory=False.
  test = pd.read_csv(folder_path + 'assessment_history_test.csv')</code></pre>
</div>
</div>
<div id="22732988" class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1: Identify all '2019' columns in train</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>train_2019_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> <span class="st">'2019'</span> <span class="kw">in</span> col]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 2: Find which 2019 columns are missing in test</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>train_only_2019_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_2019_cols <span class="cf">if</span> col <span class="kw">not</span> <span class="kw">in</span> test_merged.columns]</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 3: Always drop 'protested_2019' due to leakage risk</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>train_only_2019_cols.append(<span class="st">'protested_2019'</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 4: Drop the identified columns from train</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> train_merged.drop(columns<span class="op">=</span>train_only_2019_cols, errors<span class="op">=</span><span class="st">'ignore'</span>)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 5: Optional logging</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Dropped </span><span class="sc">{</span><span class="bu">len</span>(train_only_2019_cols)<span class="sc">}</span><span class="ss"> columns from train (including protested_2019 if present):"</span>)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(train_only_2019_cols)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>✅ Dropped 4 columns from train (including protested_2019 if present):
['building_value_2019', 'land_value_2019', 'assessed_2019', 'protested_2019']</code></pre>
</div>
</div>
<div id="49b308d3" class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'protested_2019'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        df.drop(columns<span class="op">=</span><span class="st">'protested_2019'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Dropped 'protested_2019' from </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"'protested_2019' not found in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>ℹ️ 'protested_2019' not found in train_merged
✅ Dropped 'protested_2019' from test_merged</code></pre>
</div>
</div>
<div id="e44ff519" class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">## Get all '2019' columns in train and test</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>train_2019_cols <span class="op">=</span> <span class="bu">sorted</span>([col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> <span class="st">'2019'</span> <span class="kw">in</span> col])</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>test_2019_cols <span class="op">=</span> <span class="bu">sorted</span>([col <span class="cf">for</span> col <span class="kw">in</span> test_merged.columns <span class="cf">if</span> <span class="st">'2019'</span> <span class="kw">in</span> col])</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Print train columns</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"2019 Columns in train_merged:"</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> train_2019_cols:</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" - </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> 2019 Columns in test_merged:"</span>)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> test_2019_cols:</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" - </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>📘 2019 Columns in train_merged:
 - bedrooms_2019
 - building_area_2019
 - building_condition_2019
 - deck_area_2019
 - elevator_2019
 - exterior_walls_2019
 - fireplaces_2019
 - floor_area_lower_2019
 - floor_area_primary_2019
 - floor_area_upper_2019
 - floors_2019
 - foundation_type_2019
 - full_bath_2019
 - garage_area_2019
 - grade_2019
 - half_bath_2019
 - has_cooling_2019
 - has_heat_2019
 - land_area_2019
 - mobile_home_area_2019
 - physical_condition_2019
 - porch_area_2019
 - quality_2019
 - quality_description_2019
 - total_rooms_2019
 - year_built_2019
 - year_remodeled_2019

📙 2019 Columns in test_merged:
 - bedrooms_2019
 - building_area_2019
 - building_condition_2019
 - deck_area_2019
 - elevator_2019
 - exterior_walls_2019
 - fireplaces_2019
 - floor_area_lower_2019
 - floor_area_primary_2019
 - floor_area_upper_2019
 - floors_2019
 - foundation_type_2019
 - full_bath_2019
 - garage_area_2019
 - grade_2019
 - half_bath_2019
 - has_cooling_2019
 - has_heat_2019
 - land_area_2019
 - mobile_home_area_2019
 - physical_condition_2019
 - porch_area_2019
 - quality_2019
 - quality_description_2019
 - total_rooms_2019
 - year_built_2019
 - year_remodeled_2019</code></pre>
</div>
</div>
<div id="0e8d9653" class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compare sets</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>train_only_2019 <span class="op">=</span> <span class="bu">sorted</span>(<span class="bu">list</span>(<span class="bu">set</span>(train_2019_cols) <span class="op">-</span> <span class="bu">set</span>(test_2019_cols)))</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>test_only_2019 <span class="op">=</span> <span class="bu">sorted</span>(<span class="bu">list</span>(<span class="bu">set</span>(test_2019_cols) <span class="op">-</span> <span class="bu">set</span>(train_2019_cols)))</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Print comparison result</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> train_only_2019 <span class="kw">and</span> <span class="kw">not</span> test_only_2019:</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> All 2019 columns match between train_merged and test_merged."</span>)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> Mismatched 2019 columns found:"</span>)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> train_only_2019:</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">" In train_merged but not in test_merged:"</span>)</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> col <span class="kw">in</span> train_only_2019:</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"   - </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> test_only_2019:</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">" In test_merged but not in train_merged:"</span>)</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> col <span class="kw">in</span> test_only_2019:</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"   - </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
✅ All 2019 columns match between train_merged and test_merged.</code></pre>
</div>
</div>
<div id="4bb6dfca" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1: Store target separately</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>y_train <span class="op">=</span> train_merged[<span class="st">"TARGET"</span>].values</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 4: Confirm sizes</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Train shape: </span><span class="sc">{</span>train<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Test shape: </span><span class="sc">{</span>test<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Train shape: (628287, 37)
Test shape: (418858, 33)</code></pre>
</div>
</div>
<div id="28236192" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate % of missing values in each column of TRAIN only</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>train_na <span class="op">=</span> (train_merged.isnull().<span class="bu">sum</span>() <span class="op">/</span> train_merged.shape[<span class="dv">0</span>]) <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop columns with no missing values, sort the rest</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>train_na <span class="op">=</span> train_na[train_na <span class="op">&gt;</span> <span class="dv">0</span>].sort_values(ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Optional: Show top 200 missing features</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>missing_data <span class="op">=</span> pd.DataFrame({<span class="st">'Missing Ratio (%)'</span>: train_na})</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Display</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Top columns with missing data (based on training set only):"</span>)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>missing_data.head(<span class="dv">20</span>)</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Top columns with missing data (based on training set only):</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="10">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Missing Ratio (%)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">building_area_2015</td>
<td>5.954126</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">land_area_2015</td>
<td>5.954126</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">protested_2015</td>
<td>5.954126</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">assessed_2015</td>
<td>5.954126</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">building_value_2015</td>
<td>5.954126</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">land_value_2015</td>
<td>5.954126</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">quality_description_2015</td>
<td>5.742280</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">quality_2015</td>
<td>5.742280</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">year_remodeled_2015</td>
<td>5.742280</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">year_built_2015</td>
<td>5.742280</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">building_condition_2015</td>
<td>5.566405</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">physical_condition_2015</td>
<td>5.566405</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">has_heat_2015</td>
<td>5.566405</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">has_cooling_2015</td>
<td>5.566405</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">foundation_type_2015</td>
<td>5.566246</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">exterior_walls_2015</td>
<td>5.566246</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">grade_2015</td>
<td>5.566087</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">bedrooms_2015</td>
<td>5.391485</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">full_bath_2015</td>
<td>5.391485</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">fireplaces_2015</td>
<td>5.391485</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div id="a5543a7e" class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_floor_area_totals(df, years):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> y <span class="kw">in</span> years:</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>        primary_col <span class="op">=</span> <span class="ss">f'floor_area_primary_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">'</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>        upper_col   <span class="op">=</span> <span class="ss">f'floor_area_upper_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">'</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>        lower_col   <span class="op">=</span> <span class="ss">f'floor_area_lower_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">'</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>        total_col   <span class="op">=</span> <span class="ss">f'floor_area_total_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">'</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">all</span>(col <span class="kw">in</span> df.columns <span class="cf">for</span> col <span class="kw">in</span> [primary_col, upper_col, lower_col]):</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>            df[total_col] <span class="op">=</span> (</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>                df[primary_col].fillna(<span class="dv">0</span>) <span class="op">+</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>                df[upper_col].fillna(<span class="dv">0</span>) <span class="op">+</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>                df[lower_col].fillna(<span class="dv">0</span>)</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Created: </span><span class="sc">{</span>total_col<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipping </span><span class="sc">{</span>total_col<span class="sc">}</span><span class="ss"> — one or more components missing."</span>)</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply for years 2015–2019</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2015'</span>, <span class="st">'2016'</span>, <span class="st">'2017'</span>, <span class="st">'2018'</span>, <span class="st">'2019'</span>]</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> create_floor_area_totals(train_merged, years)</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> create_floor_area_totals(test_merged, years)</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>✅ Created: floor_area_total_2015
✅ Created: floor_area_total_2016
✅ Created: floor_area_total_2017
✅ Created: floor_area_total_2018
✅ Created: floor_area_total_2019
✅ Created: floor_area_total_2015
✅ Created: floor_area_total_2016
✅ Created: floor_area_total_2017
✅ Created: floor_area_total_2018
✅ Created: floor_area_total_2019</code></pre>
</div>
</div>
<div id="e3e21f91" class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>zero_pct <span class="op">=</span> (train_merged[<span class="st">'mobile_home_area_2015'</span>] <span class="op">==</span> <span class="dv">0</span>).mean() <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" mobile_home_area_2015 is 0 in </span><span class="sc">{</span>zero_pct<span class="sc">:.2f}</span><span class="ss">% of training rows"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>📊 mobile_home_area_2015 is 0 in 94.42% of training rows</code></pre>
</div>
</div>
<div id="1baf9005" class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> col.startswith(<span class="st">"mobile_home_area"</span>)]</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop from both sets</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" Dropped columns from train/test: </span><span class="sc">{</span>cols_to_drop<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>🗑️ Dropped columns from train/test: ['mobile_home_area_2015', 'mobile_home_area_2016', 'mobile_home_area_2017', 'mobile_home_area_2018', 'mobile_home_area_2019']</code></pre>
</div>
</div>
<div id="c93f14b0" class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>zero_pct <span class="op">=</span> (train_merged[<span class="st">'deck_area_2015'</span>] <span class="op">==</span> <span class="dv">0</span>).mean() <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" deck_area_2015 is 0 in </span><span class="sc">{</span>zero_pct<span class="sc">:.2f}</span><span class="ss">% of training rows"</span>)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>📊 deck_area_2015 is 0 in 90.66% of training rows</code></pre>
</div>
</div>
<div id="376042eb" class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Use training columns to identify which deck_area columns exist</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> col.startswith(<span class="st">"deck_area"</span>)]</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop those columns from both datasets</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" Dropped columns from train/test: </span><span class="sc">{</span>cols_to_drop<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>🗑️ Dropped columns from train/test: ['deck_area_2015', 'deck_area_2016', 'deck_area_2017', 'deck_area_2018', 'deck_area_2019']</code></pre>
</div>
</div>
<div id="e1cf0fe8" class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_yearly_features(df, base_features, years):</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> feature <span class="kw">in</span> base_features:</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>        cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Backfill all relevant year columns in-place</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>            df[cols] <span class="op">=</span> df[cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Backfilled: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> across </span><span class="sc">{</span>cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipping </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> — not enough year columns found."</span>)</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Years in reverse so that bfill works from most recent (2019) to oldest (2015)</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>features <span class="op">=</span> [<span class="st">'garage_area'</span>, <span class="st">'porch_area'</span>]</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to both train and test</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_yearly_features(train_merged, features, years)</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_yearly_features(test_merged, features, years)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>✅ Backfilled: garage_area across ['garage_area_2019', 'garage_area_2018', 'garage_area_2017', 'garage_area_2016', 'garage_area_2015']
✅ Backfilled: porch_area across ['porch_area_2019', 'porch_area_2018', 'porch_area_2017', 'porch_area_2016', 'porch_area_2015']
✅ Backfilled: garage_area across ['garage_area_2019', 'garage_area_2018', 'garage_area_2017', 'garage_area_2016', 'garage_area_2015']
✅ Backfilled: porch_area across ['porch_area_2019', 'porch_area_2018', 'porch_area_2017', 'porch_area_2016', 'porch_area_2015']</code></pre>
</div>
</div>
<div id="90f87495" class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_yearly_features(df, features, years):</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> feature <span class="kw">in</span> features:</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>        year_cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(year_cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>            df[year_cols] <span class="op">=</span> df[year_cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Backfilled: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> across </span><span class="sc">{</span>year_cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipped: Not enough year columns for '</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">'"</span>)</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Use years in reverse for proper backfill (newest to oldest)</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>features <span class="op">=</span> [<span class="st">'floors'</span>, <span class="st">'half_bath'</span>, <span class="st">'full_bath'</span>, <span class="st">'total_rooms'</span>, <span class="st">'bedrooms'</span>]</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to both train and test</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_yearly_features(train_merged, features, years)</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_yearly_features(test_merged, features, years)</span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>✅ Backfilled: floors across ['floors_2019', 'floors_2018', 'floors_2017', 'floors_2016', 'floors_2015']
✅ Backfilled: half_bath across ['half_bath_2019', 'half_bath_2018', 'half_bath_2017', 'half_bath_2016', 'half_bath_2015']
✅ Backfilled: full_bath across ['full_bath_2019', 'full_bath_2018', 'full_bath_2017', 'full_bath_2016', 'full_bath_2015']
✅ Backfilled: total_rooms across ['total_rooms_2019', 'total_rooms_2018', 'total_rooms_2017', 'total_rooms_2016', 'total_rooms_2015']
✅ Backfilled: bedrooms across ['bedrooms_2019', 'bedrooms_2018', 'bedrooms_2017', 'bedrooms_2016', 'bedrooms_2015']
✅ Backfilled: floors across ['floors_2019', 'floors_2018', 'floors_2017', 'floors_2016', 'floors_2015']
✅ Backfilled: half_bath across ['half_bath_2019', 'half_bath_2018', 'half_bath_2017', 'half_bath_2016', 'half_bath_2015']
✅ Backfilled: full_bath across ['full_bath_2019', 'full_bath_2018', 'full_bath_2017', 'full_bath_2016', 'full_bath_2015']
✅ Backfilled: total_rooms across ['total_rooms_2019', 'total_rooms_2018', 'total_rooms_2017', 'total_rooms_2016', 'total_rooms_2015']
✅ Backfilled: bedrooms across ['bedrooms_2019', 'bedrooms_2018', 'bedrooms_2017', 'bedrooms_2016', 'bedrooms_2015']</code></pre>
</div>
</div>
<div id="461dc946" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Identify elevator-related columns from training set</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>elevator_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> col.startswith(<span class="st">"elevator"</span>)]</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop from both train and test</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>elevator_cols, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>elevator_cols, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"🗑️ Dropped elevator-related columns from train/test: </span><span class="sc">{</span>elevator_cols<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>🗑️ Dropped elevator-related columns from train/test: ['elevator_2015', 'elevator_2016', 'elevator_2017', 'elevator_2018', 'elevator_2019']</code></pre>
</div>
</div>
<div id="631ccc5a" class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_year_features(df, features, years):</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> feature <span class="kw">in</span> features:</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>        cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>            df[cols] <span class="op">=</span> df[cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Backfilled: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> across </span><span class="sc">{</span>cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipped </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> — not enough year-based columns found."</span>)</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_year_built_final(df):</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>    year_cols <span class="op">=</span> [<span class="ss">f"year_built_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>] <span class="cf">if</span> <span class="ss">f"year_built_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> year_cols:</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'year_built_final'</span>] <span class="op">=</span> df[year_cols].bfill(axis<span class="op">=</span><span class="dv">1</span>).iloc[:, <span class="dv">0</span>]</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Created year_built_final from: </span><span class="sc">{</span>year_cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">" Skipped: no year_built_* columns found."</span>)</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Define reverse years for backfill (latest → oldest)</span></span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>features_to_backfill <span class="op">=</span> [<span class="st">'fireplaces'</span>, <span class="st">'quality'</span>, <span class="st">'quality_description'</span>]</span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to both train and test</span></span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_year_features(train_merged, features_to_backfill, years)</span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> create_year_built_final(train_merged)</span>
<span id="cb31-27"><a href="#cb31-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-28"><a href="#cb31-28" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_year_features(test_merged, features_to_backfill, years)</span>
<span id="cb31-29"><a href="#cb31-29" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> create_year_built_final(test_merged)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>✅ Backfilled: fireplaces across ['fireplaces_2019', 'fireplaces_2018', 'fireplaces_2017', 'fireplaces_2016', 'fireplaces_2015']
✅ Backfilled: quality across ['quality_2019', 'quality_2018', 'quality_2017', 'quality_2016', 'quality_2015']
✅ Backfilled: quality_description across ['quality_description_2019', 'quality_description_2018', 'quality_description_2017', 'quality_description_2016', 'quality_description_2015']
✅ Created year_built_final from: ['year_built_2019', 'year_built_2018', 'year_built_2017', 'year_built_2016', 'year_built_2015']
✅ Backfilled: fireplaces across ['fireplaces_2019', 'fireplaces_2018', 'fireplaces_2017', 'fireplaces_2016', 'fireplaces_2015']
✅ Backfilled: quality across ['quality_2019', 'quality_2018', 'quality_2017', 'quality_2016', 'quality_2015']
✅ Backfilled: quality_description across ['quality_description_2019', 'quality_description_2018', 'quality_description_2017', 'quality_description_2016', 'quality_description_2015']
✅ Created year_built_final from: ['year_built_2019', 'year_built_2018', 'year_built_2017', 'year_built_2016', 'year_built_2015']</code></pre>
</div>
</div>
<div id="3b931aae" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co">## Identify columns to drop from training data</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> col.startswith(<span class="st">"year_remodeled"</span>)]</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop from both train and test</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"🗑️ Dropped year_remodeled-related columns from train/test: </span><span class="sc">{</span>cols_to_drop<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>🗑️ Dropped year_remodeled-related columns from train/test: ['year_remodeled_2015', 'year_remodeled_2016', 'year_remodeled_2017', 'year_remodeled_2018', 'year_remodeled_2019']</code></pre>
</div>
</div>
<div id="885c18cb" class="cell">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_categorical_year_features(df, features, years):</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> feature <span class="kw">in</span> features:</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>        year_cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(year_cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>            df[year_cols] <span class="op">=</span> df[year_cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Backfilled: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> across </span><span class="sc">{</span>year_cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipped: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> — not enough year-based columns."</span>)</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Backfill from most recent year to oldest</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>features <span class="op">=</span> [<span class="st">'building_condition'</span>, <span class="st">'foundation_type'</span>, <span class="st">'grade'</span>, <span class="st">'has_cooling'</span>, </span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>            <span class="st">'has_heat'</span>, <span class="st">'physical_condition'</span>, <span class="st">'exterior_walls'</span>]</span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to train and test</span></span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_categorical_year_features(train_merged, features, years)</span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_categorical_year_features(test_merged, features, years)</span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>✅ Backfilled: building_condition across ['building_condition_2019', 'building_condition_2018', 'building_condition_2017', 'building_condition_2016', 'building_condition_2015']
✅ Backfilled: foundation_type across ['foundation_type_2019', 'foundation_type_2018', 'foundation_type_2017', 'foundation_type_2016', 'foundation_type_2015']
✅ Backfilled: grade across ['grade_2019', 'grade_2018', 'grade_2017', 'grade_2016', 'grade_2015']
✅ Backfilled: has_cooling across ['has_cooling_2019', 'has_cooling_2018', 'has_cooling_2017', 'has_cooling_2016', 'has_cooling_2015']
✅ Backfilled: has_heat across ['has_heat_2019', 'has_heat_2018', 'has_heat_2017', 'has_heat_2016', 'has_heat_2015']
✅ Backfilled: physical_condition across ['physical_condition_2019', 'physical_condition_2018', 'physical_condition_2017', 'physical_condition_2016', 'physical_condition_2015']
✅ Backfilled: exterior_walls across ['exterior_walls_2019', 'exterior_walls_2018', 'exterior_walls_2017', 'exterior_walls_2016', 'exterior_walls_2015']
✅ Backfilled: building_condition across ['building_condition_2019', 'building_condition_2018', 'building_condition_2017', 'building_condition_2016', 'building_condition_2015']
✅ Backfilled: foundation_type across ['foundation_type_2019', 'foundation_type_2018', 'foundation_type_2017', 'foundation_type_2016', 'foundation_type_2015']
✅ Backfilled: grade across ['grade_2019', 'grade_2018', 'grade_2017', 'grade_2016', 'grade_2015']
✅ Backfilled: has_cooling across ['has_cooling_2019', 'has_cooling_2018', 'has_cooling_2017', 'has_cooling_2016', 'has_cooling_2015']
✅ Backfilled: has_heat across ['has_heat_2019', 'has_heat_2018', 'has_heat_2017', 'has_heat_2016', 'has_heat_2015']
✅ Backfilled: physical_condition across ['physical_condition_2019', 'physical_condition_2018', 'physical_condition_2017', 'physical_condition_2016', 'physical_condition_2015']
✅ Backfilled: exterior_walls across ['exterior_walls_2019', 'exterior_walls_2018', 'exterior_walls_2017', 'exterior_walls_2016', 'exterior_walls_2015']</code></pre>
</div>
</div>
<div id="c0c31525" class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_year_columns(df, features, years):</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> feature <span class="kw">in</span> features:</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>        cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>            df[cols] <span class="op">=</span> df[cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Backfilled: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> across </span><span class="sc">{</span>cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipped: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> — not enough year-based columns found."</span>)</span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Define year ranges</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>area_years <span class="op">=</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>value_years <span class="op">=</span> [<span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Define feature groups</span></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>area_features <span class="op">=</span> [<span class="st">'building_area'</span>, <span class="st">'land_area'</span>]</span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>value_features <span class="op">=</span> [<span class="st">'building_value'</span>, <span class="st">'land_value'</span>, <span class="st">'assessed'</span>]</span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to train and test</span></span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_year_columns(train_merged, area_features, area_years)</span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_year_columns(train_merged, value_features, value_years)</span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_year_columns(test_merged, area_features, area_years)</span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_year_columns(test_merged, value_features, value_years)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>✅ Backfilled: building_area across ['building_area_2019', 'building_area_2018', 'building_area_2017', 'building_area_2016', 'building_area_2015']
✅ Backfilled: land_area across ['land_area_2019', 'land_area_2018', 'land_area_2017', 'land_area_2016', 'land_area_2015']
✅ Backfilled: building_value across ['building_value_2018', 'building_value_2017', 'building_value_2016', 'building_value_2015']
✅ Backfilled: land_value across ['land_value_2018', 'land_value_2017', 'land_value_2016', 'land_value_2015']
✅ Backfilled: assessed across ['assessed_2018', 'assessed_2017', 'assessed_2016', 'assessed_2015']
✅ Backfilled: building_area across ['building_area_2019', 'building_area_2018', 'building_area_2017', 'building_area_2016', 'building_area_2015']
✅ Backfilled: land_area across ['land_area_2019', 'land_area_2018', 'land_area_2017', 'land_area_2016', 'land_area_2015']
✅ Backfilled: building_value across ['building_value_2018', 'building_value_2017', 'building_value_2016', 'building_value_2015']
✅ Backfilled: land_value across ['land_value_2018', 'land_value_2017', 'land_value_2016', 'land_value_2015']
✅ Backfilled: assessed across ['assessed_2018', 'assessed_2017', 'assessed_2016', 'assessed_2015']</code></pre>
</div>
</div>
<div id="d621f5cd" class="cell">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_protested_columns(df, years):</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    cols <span class="op">=</span> [<span class="ss">f"protested_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"protested_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>        df[cols] <span class="op">=</span> df[cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Backfilled: protested across </span><span class="sc">{</span>cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">" Skipped protested — not enough year-based columns found."</span>)</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Only use pre-2019 years to avoid leakage</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to both datasets</span></span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_protested_columns(train_merged, years)</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_protested_columns(test_merged, years)</span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>✅ Backfilled: protested across ['protested_2018', 'protested_2017', 'protested_2016', 'protested_2015']
✅ Backfilled: protested across ['protested_2018', 'protested_2017', 'protested_2016', 'protested_2015']</code></pre>
</div>
</div>
<div id="38927d79" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Save 'acct' from test_merged only</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>acct_test <span class="op">=</span> test_merged[[<span class="st">'acct'</span>]].copy() <span class="cf">if</span> <span class="st">'acct'</span> <span class="kw">in</span> test_merged.columns <span class="cf">else</span> <span class="va">None</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop 'acct' from both train and test</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'acct'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>        df.drop(columns<span class="op">=</span><span class="st">'acct'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"🗑️ Dropped 'acct' from </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>🗑️ Dropped 'acct' from train_merged
🗑️ Dropped 'acct' from test_merged</code></pre>
</div>
</div>
<div id="b46d2e44" class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> [<span class="st">'zone'</span>, <span class="st">'subneighborhood'</span>, <span class="st">'neighborhood'</span>, <span class="st">'region'</span>]:</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>train_merged[col]<span class="sc">.</span>nunique()<span class="sc">}</span><span class="ss"> unique values in training set"</span>)</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"⚠️ </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> not found in training set"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>zone: 1589 unique values in training set
subneighborhood: 6161 unique values in training set
neighborhood: 959 unique values in training set
region: 87 unique values in training set</code></pre>
</div>
</div>
<div id="b39be55a" class="cell">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> [<span class="st">'neighborhood'</span>, <span class="st">'region'</span>,<span class="st">'zone'</span>,<span class="st">'subneighborhood'</span>]:</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 1: Compute frequency from training data</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>        freq_map <span class="op">=</span> train_merged[col].value_counts(normalize<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 2: Apply to both datasets</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>        train_merged[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_freq'</span>] <span class="op">=</span> train_merged[col].<span class="bu">map</span>(freq_map)</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>        test_merged[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_freq'</span>] <span class="op">=</span> test_merged[col].<span class="bu">map</span>(freq_map)</span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Frequency encoded: </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> → </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_freq (based on training set)"</span>)</span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Column '</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">' not found in training set"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2858503920.py:7: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  train_merged[f'{col}_freq'] = train_merged[col].map(freq_map)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2858503920.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test_merged[f'{col}_freq'] = test_merged[col].map(freq_map)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2858503920.py:7: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  train_merged[f'{col}_freq'] = train_merged[col].map(freq_map)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2858503920.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test_merged[f'{col}_freq'] = test_merged[col].map(freq_map)</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>✅ Frequency encoded: neighborhood → neighborhood_freq (based on training set)
✅ Frequency encoded: region → region_freq (based on training set)</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2858503920.py:7: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  train_merged[f'{col}_freq'] = train_merged[col].map(freq_map)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2858503920.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test_merged[f'{col}_freq'] = test_merged[col].map(freq_map)</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>✅ Frequency encoded: zone → zone_freq (based on training set)
✅ Frequency encoded: subneighborhood → subneighborhood_freq (based on training set)</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2858503920.py:7: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  train_merged[f'{col}_freq'] = train_merged[col].map(freq_map)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2858503920.py:8: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  test_merged[f'{col}_freq'] = test_merged[col].map(freq_map)</code></pre>
</div>
</div>
<div id="440c8579" class="cell">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">all</span>(col <span class="kw">in</span> train_merged.columns <span class="cf">for</span> col <span class="kw">in</span> [<span class="st">'land_area_2019'</span>, <span class="st">'land_area_2015'</span>]):</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    growth <span class="op">=</span> train_merged[<span class="st">'land_area_2019'</span>] <span class="op">-</span> train_merged[<span class="st">'land_area_2015'</span>]</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>    changed_pct <span class="op">=</span> (growth <span class="op">!=</span> <span class="dv">0</span>).mean() <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Percentage of homes with land area change (2015→2019): </span><span class="sc">{</span>changed_pct<span class="sc">:.2f}</span><span class="ss">%"</span>)</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">" One or both columns ('land_area_2015', 'land_area_2019') not found in training set"</span>)</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>🧪 Percentage of homes with land area change (2015→2019): 6.42%</code></pre>
</div>
</div>
<div id="57919971" class="cell">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'year_built_final'</span>] <span class="op">=</span> df[<span class="st">'year_built_final'</span>].astype(<span class="bu">str</span>)</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Converted 'year_built_final' to string in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" 'year_built_final' not found in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>🔤 Converted 'year_built_final' to string in train_merged
🔤 Converted 'year_built_final' to string in test_merged</code></pre>
</div>
</div>
<div id="f6711f05" class="cell">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'floor_area_total_final'</span> <span class="kw">in</span> df.columns <span class="kw">and</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>        df.loc[df[<span class="st">'floor_area_total_final'</span>] <span class="op">==</span> <span class="dv">0</span>, <span class="st">'year_built_final'</span>] <span class="op">=</span> <span class="st">'None'</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Set 'year_built_final' to 'None' where 'floor_area_total_final' == 0 in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Required columns missing in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>⚠️ Required columns missing in train_merged
⚠️ Required columns missing in test_merged</code></pre>
</div>
</div>
<div id="0ee69535" class="cell">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define year ranges per feature type</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>value_years <span class="op">=</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2019</span>)   <span class="co"># 2015–2018 for value columns</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>area_years  <span class="op">=</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)   <span class="co"># 2015–2019 for area columns</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Define base columns</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>base_cols_year_map <span class="op">=</span> {</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_value'</span>: value_years,</span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">'land_value'</span>: value_years,</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_area'</span>: area_years,</span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">'land_area'</span>: area_years,</span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate full list of columns to impute</span></span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a>cols_to_impute <span class="op">=</span> []</span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> base, years <span class="kw">in</span> base_cols_year_map.items():</span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> year <span class="kw">in</span> years:</span>
<span id="cb57-17"><a href="#cb57-17" aria-hidden="true" tabindex="-1"></a>        cols_to_impute.append(<span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb57-18"><a href="#cb57-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-19"><a href="#cb57-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Impute using neighborhood → region strategy</span></span>
<span id="cb57-20"><a href="#cb57-20" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> cols_to_impute:</span>
<span id="cb57-21"><a href="#cb57-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># First, fill by neighborhood (train only)</span></span>
<span id="cb57-22"><a href="#cb57-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'neighborhood'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb57-23"><a href="#cb57-23" aria-hidden="true" tabindex="-1"></a>        medians_by_neigh <span class="op">=</span> train_merged.groupby(<span class="st">'neighborhood'</span>)[col].median()</span>
<span id="cb57-24"><a href="#cb57-24" aria-hidden="true" tabindex="-1"></a>        train_merged[col] <span class="op">=</span> train_merged.<span class="bu">apply</span>(</span>
<span id="cb57-25"><a href="#cb57-25" aria-hidden="true" tabindex="-1"></a>            <span class="kw">lambda</span> row: medians_by_neigh[row[<span class="st">'neighborhood'</span>]] <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb57-26"><a href="#cb57-26" aria-hidden="true" tabindex="-1"></a>        test_merged[col] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb57-27"><a href="#cb57-27" aria-hidden="true" tabindex="-1"></a>            <span class="kw">lambda</span> row: medians_by_neigh.get(row[<span class="st">'neighborhood'</span>], np.nan) <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb57-28"><a href="#cb57-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-29"><a href="#cb57-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Then, fill remaining by region (train only)</span></span>
<span id="cb57-30"><a href="#cb57-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'region'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb57-31"><a href="#cb57-31" aria-hidden="true" tabindex="-1"></a>        medians_by_region <span class="op">=</span> train_merged.groupby(<span class="st">'region'</span>)[col].median()</span>
<span id="cb57-32"><a href="#cb57-32" aria-hidden="true" tabindex="-1"></a>        train_merged[col] <span class="op">=</span> train_merged.<span class="bu">apply</span>(</span>
<span id="cb57-33"><a href="#cb57-33" aria-hidden="true" tabindex="-1"></a>            <span class="kw">lambda</span> row: medians_by_region[row[<span class="st">'region'</span>]] <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb57-34"><a href="#cb57-34" aria-hidden="true" tabindex="-1"></a>        test_merged[col] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb57-35"><a href="#cb57-35" aria-hidden="true" tabindex="-1"></a>            <span class="kw">lambda</span> row: medians_by_region.get(row[<span class="st">'region'</span>], np.nan) <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb57-36"><a href="#cb57-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-37"><a href="#cb57-37" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Imputed '</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">' using group medians (neighborhood → region) from training data"</span>)</span>
<span id="cb57-38"><a href="#cb57-38" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>✅ Imputed 'building_value_2015' using group medians (neighborhood → region) from training data
✅ Imputed 'building_value_2016' using group medians (neighborhood → region) from training data
✅ Imputed 'building_value_2017' using group medians (neighborhood → region) from training data
✅ Imputed 'building_value_2018' using group medians (neighborhood → region) from training data
✅ Imputed 'land_value_2015' using group medians (neighborhood → region) from training data
✅ Imputed 'land_value_2016' using group medians (neighborhood → region) from training data
✅ Imputed 'land_value_2017' using group medians (neighborhood → region) from training data
✅ Imputed 'land_value_2018' using group medians (neighborhood → region) from training data
✅ Imputed 'building_area_2015' using group medians (neighborhood → region) from training data
✅ Imputed 'building_area_2016' using group medians (neighborhood → region) from training data
✅ Imputed 'building_area_2017' using group medians (neighborhood → region) from training data
✅ Imputed 'building_area_2018' using group medians (neighborhood → region) from training data
✅ Imputed 'building_area_2019' using group medians (neighborhood → region) from training data
✅ Imputed 'land_area_2015' using group medians (neighborhood → region) from training data
✅ Imputed 'land_area_2016' using group medians (neighborhood → region) from training data
✅ Imputed 'land_area_2017' using group medians (neighborhood → region) from training data
✅ Imputed 'land_area_2018' using group medians (neighborhood → region) from training data
✅ Imputed 'land_area_2019' using group medians (neighborhood → region) from training data</code></pre>
</div>
</div>
<div id="5774e582" class="cell">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pandas.api.types <span class="im">import</span> is_numeric_dtype</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1: Coerce non-numeric to NaN in both sets</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'year_built_final'</span>] <span class="op">=</span> pd.to_numeric(df[<span class="st">'year_built_final'</span>], errors<span class="op">=</span><span class="st">'coerce'</span>)</span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Coerced 'year_built_final' to numeric in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 2: Group-based imputation (use training data only)</span></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> train_merged.columns <span class="kw">and</span> <span class="st">'neighborhood'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Neighborhood-based median from train</span></span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a>    neigh_medians <span class="op">=</span> train_merged.groupby(<span class="st">'neighborhood'</span>)[<span class="st">'year_built_final'</span>].median()</span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Apply to train</span></span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a>    train_merged[<span class="st">'year_built_final'</span>] <span class="op">=</span> train_merged.<span class="bu">apply</span>(</span>
<span id="cb59-16"><a href="#cb59-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: neigh_medians[row[<span class="st">'neighborhood'</span>]] <span class="cf">if</span> pd.isna(row[<span class="st">'year_built_final'</span>]) <span class="cf">else</span> row[<span class="st">'year_built_final'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb59-17"><a href="#cb59-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-18"><a href="#cb59-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Apply to test</span></span>
<span id="cb59-19"><a href="#cb59-19" aria-hidden="true" tabindex="-1"></a>    test_merged[<span class="st">'year_built_final'</span>] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb59-20"><a href="#cb59-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: neigh_medians.get(row[<span class="st">'neighborhood'</span>], np.nan) <span class="cf">if</span> pd.isna(row[<span class="st">'year_built_final'</span>]) <span class="cf">else</span> row[<span class="st">'year_built_final'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb59-21"><a href="#cb59-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-22"><a href="#cb59-22" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'region'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb59-23"><a href="#cb59-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Region-based fallback median from train</span></span>
<span id="cb59-24"><a href="#cb59-24" aria-hidden="true" tabindex="-1"></a>    region_medians <span class="op">=</span> train_merged.groupby(<span class="st">'region'</span>)[<span class="st">'year_built_final'</span>].median()</span>
<span id="cb59-25"><a href="#cb59-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-26"><a href="#cb59-26" aria-hidden="true" tabindex="-1"></a>    train_merged[<span class="st">'year_built_final'</span>] <span class="op">=</span> train_merged.<span class="bu">apply</span>(</span>
<span id="cb59-27"><a href="#cb59-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: region_medians[row[<span class="st">'region'</span>]] <span class="cf">if</span> pd.isna(row[<span class="st">'year_built_final'</span>]) <span class="cf">else</span> row[<span class="st">'year_built_final'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb59-28"><a href="#cb59-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-29"><a href="#cb59-29" aria-hidden="true" tabindex="-1"></a>    test_merged[<span class="st">'year_built_final'</span>] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb59-30"><a href="#cb59-30" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: region_medians.get(row[<span class="st">'region'</span>], np.nan) <span class="cf">if</span> pd.isna(row[<span class="st">'year_built_final'</span>]) <span class="cf">else</span> row[<span class="st">'year_built_final'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb59-31"><a href="#cb59-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-32"><a href="#cb59-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Imputed 'year_built_final' using neighborhood → region medians from training set"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>🔢 Coerced 'year_built_final' to numeric in train_merged
🔢 Coerced 'year_built_final' to numeric in test_merged
✅ Imputed 'year_built_final' using neighborhood → region medians from training set</code></pre>
</div>
</div>
<div id="8ed53d58" class="cell">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="co"># List of all assessed columns to impute</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>assessed_cols <span class="op">=</span> [<span class="st">'assessed_2015'</span>, <span class="st">'assessed_2016'</span>, <span class="st">'assessed_2017'</span>, <span class="st">'assessed_2018'</span>]</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> assessed_cols:</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">not</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: Compute medians from training data only</span></span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>    neigh_medians <span class="op">=</span> train_merged.groupby(<span class="st">'neighborhood'</span>)[col].median()</span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>    region_medians <span class="op">=</span> train_merged.groupby(<span class="st">'region'</span>)[col].median()</span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>    global_median <span class="op">=</span> train_merged[col].median()</span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 2: Train set imputation</span></span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a>    train_merged[col] <span class="op">=</span> train_merged.<span class="bu">apply</span>(</span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: neigh_medians[row[<span class="st">'neighborhood'</span>]]</span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pd.isna(row[col]) <span class="kw">and</span> row[<span class="st">'neighborhood'</span>] <span class="kw">in</span> neigh_medians <span class="cf">else</span></span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a>        region_medians[row[<span class="st">'region'</span>]]</span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pd.isna(row[col]) <span class="kw">and</span> row[<span class="st">'region'</span>] <span class="kw">in</span> region_medians <span class="cf">else</span></span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true" tabindex="-1"></a>        global_median</span>
<span id="cb61-20"><a href="#cb61-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span></span>
<span id="cb61-21"><a href="#cb61-21" aria-hidden="true" tabindex="-1"></a>        row[col],</span>
<span id="cb61-22"><a href="#cb61-22" aria-hidden="true" tabindex="-1"></a>        axis<span class="op">=</span><span class="dv">1</span></span>
<span id="cb61-23"><a href="#cb61-23" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb61-24"><a href="#cb61-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-25"><a href="#cb61-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 3: Test set imputation (using train medians only)</span></span>
<span id="cb61-26"><a href="#cb61-26" aria-hidden="true" tabindex="-1"></a>    test_merged[col] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb61-27"><a href="#cb61-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: neigh_medians.get(row[<span class="st">'neighborhood'</span>], np.nan)</span>
<span id="cb61-28"><a href="#cb61-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col],</span>
<span id="cb61-29"><a href="#cb61-29" aria-hidden="true" tabindex="-1"></a>        axis<span class="op">=</span><span class="dv">1</span></span>
<span id="cb61-30"><a href="#cb61-30" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb61-31"><a href="#cb61-31" aria-hidden="true" tabindex="-1"></a>    test_merged[col] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb61-32"><a href="#cb61-32" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: region_medians.get(row[<span class="st">'region'</span>], np.nan)</span>
<span id="cb61-33"><a href="#cb61-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col],</span>
<span id="cb61-34"><a href="#cb61-34" aria-hidden="true" tabindex="-1"></a>        axis<span class="op">=</span><span class="dv">1</span></span>
<span id="cb61-35"><a href="#cb61-35" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb61-36"><a href="#cb61-36" aria-hidden="true" tabindex="-1"></a>    test_merged[col].fillna(global_median, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb61-37"><a href="#cb61-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-38"><a href="#cb61-38" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Imputed '</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">' using neighborhood → region → global medians (from training data)"</span>)</span>
<span id="cb61-39"><a href="#cb61-39" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/3523755006.py:36: FutureWarning: A value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method.
The behavior will change in pandas 3.0. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy.

For example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object.


  test_merged[col].fillna(global_median, inplace=True)</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>✅ Imputed 'assessed_2015' using neighborhood → region → global medians (from training data)</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/3523755006.py:36: FutureWarning: A value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method.
The behavior will change in pandas 3.0. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy.

For example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object.


  test_merged[col].fillna(global_median, inplace=True)</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>✅ Imputed 'assessed_2016' using neighborhood → region → global medians (from training data)</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/3523755006.py:36: FutureWarning: A value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method.
The behavior will change in pandas 3.0. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy.

For example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object.


  test_merged[col].fillna(global_median, inplace=True)</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>✅ Imputed 'assessed_2017' using neighborhood → region → global medians (from training data)
✅ Imputed 'assessed_2018' using neighborhood → region → global medians (from training data)</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/3523755006.py:36: FutureWarning: A value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method.
The behavior will change in pandas 3.0. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy.

For example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object.


  test_merged[col].fillna(global_median, inplace=True)</code></pre>
</div>
</div>
<div id="5d5bb99d" class="cell">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 1: Compute neighborhood-level stats ===</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>neigh_stats <span class="op">=</span> train_merged.groupby(<span class="st">'neighborhood'</span>)[<span class="st">'assessed_2018'</span>].agg([</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'neigh_assess_mean'</span>, <span class="st">'mean'</span>),</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'neigh_assess_median'</span>, <span class="st">'median'</span>),</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'neigh_assess_std'</span>, <span class="st">'std'</span>),</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'neigh_assess_q1'</span>, <span class="kw">lambda</span> x: x.quantile(<span class="fl">0.25</span>)),</span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'neigh_assess_q3'</span>, <span class="kw">lambda</span> x: x.quantile(<span class="fl">0.75</span>)),</span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>]).reset_index()</span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>neigh_stats[<span class="st">'neigh_assess_iqr'</span>] <span class="op">=</span> neigh_stats[<span class="st">'neigh_assess_q3'</span>] <span class="op">-</span> neigh_stats[<span class="st">'neigh_assess_q1'</span>]</span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 2: Compute region-level stats ===</span></span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a>region_stats <span class="op">=</span> train_merged.groupby(<span class="st">'region'</span>)[<span class="st">'assessed_2018'</span>].agg([</span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'region_assess_mean'</span>, <span class="st">'mean'</span>),</span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'region_assess_median'</span>, <span class="st">'median'</span>),</span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'region_assess_std'</span>, <span class="st">'std'</span>),</span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'region_assess_q1'</span>, <span class="kw">lambda</span> x: x.quantile(<span class="fl">0.25</span>)),</span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'region_assess_q3'</span>, <span class="kw">lambda</span> x: x.quantile(<span class="fl">0.75</span>)),</span>
<span id="cb69-18"><a href="#cb69-18" aria-hidden="true" tabindex="-1"></a>]).reset_index()</span>
<span id="cb69-19"><a href="#cb69-19" aria-hidden="true" tabindex="-1"></a>region_stats[<span class="st">'region_assess_iqr'</span>] <span class="op">=</span> region_stats[<span class="st">'region_assess_q3'</span>] <span class="op">-</span> region_stats[<span class="st">'region_assess_q1'</span>]</span>
<span id="cb69-20"><a href="#cb69-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-21"><a href="#cb69-21" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 3: Fallback std maps from training data ===</span></span>
<span id="cb69-22"><a href="#cb69-22" aria-hidden="true" tabindex="-1"></a><span class="co"># For neighborhood fallback, group region medians of neighborhood std</span></span>
<span id="cb69-23"><a href="#cb69-23" aria-hidden="true" tabindex="-1"></a>neigh_std_by_region <span class="op">=</span> neigh_stats.merge(train_merged[[<span class="st">'neighborhood'</span>, <span class="st">'region'</span>]], on<span class="op">=</span><span class="st">'neighborhood'</span>, how<span class="op">=</span><span class="st">'left'</span>) <span class="op">\</span></span>
<span id="cb69-24"><a href="#cb69-24" aria-hidden="true" tabindex="-1"></a>                                  .groupby(<span class="st">'region'</span>)[<span class="st">'neigh_assess_std'</span>].median()</span>
<span id="cb69-25"><a href="#cb69-25" aria-hidden="true" tabindex="-1"></a>global_neigh_std <span class="op">=</span> neigh_stats[<span class="st">'neigh_assess_std'</span>].median()</span>
<span id="cb69-26"><a href="#cb69-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-27"><a href="#cb69-27" aria-hidden="true" tabindex="-1"></a>region_std_by_neigh <span class="op">=</span> region_stats.merge(train_merged[[<span class="st">'neighborhood'</span>, <span class="st">'region'</span>]], on<span class="op">=</span><span class="st">'region'</span>, how<span class="op">=</span><span class="st">'left'</span>) <span class="op">\</span></span>
<span id="cb69-28"><a href="#cb69-28" aria-hidden="true" tabindex="-1"></a>                                   .groupby(<span class="st">'neighborhood'</span>)[<span class="st">'region_assess_std'</span>].median()</span>
<span id="cb69-29"><a href="#cb69-29" aria-hidden="true" tabindex="-1"></a>global_region_std <span class="op">=</span> region_stats[<span class="st">'region_assess_std'</span>].median()</span>
<span id="cb69-30"><a href="#cb69-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-31"><a href="#cb69-31" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 4: Merge into train/test and compute features ===</span></span>
<span id="cb69-32"><a href="#cb69-32" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb69-33"><a href="#cb69-33" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.merge(neigh_stats, on<span class="op">=</span><span class="st">'neighborhood'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb69-34"><a href="#cb69-34" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.merge(region_stats, on<span class="op">=</span><span class="st">'region'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb69-35"><a href="#cb69-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-36"><a href="#cb69-36" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill missing std values via fallback</span></span>
<span id="cb69-37"><a href="#cb69-37" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'neigh_assess_std'</span>] <span class="op">=</span> df[<span class="st">'neigh_assess_std'</span>].fillna(</span>
<span id="cb69-38"><a href="#cb69-38" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'region'</span>].<span class="bu">map</span>(neigh_std_by_region)</span>
<span id="cb69-39"><a href="#cb69-39" aria-hidden="true" tabindex="-1"></a>    ).fillna(global_neigh_std)</span>
<span id="cb69-40"><a href="#cb69-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-41"><a href="#cb69-41" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'region_assess_std'</span>] <span class="op">=</span> df[<span class="st">'region_assess_std'</span>].fillna(</span>
<span id="cb69-42"><a href="#cb69-42" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'neighborhood'</span>].<span class="bu">map</span>(region_std_by_neigh)</span>
<span id="cb69-43"><a href="#cb69-43" aria-hidden="true" tabindex="-1"></a>    ).fillna(global_region_std)</span>
<span id="cb69-44"><a href="#cb69-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-45"><a href="#cb69-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute derived features</span></span>
<span id="cb69-46"><a href="#cb69-46" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'assess_minus_neigh_mean'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">-</span> df[<span class="st">'neigh_assess_mean'</span>]</span>
<span id="cb69-47"><a href="#cb69-47" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'assess_ratio_neigh_mean'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">/</span> (df[<span class="st">'neigh_assess_mean'</span>] <span class="op">+</span> <span class="fl">1e-6</span>)</span>
<span id="cb69-48"><a href="#cb69-48" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'z_score_assess_neigh'</span>] <span class="op">=</span> df[<span class="st">'assess_minus_neigh_mean'</span>] <span class="op">/</span> (df[<span class="st">'neigh_assess_std'</span>] <span class="op">+</span> <span class="fl">1e-6</span>)</span>
<span id="cb69-49"><a href="#cb69-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-50"><a href="#cb69-50" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'assess_minus_region_mean'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">-</span> df[<span class="st">'region_assess_mean'</span>]</span>
<span id="cb69-51"><a href="#cb69-51" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'assess_ratio_region_mean'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">/</span> (df[<span class="st">'region_assess_mean'</span>] <span class="op">+</span> <span class="fl">1e-6</span>)</span>
<span id="cb69-52"><a href="#cb69-52" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'z_score_assess_region'</span>] <span class="op">=</span> df[<span class="st">'assess_minus_region_mean'</span>] <span class="op">/</span> (df[<span class="st">'region_assess_std'</span>] <span class="op">+</span> <span class="fl">1e-6</span>)</span>
<span id="cb69-53"><a href="#cb69-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-54"><a href="#cb69-54" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Save back</span></span>
<span id="cb69-55"><a href="#cb69-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> df_name <span class="op">==</span> <span class="st">'train_merged'</span>:</span>
<span id="cb69-56"><a href="#cb69-56" aria-hidden="true" tabindex="-1"></a>        train_merged <span class="op">=</span> df</span>
<span id="cb69-57"><a href="#cb69-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb69-58"><a href="#cb69-58" aria-hidden="true" tabindex="-1"></a>        test_merged <span class="op">=</span> df</span>
<span id="cb69-59"><a href="#cb69-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-60"><a href="#cb69-60" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Completed: Stats merge + std fallback + z-score computation."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>✅ Completed: Stats merge + std fallback + z-score computation.</code></pre>
</div>
</div>
<div id="42769f67" class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> [<span class="st">'neighborhood'</span>, <span class="st">'region'</span>,<span class="st">'zone'</span>,<span class="st">'subneighborhood'</span>]</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>    drop_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> cols_to_drop <span class="cf">if</span> col <span class="kw">in</span> df.columns]</span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> drop_cols:</span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>        df.drop(columns<span class="op">=</span>drop_cols, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"🗑️ Dropped columns from </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>drop_cols<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>🗑️ Dropped columns from train_merged: ['neighborhood', 'region', 'zone', 'subneighborhood']
🗑️ Dropped columns from test_merged: ['neighborhood', 'region', 'zone', 'subneighborhood']</code></pre>
</div>
</div>
<div id="7b449aa0" class="cell">
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>growth_pairs <span class="op">=</span> {</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_value_growth'</span>: (<span class="st">'building_value_2018'</span>, <span class="st">'building_value_2015'</span>),</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">'land_value_growth'</span>:     (<span class="st">'land_value_2018'</span>, <span class="st">'land_value_2015'</span>),</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">'assessed_growth'</span>:       (<span class="st">'assessed_2018'</span>, <span class="st">'assessed_2015'</span>)</span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> new_col, (final_col, base_col) <span class="kw">in</span> growth_pairs.items():</span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> final_col <span class="kw">in</span> df.columns <span class="kw">and</span> base_col <span class="kw">in</span> df.columns:</span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>            df[new_col] <span class="op">=</span> df[final_col] <span class="op">-</span> df[base_col]</span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Created </span><span class="sc">{</span>new_col<span class="sc">}</span><span class="ss"> in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipped </span><span class="sc">{</span>new_col<span class="sc">}</span><span class="ss"> in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">: missing </span><span class="sc">{</span>final_col<span class="sc">}</span><span class="ss"> or </span><span class="sc">{</span>base_col<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-15"><a href="#cb73-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Building Age ===</span></span>
<span id="cb73-16"><a href="#cb73-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb73-17"><a href="#cb73-17" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'year_built_final'</span>] <span class="op">=</span> pd.to_numeric(df[<span class="st">'year_built_final'</span>], errors<span class="op">=</span><span class="st">'coerce'</span>)  <span class="co"># handle 'Vacant', etc.</span></span>
<span id="cb73-18"><a href="#cb73-18" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'building_age'</span>] <span class="op">=</span> <span class="dv">2018</span> <span class="op">-</span> df[<span class="st">'year_built_final'</span>]</span>
<span id="cb73-19"><a href="#cb73-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Created building_age in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb73-20"><a href="#cb73-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb73-21"><a href="#cb73-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Skipped building_age in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">: missing year_built_final"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>✅ Created building_value_growth in train_merged
✅ Created land_value_growth in train_merged
✅ Created assessed_growth in train_merged
✅ Created building_age in train_merged
✅ Created building_value_growth in test_merged
✅ Created land_value_growth in test_merged
✅ Created assessed_growth in test_merged
✅ Created building_age in test_merged</code></pre>
</div>
</div>
<div id="1739cfaa" class="cell">
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'school_dist'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>    missing_pct <span class="op">=</span> train_merged[<span class="st">'school_dist'</span>].isna().mean() <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>    missing_count <span class="op">=</span> train_merged[<span class="st">'school_dist'</span>].isna().<span class="bu">sum</span>()</span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" 'school_dist' has </span><span class="sc">{</span>missing_count<span class="sc">}</span><span class="ss"> missing values (</span><span class="sc">{</span>missing_pct<span class="sc">:.2f}</span><span class="ss">%) in training set"</span>)</span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">" 'school_dist' not found in training set"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>🔍 'school_dist' has 3 missing values (0.00%) in training set</code></pre>
</div>
</div>
<div id="e7945775" class="cell">
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'school_dist'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>    school_dist_median <span class="op">=</span> train_merged[<span class="st">'school_dist'</span>].median()</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="st">'school_dist'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>            df[<span class="st">'school_dist'</span>] <span class="op">=</span> df[<span class="st">'school_dist'</span>].fillna(school_dist_median)</span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Filled missing 'school_dist' in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss"> using train median (</span><span class="sc">{</span>school_dist_median<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">" 'school_dist' not found in train_merged"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>✅ Filled missing 'school_dist' in train_merged using train median (8.0)
✅ Filled missing 'school_dist' in test_merged using train median (8.0)</code></pre>
</div>
</div>
<div id="9f776fca" class="cell">
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>    missing_pct <span class="op">=</span> train_merged[<span class="st">'year_built_final'</span>].isna().mean() <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>    missing_count <span class="op">=</span> train_merged[<span class="st">'year_built_final'</span>].isna().<span class="bu">sum</span>()</span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" 'year_built_final' has </span><span class="sc">{</span>missing_count<span class="sc">}</span><span class="ss"> missing values (</span><span class="sc">{</span>missing_pct<span class="sc">:.2f}</span><span class="ss">%) in training set"</span>)</span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">" 'year_built_final' not found in training set"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>🔍 'year_built_final' has 0 missing values (0.00%) in training set</code></pre>
</div>
</div>
<div id="c0acf4a2" class="cell">
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 0: Define base feature names ===</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>numeric_bases <span class="op">=</span> [</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">'garage_area'</span>, <span class="st">'porch_area'</span>, <span class="st">'floors'</span>, <span class="st">'half_bath'</span>, <span class="st">'full_bath'</span>,</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">'total_rooms'</span>, <span class="st">'bedrooms'</span>, <span class="st">'fireplaces'</span>, <span class="st">'building_area'</span>, <span class="st">'building_value'</span></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a>categorical_fill_map <span class="op">=</span> {</span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality'</span>: <span class="st">'None'</span>,</span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality_description'</span>: <span class="st">'None'</span>,</span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_condition'</span>: <span class="st">'None'</span>,</span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true" tabindex="-1"></a>    <span class="st">'foundation_type'</span>: <span class="st">'None'</span>,</span>
<span id="cb81-12"><a href="#cb81-12" aria-hidden="true" tabindex="-1"></a>    <span class="st">'grade'</span>: <span class="st">'None'</span>,</span>
<span id="cb81-13"><a href="#cb81-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">'has_cooling'</span>: <span class="va">False</span>,</span>
<span id="cb81-14"><a href="#cb81-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">'has_heat'</span>: <span class="va">False</span>,</span>
<span id="cb81-15"><a href="#cb81-15" aria-hidden="true" tabindex="-1"></a>    <span class="st">'physical_condition'</span>: <span class="st">'None'</span>,</span>
<span id="cb81-16"><a href="#cb81-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">'exterior_walls'</span>: <span class="st">'None'</span>,</span>
<span id="cb81-17"><a href="#cb81-17" aria-hidden="true" tabindex="-1"></a>    <span class="st">'protested'</span>: <span class="va">False</span></span>
<span id="cb81-18"><a href="#cb81-18" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb81-19"><a href="#cb81-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-20"><a href="#cb81-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate full list of columns (2015–2019 only, no final columns)</span></span>
<span id="cb81-21"><a href="#cb81-21" aria-hidden="true" tabindex="-1"></a>numeric_cols_to_zero <span class="op">=</span> [</span>
<span id="cb81-22"><a href="#cb81-22" aria-hidden="true" tabindex="-1"></a>    <span class="ss">f'</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> base <span class="kw">in</span> numeric_bases <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)</span>
<span id="cb81-23"><a href="#cb81-23" aria-hidden="true" tabindex="-1"></a>] <span class="op">+</span> [<span class="st">'building_value_growth'</span>]</span>
<span id="cb81-24"><a href="#cb81-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-25"><a href="#cb81-25" aria-hidden="true" tabindex="-1"></a>categorical_cols_to_fill <span class="op">=</span> {</span>
<span id="cb81-26"><a href="#cb81-26" aria-hidden="true" tabindex="-1"></a>    <span class="ss">f'</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">'</span>: val</span>
<span id="cb81-27"><a href="#cb81-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> base, val <span class="kw">in</span> categorical_fill_map.items()</span>
<span id="cb81-28"><a href="#cb81-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)</span>
<span id="cb81-29"><a href="#cb81-29" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb81-30"><a href="#cb81-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-31"><a href="#cb81-31" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 1: Apply imputation if floor_area_total_2019 == 0 ===</span></span>
<span id="cb81-32"><a href="#cb81-32" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb81-33"><a href="#cb81-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'floor_area_total_2019'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb81-34"><a href="#cb81-34" aria-hidden="true" tabindex="-1"></a>        zero_floor_mask <span class="op">=</span> df[<span class="st">'floor_area_total_2019'</span>] <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb81-35"><a href="#cb81-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-36"><a href="#cb81-36" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Fill numeric columns with 0</span></span>
<span id="cb81-37"><a href="#cb81-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> col <span class="kw">in</span> numeric_cols_to_zero:</span>
<span id="cb81-38"><a href="#cb81-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb81-39"><a href="#cb81-39" aria-hidden="true" tabindex="-1"></a>                df.loc[zero_floor_mask, col] <span class="op">=</span> df.loc[zero_floor_mask, col].fillna(<span class="dv">0</span>)</span>
<span id="cb81-40"><a href="#cb81-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-41"><a href="#cb81-41" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Fill categorical/boolean columns</span></span>
<span id="cb81-42"><a href="#cb81-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> col, fill_val <span class="kw">in</span> categorical_cols_to_fill.items():</span>
<span id="cb81-43"><a href="#cb81-43" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb81-44"><a href="#cb81-44" aria-hidden="true" tabindex="-1"></a>                df.loc[zero_floor_mask, col] <span class="op">=</span> df.loc[zero_floor_mask, col].fillna(fill_val)</span>
<span id="cb81-45"><a href="#cb81-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-46"><a href="#cb81-46" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Filled structure-dependent missing values in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss"> for </span><span class="sc">{</span>zero_floor_mask<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ss"> rows"</span>)</span>
<span id="cb81-47"><a href="#cb81-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb81-48"><a href="#cb81-48" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" 'floor_area_total_2019' not found in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb81-49"><a href="#cb81-49" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>✅ Filled structure-dependent missing values in train_merged for 218 rows
✅ Filled structure-dependent missing values in test_merged for 150 rows</code></pre>
</div>
</div>
<div id="c5f607f6" class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> OrdinalEncoder</span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> KFold</span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Clear specific variables</span></span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> var <span class="kw">in</span> [<span class="st">'ordinal_cols_all'</span>, <span class="st">'bool_cols_all'</span>]:</span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> var <span class="kw">in</span> <span class="bu">locals</span>():</span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">del</span> <span class="bu">globals</span>()[var]</span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-11"><a href="#cb83-11" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 1: Boolean Encoding (2015–2019 only) ===</span></span>
<span id="cb83-12"><a href="#cb83-12" aria-hidden="true" tabindex="-1"></a>bool_bases <span class="op">=</span> [<span class="st">'has_cooling'</span>, <span class="st">'has_heat'</span>, <span class="st">'protested'</span>]</span>
<span id="cb83-13"><a href="#cb83-13" aria-hidden="true" tabindex="-1"></a>bool_cols_all <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> base <span class="kw">in</span> bool_bases <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)]</span>
<span id="cb83-14"><a href="#cb83-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-15"><a href="#cb83-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> bool_cols_all:</span>
<span id="cb83-16"><a href="#cb83-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb83-17"><a href="#cb83-17" aria-hidden="true" tabindex="-1"></a>        mode_val <span class="op">=</span> train_merged[col].mode(dropna<span class="op">=</span><span class="va">True</span>)[<span class="dv">0</span>]</span>
<span id="cb83-18"><a href="#cb83-18" aria-hidden="true" tabindex="-1"></a>        train_merged[col] <span class="op">=</span> train_merged[col].fillna(mode_val).astype(<span class="bu">int</span>)</span>
<span id="cb83-19"><a href="#cb83-19" aria-hidden="true" tabindex="-1"></a>        test_merged[col] <span class="op">=</span> test_merged[col].fillna(mode_val).astype(<span class="bu">int</span>)</span>
<span id="cb83-20"><a href="#cb83-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-21"><a href="#cb83-21" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 2: Ordinal Cleaning and Encoding (2015–2019 only) ===</span></span>
<span id="cb83-22"><a href="#cb83-22" aria-hidden="true" tabindex="-1"></a>ordinal_bases <span class="op">=</span> [</span>
<span id="cb83-23"><a href="#cb83-23" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality'</span>, <span class="st">'quality_description'</span>, <span class="st">'grade'</span>,</span>
<span id="cb83-24"><a href="#cb83-24" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_condition'</span>, <span class="st">'physical_condition'</span></span>
<span id="cb83-25"><a href="#cb83-25" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb83-26"><a href="#cb83-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-27"><a href="#cb83-27" aria-hidden="true" tabindex="-1"></a>ordinal_cols_all <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> base <span class="kw">in</span> ordinal_bases <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)]</span>
<span id="cb83-28"><a href="#cb83-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-29"><a href="#cb83-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Column-specific replacements</span></span>
<span id="cb83-30"><a href="#cb83-30" aria-hidden="true" tabindex="-1"></a>replacement_maps <span class="op">=</span> {</span>
<span id="cb83-31"><a href="#cb83-31" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality'</span>: {<span class="st">'E'</span>: <span class="st">'D'</span>, <span class="st">'F'</span>: <span class="st">'D'</span>, <span class="st">'X'</span>: np.nan, <span class="st">'None'</span>: np.nan},</span>
<span id="cb83-32"><a href="#cb83-32" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality_description'</span>: {<span class="st">'Poor'</span>: <span class="st">'Very Low'</span>, <span class="st">'None'</span>: np.nan},</span>
<span id="cb83-33"><a href="#cb83-33" aria-hidden="true" tabindex="-1"></a>    <span class="st">'grade'</span>: {<span class="st">'X'</span>: <span class="st">'F'</span>, <span class="st">'X-'</span>: <span class="st">'F'</span>, <span class="st">'X+'</span>: <span class="st">'F'</span>, <span class="st">'E'</span>: <span class="st">'D'</span>, <span class="st">'E-'</span>: <span class="st">'D-'</span>, <span class="st">'E+'</span>: <span class="st">'D+'</span>, <span class="st">'None'</span>: np.nan},</span>
<span id="cb83-34"><a href="#cb83-34" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_condition'</span>: {<span class="st">'Very Poor'</span>: <span class="st">'Poor'</span>, <span class="st">'Unsound'</span>: <span class="st">'Poor'</span>, <span class="st">'None'</span>: np.nan},</span>
<span id="cb83-35"><a href="#cb83-35" aria-hidden="true" tabindex="-1"></a>    <span class="st">'physical_condition'</span>: {<span class="st">'Very Poor'</span>: <span class="st">'Poor'</span>, <span class="st">'Unsound'</span>: <span class="st">'Poor'</span>, <span class="st">'None'</span>: np.nan}</span>
<span id="cb83-36"><a href="#cb83-36" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb83-37"><a href="#cb83-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-38"><a href="#cb83-38" aria-hidden="true" tabindex="-1"></a><span class="co"># Ordinal category order</span></span>
<span id="cb83-39"><a href="#cb83-39" aria-hidden="true" tabindex="-1"></a>ord_categories <span class="op">=</span> {</span>
<span id="cb83-40"><a href="#cb83-40" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality'</span>: [<span class="st">'D'</span>, <span class="st">'C'</span>, <span class="st">'B'</span>, <span class="st">'A'</span>],</span>
<span id="cb83-41"><a href="#cb83-41" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality_description'</span>: [<span class="st">'Very Low'</span>, <span class="st">'Low'</span>, <span class="st">'Average'</span>, <span class="st">'Good'</span>, <span class="st">'Excellent'</span>, <span class="st">'Superior'</span>],</span>
<span id="cb83-42"><a href="#cb83-42" aria-hidden="true" tabindex="-1"></a>    <span class="st">'grade'</span>: [<span class="st">'F'</span>, <span class="st">'D-'</span>, <span class="st">'D'</span>, <span class="st">'D+'</span>, <span class="st">'C-'</span>, <span class="st">'C'</span>, <span class="st">'C+'</span>, <span class="st">'B-'</span>, <span class="st">'B'</span>, <span class="st">'B+'</span>, <span class="st">'A-'</span>, <span class="st">'A'</span>, <span class="st">'A+'</span>],</span>
<span id="cb83-43"><a href="#cb83-43" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_condition'</span>: [<span class="st">'Poor'</span>, <span class="st">'Fair'</span>, <span class="st">'Average'</span>, <span class="st">'Good'</span>, <span class="st">'Very Good'</span>, <span class="st">'Excellent'</span>],</span>
<span id="cb83-44"><a href="#cb83-44" aria-hidden="true" tabindex="-1"></a>    <span class="st">'physical_condition'</span>: [<span class="st">'Poor'</span>, <span class="st">'Fair'</span>, <span class="st">'Average'</span>, <span class="st">'Good'</span>, <span class="st">'Very Good'</span>, <span class="st">'Excellent'</span>]</span>
<span id="cb83-45"><a href="#cb83-45" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb83-46"><a href="#cb83-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-47"><a href="#cb83-47" aria-hidden="true" tabindex="-1"></a><span class="co"># Clean and encode</span></span>
<span id="cb83-48"><a href="#cb83-48" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> base <span class="kw">in</span> ordinal_bases:</span>
<span id="cb83-49"><a href="#cb83-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>):</span>
<span id="cb83-50"><a href="#cb83-50" aria-hidden="true" tabindex="-1"></a>        col <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb83-51"><a href="#cb83-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb83-52"><a href="#cb83-52" aria-hidden="true" tabindex="-1"></a>            replacements <span class="op">=</span> replacement_maps.get(base, {})</span>
<span id="cb83-53"><a href="#cb83-53" aria-hidden="true" tabindex="-1"></a>            train_merged[col] <span class="op">=</span> train_merged[col].replace(replacements)</span>
<span id="cb83-54"><a href="#cb83-54" aria-hidden="true" tabindex="-1"></a>            test_merged[col] <span class="op">=</span> test_merged[col].replace(replacements)</span>
<span id="cb83-55"><a href="#cb83-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-56"><a href="#cb83-56" aria-hidden="true" tabindex="-1"></a>            mode_val <span class="op">=</span> train_merged[col].mode(dropna<span class="op">=</span><span class="va">True</span>)[<span class="dv">0</span>]</span>
<span id="cb83-57"><a href="#cb83-57" aria-hidden="true" tabindex="-1"></a>            train_merged[col] <span class="op">=</span> train_merged[col].fillna(mode_val)</span>
<span id="cb83-58"><a href="#cb83-58" aria-hidden="true" tabindex="-1"></a>            test_merged[col] <span class="op">=</span> test_merged[col].fillna(mode_val)</span>
<span id="cb83-59"><a href="#cb83-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-60"><a href="#cb83-60" aria-hidden="true" tabindex="-1"></a>            encoder <span class="op">=</span> OrdinalEncoder(categories<span class="op">=</span>[ord_categories[base]], handle_unknown<span class="op">=</span><span class="st">'use_encoded_value'</span>, unknown_value<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb83-61"><a href="#cb83-61" aria-hidden="true" tabindex="-1"></a>            train_merged[[col]] <span class="op">=</span> encoder.fit_transform(train_merged[[col]])</span>
<span id="cb83-62"><a href="#cb83-62" aria-hidden="true" tabindex="-1"></a>            test_merged[[col]] <span class="op">=</span> encoder.transform(test_merged[[col]])</span>
<span id="cb83-63"><a href="#cb83-63" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:18: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  train_merged[col] = train_merged[col].fillna(mode_val).astype(int)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:19: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  test_merged[col] = test_merged[col].fillna(mode_val).astype(int)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:18: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  train_merged[col] = train_merged[col].fillna(mode_val).astype(int)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:19: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  test_merged[col] = test_merged[col].fillna(mode_val).astype(int)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:18: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  train_merged[col] = train_merged[col].fillna(mode_val).astype(int)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:19: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  test_merged[col] = test_merged[col].fillna(mode_val).astype(int)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:18: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  train_merged[col] = train_merged[col].fillna(mode_val).astype(int)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:19: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  test_merged[col] = test_merged[col].fillna(mode_val).astype(int)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:18: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  train_merged[col] = train_merged[col].fillna(mode_val).astype(int)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:19: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  test_merged[col] = test_merged[col].fillna(mode_val).astype(int)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:18: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  train_merged[col] = train_merged[col].fillna(mode_val).astype(int)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:19: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  test_merged[col] = test_merged[col].fillna(mode_val).astype(int)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:18: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  train_merged[col] = train_merged[col].fillna(mode_val).astype(int)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:19: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  test_merged[col] = test_merged[col].fillna(mode_val).astype(int)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:18: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  train_merged[col] = train_merged[col].fillna(mode_val).astype(int)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:19: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  test_merged[col] = test_merged[col].fillna(mode_val).astype(int)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:18: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  train_merged[col] = train_merged[col].fillna(mode_val).astype(int)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:19: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  test_merged[col] = test_merged[col].fillna(mode_val).astype(int)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:18: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  train_merged[col] = train_merged[col].fillna(mode_val).astype(int)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:19: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  test_merged[col] = test_merged[col].fillna(mode_val).astype(int)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:18: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  train_merged[col] = train_merged[col].fillna(mode_val).astype(int)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:19: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  test_merged[col] = test_merged[col].fillna(mode_val).astype(int)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:18: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  train_merged[col] = train_merged[col].fillna(mode_val).astype(int)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:19: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  test_merged[col] = test_merged[col].fillna(mode_val).astype(int)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:18: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  train_merged[col] = train_merged[col].fillna(mode_val).astype(int)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:19: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  test_merged[col] = test_merged[col].fillna(mode_val).astype(int)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:18: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  train_merged[col] = train_merged[col].fillna(mode_val).astype(int)
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/2484106990.py:19: FutureWarning: Downcasting object dtype arrays on .fillna, .ffill, .bfill is deprecated and will change in a future version. Call result.infer_objects(copy=False) instead. To opt-in to the future behavior, set `pd.set_option('future.no_silent_downcasting', True)`
  test_merged[col] = test_merged[col].fillna(mode_val).astype(int)</code></pre>
</div>
</div>
<div id="8bc5bd9e" class="cell">
<div class="sourceCode cell-code" id="cb85"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 3: Target Encoding (2015–2019 only) ===</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> group_and_target_encode_cv(train_df, test_df, target_name, column, rare_threshold<span class="op">=</span><span class="fl">0.001</span>, smoothing<span class="op">=</span><span class="dv">10</span>, n_splits<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>    freq <span class="op">=</span> train_df[column].value_counts(normalize<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>    rare_cats <span class="op">=</span> freq[freq <span class="op">&lt;</span> rare_threshold].index</span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>    train_df[column] <span class="op">=</span> train_df[column].replace(rare_cats, <span class="st">'Other'</span>)</span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>    test_df[column] <span class="op">=</span> test_df[column].replace(rare_cats, <span class="st">'Other'</span>)</span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a>    global_mean <span class="op">=</span> train_df[target_name].mean()</span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a>    oof_encoded <span class="op">=</span> pd.Series(index<span class="op">=</span>train_df.index, dtype<span class="op">=</span><span class="st">'float64'</span>)</span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true" tabindex="-1"></a>    kf <span class="op">=</span> KFold(n_splits<span class="op">=</span>n_splits, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb85-12"><a href="#cb85-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> train_idx, val_idx <span class="kw">in</span> kf.split(train_df):</span>
<span id="cb85-13"><a href="#cb85-13" aria-hidden="true" tabindex="-1"></a>        X_tr, X_val <span class="op">=</span> train_df.iloc[train_idx], train_df.iloc[val_idx]</span>
<span id="cb85-14"><a href="#cb85-14" aria-hidden="true" tabindex="-1"></a>        stats <span class="op">=</span> X_tr.groupby(column)[target_name].agg([<span class="st">'mean'</span>, <span class="st">'count'</span>])</span>
<span id="cb85-15"><a href="#cb85-15" aria-hidden="true" tabindex="-1"></a>        smooth <span class="op">=</span> (stats[<span class="st">'mean'</span>] <span class="op">*</span> stats[<span class="st">'count'</span>] <span class="op">+</span> global_mean <span class="op">*</span> smoothing) <span class="op">/</span> (stats[<span class="st">'count'</span>] <span class="op">+</span> smoothing)</span>
<span id="cb85-16"><a href="#cb85-16" aria-hidden="true" tabindex="-1"></a>        oof_encoded.iloc[val_idx] <span class="op">=</span> X_val[column].<span class="bu">map</span>(smooth).fillna(global_mean)</span>
<span id="cb85-17"><a href="#cb85-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-18"><a href="#cb85-18" aria-hidden="true" tabindex="-1"></a>    final_stats <span class="op">=</span> train_df.groupby(column)[target_name].agg([<span class="st">'mean'</span>, <span class="st">'count'</span>])</span>
<span id="cb85-19"><a href="#cb85-19" aria-hidden="true" tabindex="-1"></a>    final_smooth <span class="op">=</span> (final_stats[<span class="st">'mean'</span>] <span class="op">*</span> final_stats[<span class="st">'count'</span>] <span class="op">+</span> global_mean <span class="op">*</span> smoothing) <span class="op">/</span> (final_stats[<span class="st">'count'</span>] <span class="op">+</span> smoothing)</span>
<span id="cb85-20"><a href="#cb85-20" aria-hidden="true" tabindex="-1"></a>    test_encoded <span class="op">=</span> test_df[column].<span class="bu">map</span>(final_smooth).fillna(global_mean)</span>
<span id="cb85-21"><a href="#cb85-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-22"><a href="#cb85-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> oof_encoded, test_encoded</span>
<span id="cb85-23"><a href="#cb85-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-24"><a href="#cb85-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Target-encodable nominal columns</span></span>
<span id="cb85-25"><a href="#cb85-25" aria-hidden="true" tabindex="-1"></a>target_encodable_bases <span class="op">=</span> [<span class="st">'foundation_type'</span>, <span class="st">'exterior_walls'</span>]</span>
<span id="cb85-26"><a href="#cb85-26" aria-hidden="true" tabindex="-1"></a>target_encodable_cols_all <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> base <span class="kw">in</span> target_encodable_bases <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)]</span>
<span id="cb85-27"><a href="#cb85-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-28"><a href="#cb85-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply target encoding</span></span>
<span id="cb85-29"><a href="#cb85-29" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> target_encodable_cols_all:</span>
<span id="cb85-30"><a href="#cb85-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb85-31"><a href="#cb85-31" aria-hidden="true" tabindex="-1"></a>        mode_val <span class="op">=</span> train_merged[col].mode(dropna<span class="op">=</span><span class="va">True</span>)[<span class="dv">0</span>]</span>
<span id="cb85-32"><a href="#cb85-32" aria-hidden="true" tabindex="-1"></a>        train_merged[col] <span class="op">=</span> train_merged[col].fillna(mode_val)</span>
<span id="cb85-33"><a href="#cb85-33" aria-hidden="true" tabindex="-1"></a>        test_merged[col] <span class="op">=</span> test_merged[col].fillna(mode_val)</span>
<span id="cb85-34"><a href="#cb85-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-35"><a href="#cb85-35" aria-hidden="true" tabindex="-1"></a>        train_merged[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_te'</span>], test_merged[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_te'</span>] <span class="op">=</span> group_and_target_encode_cv(</span>
<span id="cb85-36"><a href="#cb85-36" aria-hidden="true" tabindex="-1"></a>            train_merged, test_merged, target_name<span class="op">=</span><span class="st">'assessed_2018'</span>, column<span class="op">=</span>col,</span>
<span id="cb85-37"><a href="#cb85-37" aria-hidden="true" tabindex="-1"></a>            rare_threshold<span class="op">=</span><span class="fl">0.001</span>, smoothing<span class="op">=</span><span class="dv">10</span>, n_splits<span class="op">=</span><span class="dv">5</span></span>
<span id="cb85-38"><a href="#cb85-38" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb85-39"><a href="#cb85-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-40"><a href="#cb85-40" aria-hidden="true" tabindex="-1"></a>        train_merged.drop(columns<span class="op">=</span>[col], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb85-41"><a href="#cb85-41" aria-hidden="true" tabindex="-1"></a>        test_merged.drop(columns<span class="op">=</span>[col], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb85-42"><a href="#cb85-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-43"><a href="#cb85-43" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Done: Boolean, Ordinal, and Target Encoding for 2015–2019 features only."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>✅ Done: Boolean, Ordinal, and Target Encoding for 2015–2019 features only.</code></pre>
</div>
</div>
<div id="fb89c54c" class="cell">
<div class="sourceCode cell-code" id="cb87"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1: Get growth columns from training set</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>growth_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> <span class="st">'_growth'</span> <span class="kw">in</span> col]</span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 2: Compute medians from train_merged only</span></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>growth_medians <span class="op">=</span> {col: train_merged[col].median() <span class="cf">for</span> col <span class="kw">in</span> growth_cols}</span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 3: Apply to both train and test</span></span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> col <span class="kw">in</span> growth_cols:</span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a>            df[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_missing'</span>] <span class="op">=</span> df[col].isna().astype(<span class="bu">int</span>)</span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a>            df[col].fillna(growth_medians[col], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Filled and flagged missing values in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss"> for: </span><span class="sc">{</span>growth_cols<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>✅ Filled and flagged missing values in train_merged for: []
✅ Filled and flagged missing values in test_merged for: []</code></pre>
</div>
</div>
<div id="7d8d65ef" class="cell">
<div class="sourceCode cell-code" id="cb89"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 1: List your growth features ===</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>growth_features <span class="op">=</span> [<span class="st">'land_value_growth'</span>, <span class="st">'building_value_growth'</span>, <span class="st">'assessed_growth'</span>]</span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 2: Binning Function (train-based binning) ===</span></span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bin_growth_feature_safe(train_df, test_df, feature, bins<span class="op">=</span><span class="dv">4</span>):</span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Quantile binning on train only</span></span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true" tabindex="-1"></a>        train_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>], bin_edges <span class="op">=</span> pd.qcut(train_df[feature], q<span class="op">=</span>bins, labels<span class="op">=</span><span class="va">False</span>, retbins<span class="op">=</span><span class="va">True</span>, duplicates<span class="op">=</span><span class="st">'drop'</span>)</span>
<span id="cb89-10"><a href="#cb89-10" aria-hidden="true" tabindex="-1"></a>        test_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>] <span class="op">=</span> pd.cut(test_df[feature], bins<span class="op">=</span>bin_edges, labels<span class="op">=</span><span class="va">False</span>, include_lowest<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb89-11"><a href="#cb89-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">ValueError</span>:</span>
<span id="cb89-12"><a href="#cb89-12" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Fallback: Equal-width binning</span></span>
<span id="cb89-13"><a href="#cb89-13" aria-hidden="true" tabindex="-1"></a>        min_val <span class="op">=</span> train_df[feature].<span class="bu">min</span>()</span>
<span id="cb89-14"><a href="#cb89-14" aria-hidden="true" tabindex="-1"></a>        max_val <span class="op">=</span> train_df[feature].<span class="bu">max</span>()</span>
<span id="cb89-15"><a href="#cb89-15" aria-hidden="true" tabindex="-1"></a>        bin_edges <span class="op">=</span> np.linspace(min_val, max_val, bins <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb89-16"><a href="#cb89-16" aria-hidden="true" tabindex="-1"></a>        train_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>] <span class="op">=</span> pd.cut(train_df[feature], bins<span class="op">=</span>bin_edges, labels<span class="op">=</span><span class="va">False</span>, include_lowest<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb89-17"><a href="#cb89-17" aria-hidden="true" tabindex="-1"></a>        test_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>] <span class="op">=</span> pd.cut(test_df[feature], bins<span class="op">=</span>bin_edges, labels<span class="op">=</span><span class="va">False</span>, include_lowest<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb89-18"><a href="#cb89-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-19"><a href="#cb89-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert to category</span></span>
<span id="cb89-20"><a href="#cb89-20" aria-hidden="true" tabindex="-1"></a>    train_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>] <span class="op">=</span> train_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>].astype(<span class="st">'category'</span>)</span>
<span id="cb89-21"><a href="#cb89-21" aria-hidden="true" tabindex="-1"></a>    test_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>] <span class="op">=</span> test_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>].astype(<span class="st">'category'</span>)</span>
<span id="cb89-22"><a href="#cb89-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> train_df, test_df</span>
<span id="cb89-23"><a href="#cb89-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-24"><a href="#cb89-24" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 3: Apply to train_merged and test_merged ===</span></span>
<span id="cb89-25"><a href="#cb89-25" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> feature <span class="kw">in</span> growth_features:</span>
<span id="cb89-26"><a href="#cb89-26" aria-hidden="true" tabindex="-1"></a>    train_merged, test_merged <span class="op">=</span> bin_growth_feature_safe(train_merged, test_merged, feature)</span>
<span id="cb89-27"><a href="#cb89-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-28"><a href="#cb89-28" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 4: Bin year_built_final using train-based quantiles ===</span></span>
<span id="cb89-29"><a href="#cb89-29" aria-hidden="true" tabindex="-1"></a>train_merged[<span class="st">'year_built_bin'</span>], bin_edges <span class="op">=</span> pd.qcut(</span>
<span id="cb89-30"><a href="#cb89-30" aria-hidden="true" tabindex="-1"></a>    train_merged[<span class="st">'year_built_final'</span>], q<span class="op">=</span><span class="dv">5</span>, retbins<span class="op">=</span><span class="va">True</span>, labels<span class="op">=</span><span class="va">False</span>, duplicates<span class="op">=</span><span class="st">'drop'</span></span>
<span id="cb89-31"><a href="#cb89-31" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb89-32"><a href="#cb89-32" aria-hidden="true" tabindex="-1"></a>test_merged[<span class="st">'year_built_bin'</span>] <span class="op">=</span> pd.cut(</span>
<span id="cb89-33"><a href="#cb89-33" aria-hidden="true" tabindex="-1"></a>    test_merged[<span class="st">'year_built_final'</span>], bins<span class="op">=</span>bin_edges, labels<span class="op">=</span><span class="va">False</span>, include_lowest<span class="op">=</span><span class="va">True</span></span>
<span id="cb89-34"><a href="#cb89-34" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb89-35"><a href="#cb89-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-36"><a href="#cb89-36" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert to category</span></span>
<span id="cb89-37"><a href="#cb89-37" aria-hidden="true" tabindex="-1"></a>train_merged[<span class="st">'year_built_bin'</span>] <span class="op">=</span> train_merged[<span class="st">'year_built_bin'</span>].astype(<span class="st">'category'</span>)</span>
<span id="cb89-38"><a href="#cb89-38" aria-hidden="true" tabindex="-1"></a>test_merged[<span class="st">'year_built_bin'</span>] <span class="op">=</span> test_merged[<span class="st">'year_built_bin'</span>].astype(<span class="st">'category'</span>)</span>
<span id="cb89-39"><a href="#cb89-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-40"><a href="#cb89-40" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 5: Drop original continuous columns ===</span></span>
<span id="cb89-41"><a href="#cb89-41" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> growth_features <span class="op">+</span> [<span class="st">'year_built_final'</span>]</span>
<span id="cb89-42"><a href="#cb89-42" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb89-43"><a href="#cb89-43" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb89-44"><a href="#cb89-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-45"><a href="#cb89-45" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Binned growth &amp; year_built features safely with no leakage."</span>)</span>
<span id="cb89-46"><a href="#cb89-46" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>✅ Binned growth &amp; year_built features safely with no leakage.</code></pre>
</div>
</div>
<div id="cd8e6a4d" class="cell">
<div class="sourceCode cell-code" id="cb91"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>rare_threshold <span class="op">=</span> <span class="fl">0.001</span>  <span class="co"># 0.1%</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>cat_cols <span class="op">=</span> [</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"quality_description_final"</span>,</span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">"foundation_type_final_te"</span>,</span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">"physical_condition_final"</span>,</span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">"exterior_walls_final_te"</span>,</span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">"region_freq"</span>,</span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">"neighborhood_freq"</span></span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> cat_cols:</span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb91-14"><a href="#cb91-14" aria-hidden="true" tabindex="-1"></a>        freq <span class="op">=</span> train_merged[col].value_counts(normalize<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb91-15"><a href="#cb91-15" aria-hidden="true" tabindex="-1"></a>        rare <span class="op">=</span> freq[freq <span class="op">&lt;</span> rare_threshold]</span>
<span id="cb91-16"><a href="#cb91-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> rare.empty:</span>
<span id="cb91-17"><a href="#cb91-17" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss"> Rare categories in '</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">' (less than 0.1% of training data):</span><span class="ch">\n</span><span class="sc">{</span>rare<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb91-18"><a href="#cb91-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb91-19"><a href="#cb91-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Column '</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">' not found in train_merged"</span>)</span>
<span id="cb91-20"><a href="#cb91-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-21"><a href="#cb91-21" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>⚠️ Column 'quality_description_final' not found in train_merged
⚠️ Column 'foundation_type_final_te' not found in train_merged
⚠️ Column 'physical_condition_final' not found in train_merged
⚠️ Column 'exterior_walls_final_te' not found in train_merged

⚠️ Rare categories in 'region_freq' (less than 0.1% of training data):
region_freq
0.000963    0.000963
0.000641    0.000641
0.000347    0.000347
0.000159    0.000159
0.000083    0.000083
0.000010    0.000019
0.000002    0.000019
0.000008    0.000016
0.000005    0.000005
Name: proportion, dtype: float64

⚠️ Rare categories in 'neighborhood_freq' (less than 0.1% of training data):
neighborhood_freq
0.000500    0.001000
0.000996    0.000996
0.000988    0.000988
0.000984    0.000984
0.000492    0.000984
              ...   
0.000008    0.000024
0.000021    0.000021
0.000014    0.000014
0.000002    0.000006
0.000003    0.000006
Name: proportion, Length: 321, dtype: float64</code></pre>
</div>
</div>
<div id="76763d50" class="cell">
<div class="sourceCode cell-code" id="cb93"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define frequency columns and threshold</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>freq_cols <span class="op">=</span> [<span class="st">'region_freq'</span>, <span class="st">'neighborhood_freq'</span>, <span class="st">'zone_freq'</span>, <span class="st">'subneighborhood_freq'</span>]</span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>rare_thresh <span class="op">=</span> <span class="fl">0.001</span></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply rare value replacement for each frequency column</span></span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> freq_cols:</span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true" tabindex="-1"></a>        rare_vals <span class="op">=</span> train_merged[col].value_counts(normalize<span class="op">=</span><span class="va">True</span>)[<span class="kw">lambda</span> x: x <span class="op">&lt;</span> rare_thresh].index</span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true" tabindex="-1"></a>        train_merged[col] <span class="op">=</span> train_merged[col].replace(rare_vals, <span class="dv">0</span>)</span>
<span id="cb93-10"><a href="#cb93-10" aria-hidden="true" tabindex="-1"></a>        test_merged[col] <span class="op">=</span> test_merged[col].replace(rare_vals, <span class="dv">0</span>)</span>
<span id="cb93-11"><a href="#cb93-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Replaced rare values in </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> using train_merged threshold &lt; </span><span class="sc">{</span>rare_thresh<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb93-12"><a href="#cb93-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb93-13"><a href="#cb93-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Column </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> not found in train_merged — skipping."</span>)</span>
<span id="cb93-14"><a href="#cb93-14" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>✅ Replaced rare values in region_freq using train_merged threshold &lt; 0.001
✅ Replaced rare values in neighborhood_freq using train_merged threshold &lt; 0.001
✅ Replaced rare values in zone_freq using train_merged threshold &lt; 0.001
✅ Replaced rare values in subneighborhood_freq using train_merged threshold &lt; 0.001</code></pre>
</div>
</div>
<div id="d6e9a847" class="cell">
<div class="sourceCode cell-code" id="cb95"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 1: Skew-based Log Transformation (2015–2019 only) ===</span></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>log_bases <span class="op">=</span> [</span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">'floor_area_total'</span>, <span class="st">'porch_area'</span>, <span class="st">'building_area'</span>, <span class="st">'land_area'</span>,</span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_value'</span>, <span class="st">'land_value'</span>, <span class="st">'assessed'</span></span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb95-8"><a href="#cb95-8" aria-hidden="true" tabindex="-1"></a>neigh_stat_cols <span class="op">=</span> [</span>
<span id="cb95-9"><a href="#cb95-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">'neigh_assess_mean'</span>, <span class="st">'neigh_assess_std'</span>, <span class="st">'neigh_assess_median'</span>,</span>
<span id="cb95-10"><a href="#cb95-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">'neigh_assess_q1'</span>, <span class="st">'neigh_assess_q3'</span></span>
<span id="cb95-11"><a href="#cb95-11" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb95-12"><a href="#cb95-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-13"><a href="#cb95-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Collect log-transformable columns (2015–2019 + neighborhood stats)</span></span>
<span id="cb95-14"><a href="#cb95-14" aria-hidden="true" tabindex="-1"></a>log_transform_cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> base <span class="kw">in</span> log_bases <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)]</span>
<span id="cb95-15"><a href="#cb95-15" aria-hidden="true" tabindex="-1"></a>log_transform_cols <span class="op">+=</span> neigh_stat_cols</span>
<span id="cb95-16"><a href="#cb95-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-17"><a href="#cb95-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute skewness on train and apply log1p only if skew &gt; 2</span></span>
<span id="cb95-18"><a href="#cb95-18" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> log_transform_cols:</span>
<span id="cb95-19"><a href="#cb95-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb95-20"><a href="#cb95-20" aria-hidden="true" tabindex="-1"></a>        skew <span class="op">=</span> train_merged[col].skew()</span>
<span id="cb95-21"><a href="#cb95-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> skew <span class="op">&gt;</span> <span class="dv">2</span>:</span>
<span id="cb95-22"><a href="#cb95-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> df <span class="kw">in</span> [train_merged, test_merged]:</span>
<span id="cb95-23"><a href="#cb95-23" aria-hidden="true" tabindex="-1"></a>                df[<span class="ss">f"log_</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">"</span>] <span class="op">=</span> np.log1p(df[col])</span>
<span id="cb95-24"><a href="#cb95-24" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Log-transformed: </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> (skew=</span><span class="sc">{</span>skew<span class="sc">:.2f}</span><span class="ss">)"</span>)</span>
<span id="cb95-25"><a href="#cb95-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb95-26"><a href="#cb95-26" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"ℹ Skipped: </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> (skew=</span><span class="sc">{</span>skew<span class="sc">:.2f}</span><span class="ss">)"</span>)</span>
<span id="cb95-27"><a href="#cb95-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-28"><a href="#cb95-28" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 2: Percentile Clipping at 0.1%–99.9% ===</span></span>
<span id="cb95-29"><a href="#cb95-29" aria-hidden="true" tabindex="-1"></a>clip_bases <span class="op">=</span> [<span class="st">'floors'</span>, <span class="st">'full_bath'</span>, <span class="st">'total_rooms'</span>, <span class="st">'bedrooms'</span>]</span>
<span id="cb95-30"><a href="#cb95-30" aria-hidden="true" tabindex="-1"></a>clip_cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> base <span class="kw">in</span> clip_bases <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)]</span>
<span id="cb95-31"><a href="#cb95-31" aria-hidden="true" tabindex="-1"></a>clip_cols <span class="op">+=</span> [<span class="st">'neigh_count'</span>]  <span class="co"># add any other specific columns if needed</span></span>
<span id="cb95-32"><a href="#cb95-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-33"><a href="#cb95-33" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute clipping bounds from train</span></span>
<span id="cb95-34"><a href="#cb95-34" aria-hidden="true" tabindex="-1"></a>clip_bounds <span class="op">=</span> {</span>
<span id="cb95-35"><a href="#cb95-35" aria-hidden="true" tabindex="-1"></a>    col: (</span>
<span id="cb95-36"><a href="#cb95-36" aria-hidden="true" tabindex="-1"></a>        train_merged[col].quantile(<span class="fl">0.001</span>),</span>
<span id="cb95-37"><a href="#cb95-37" aria-hidden="true" tabindex="-1"></a>        train_merged[col].quantile(<span class="fl">0.999</span>)</span>
<span id="cb95-38"><a href="#cb95-38" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb95-39"><a href="#cb95-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> col <span class="kw">in</span> clip_cols <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns</span>
<span id="cb95-40"><a href="#cb95-40" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb95-41"><a href="#cb95-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-42"><a href="#cb95-42" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply clipping to both train and test</span></span>
<span id="cb95-43"><a href="#cb95-43" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col, (lower, upper) <span class="kw">in</span> clip_bounds.items():</span>
<span id="cb95-44"><a href="#cb95-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> df <span class="kw">in</span> [train_merged, test_merged]:</span>
<span id="cb95-45"><a href="#cb95-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb95-46"><a href="#cb95-46" aria-hidden="true" tabindex="-1"></a>            df[col] <span class="op">=</span> np.clip(df[col], lower, upper)</span>
<span id="cb95-47"><a href="#cb95-47" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Clipped: </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> to [</span><span class="sc">{</span>lower<span class="sc">:.2f}</span><span class="ss">, </span><span class="sc">{</span>upper<span class="sc">:.2f}</span><span class="ss">]"</span>)</span>
<span id="cb95-48"><a href="#cb95-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-49"><a href="#cb95-49" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> Finished: Skew-aware log transformation + 0.001–0.999 percentile clipping."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>📉 Log-transformed: floor_area_total_2015 (skew=2.22)
📉 Log-transformed: floor_area_total_2016 (skew=2.37)
📉 Log-transformed: floor_area_total_2017 (skew=2.62)
📉 Log-transformed: floor_area_total_2018 (skew=2.83)
📉 Log-transformed: floor_area_total_2019 (skew=3.06)
📉 Log-transformed: porch_area_2015 (skew=4.95)
📉 Log-transformed: porch_area_2016 (skew=4.87)
📉 Log-transformed: porch_area_2017 (skew=4.84)
📉 Log-transformed: porch_area_2018 (skew=4.75)</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>/usr/local/lib/python3.11/site-packages/pandas/core/arraylike.py:399: RuntimeWarning: invalid value encountered in log1p
  result = getattr(ufunc, method)(*inputs, **kwargs)
/usr/local/lib/python3.11/site-packages/pandas/core/arraylike.py:399: RuntimeWarning: invalid value encountered in log1p
  result = getattr(ufunc, method)(*inputs, **kwargs)
/usr/local/lib/python3.11/site-packages/pandas/core/arraylike.py:399: RuntimeWarning: invalid value encountered in log1p
  result = getattr(ufunc, method)(*inputs, **kwargs)
/usr/local/lib/python3.11/site-packages/pandas/core/arraylike.py:399: RuntimeWarning: invalid value encountered in log1p
  result = getattr(ufunc, method)(*inputs, **kwargs)</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>📉 Log-transformed: porch_area_2019 (skew=4.67)
📉 Log-transformed: building_area_2015 (skew=2.75)
📉 Log-transformed: building_area_2016 (skew=2.76)
📉 Log-transformed: building_area_2017 (skew=2.82)
📉 Log-transformed: building_area_2018 (skew=2.81)
📉 Log-transformed: building_area_2019 (skew=2.83)
📉 Log-transformed: land_area_2015 (skew=656.66)
📉 Log-transformed: land_area_2016 (skew=560.38)
📉 Log-transformed: land_area_2017 (skew=792.64)
📉 Log-transformed: land_area_2018 (skew=721.01)
📉 Log-transformed: land_area_2019 (skew=501.85)
📉 Log-transformed: building_value_2015 (skew=7.90)
📉 Log-transformed: building_value_2016 (skew=7.79)
📉 Log-transformed: building_value_2017 (skew=7.58)
📉 Log-transformed: building_value_2018 (skew=7.61)
📉 Log-transformed: land_value_2015 (skew=16.10)
📉 Log-transformed: land_value_2016 (skew=15.40)
📉 Log-transformed: land_value_2017 (skew=15.71)
📉 Log-transformed: land_value_2018 (skew=15.18)
📉 Log-transformed: assessed_2015 (skew=10.40)
📉 Log-transformed: assessed_2016 (skew=10.45)
📉 Log-transformed: assessed_2017 (skew=10.48)
📉 Log-transformed: assessed_2018 (skew=10.47)
📉 Log-transformed: neigh_assess_mean (skew=5.73)
📉 Log-transformed: neigh_assess_std (skew=8.41)</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/4250956199.py:23: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f"log_{col}"] = np.log1p(df[col])
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/4250956199.py:23: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f"log_{col}"] = np.log1p(df[col])
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/4250956199.py:23: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f"log_{col}"] = np.log1p(df[col])
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/4250956199.py:23: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f"log_{col}"] = np.log1p(df[col])
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/4250956199.py:23: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f"log_{col}"] = np.log1p(df[col])
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/4250956199.py:23: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f"log_{col}"] = np.log1p(df[col])
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/4250956199.py:23: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f"log_{col}"] = np.log1p(df[col])
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/4250956199.py:23: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f"log_{col}"] = np.log1p(df[col])
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/4250956199.py:23: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f"log_{col}"] = np.log1p(df[col])
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/4250956199.py:23: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f"log_{col}"] = np.log1p(df[col])
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/4250956199.py:23: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f"log_{col}"] = np.log1p(df[col])
/var/folders/sl/hc9dmfps60l7lq3bh_fp8ny40000gn/T/ipykernel_32068/4250956199.py:23: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f"log_{col}"] = np.log1p(df[col])</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>📉 Log-transformed: neigh_assess_median (skew=5.25)
📉 Log-transformed: neigh_assess_q1 (skew=4.89)
📉 Log-transformed: neigh_assess_q3 (skew=5.84)
✂️ Clipped: floors_2015 to [1.00, 4.00]
✂️ Clipped: floors_2016 to [1.00, 4.00]
✂️ Clipped: floors_2017 to [1.00, 4.00]
✂️ Clipped: floors_2018 to [1.00, 4.00]
✂️ Clipped: floors_2019 to [1.00, 4.00]
✂️ Clipped: full_bath_2015 to [1.00, 6.00]
✂️ Clipped: full_bath_2016 to [1.00, 6.00]
✂️ Clipped: full_bath_2017 to [1.00, 6.00]
✂️ Clipped: full_bath_2018 to [1.00, 7.00]
✂️ Clipped: full_bath_2019 to [1.00, 7.00]
✂️ Clipped: total_rooms_2015 to [2.00, 17.00]
✂️ Clipped: total_rooms_2016 to [2.00, 17.00]
✂️ Clipped: total_rooms_2017 to [2.00, 17.00]
✂️ Clipped: total_rooms_2018 to [3.00, 17.00]
✂️ Clipped: total_rooms_2019 to [3.00, 17.00]
✂️ Clipped: bedrooms_2015 to [1.00, 8.00]
✂️ Clipped: bedrooms_2016 to [1.00, 8.00]
✂️ Clipped: bedrooms_2017 to [1.00, 8.00]
✂️ Clipped: bedrooms_2018 to [1.00, 8.00]
✂️ Clipped: bedrooms_2019 to [1.00, 8.00]

✅ Finished: Skew-aware log transformation + 0.001–0.999 percentile clipping.</code></pre>
</div>
</div>
<div id="a5b0ff76" class="cell" data-execution_count="51">
<div class="sourceCode cell-code" id="cb101"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add_features(df):</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.copy()</span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Ratio features ===</span></span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'area_ratio'</span>] <span class="op">=</span> df[<span class="st">'building_area_2019'</span>] <span class="op">/</span> (df[<span class="st">'land_area_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'porch_ratio'</span>] <span class="op">=</span> df[<span class="st">'porch_area_2019'</span>] <span class="op">/</span> (df[<span class="st">'building_area_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'floor_density'</span>] <span class="op">=</span> df[<span class="st">'floor_area_total_2019'</span>] <span class="op">/</span> (df[<span class="st">'land_area_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb101-8"><a href="#cb101-8" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'log_build_density'</span>] <span class="op">=</span> df[<span class="st">'log_building_area_2019'</span>] <span class="op">-</span> df[<span class="st">'log_land_area_2019'</span>]</span>
<span id="cb101-9"><a href="#cb101-9" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'log_land_to_build_ratio'</span>] <span class="op">=</span> df[<span class="st">'log_land_area_2019'</span>] <span class="op">-</span> df[<span class="st">'log_building_area_2019'</span>]</span>
<span id="cb101-10"><a href="#cb101-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-11"><a href="#cb101-11" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'value_ratio'</span>] <span class="op">=</span> df[<span class="st">'building_value_2018'</span>] <span class="op">/</span> (df[<span class="st">'land_value_2018'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb101-12"><a href="#cb101-12" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'log_value_diff'</span>] <span class="op">=</span> df[<span class="st">'log_building_value_2018'</span>] <span class="op">-</span> df[<span class="st">'log_land_value_2018'</span>]</span>
<span id="cb101-13"><a href="#cb101-13" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'value_per_sqft'</span>] <span class="op">=</span> df[<span class="st">'building_value_2018'</span>] <span class="op">/</span> (df[<span class="st">'building_area_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb101-14"><a href="#cb101-14" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'price_per_sqft'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">/</span> (df[<span class="st">'building_area_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb101-15"><a href="#cb101-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-16"><a href="#cb101-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Bathroom &amp; room structure ===</span></span>
<span id="cb101-17"><a href="#cb101-17" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'bathroom_score'</span>] <span class="op">=</span> df[<span class="st">'full_bath_2019'</span>] <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> df[<span class="st">'half_bath_2019'</span>]</span>
<span id="cb101-18"><a href="#cb101-18" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'bathroom_density'</span>] <span class="op">=</span> df[<span class="st">'bathroom_score'</span>] <span class="op">/</span> (df[<span class="st">'total_rooms_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb101-19"><a href="#cb101-19" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'bedroom_ratio'</span>] <span class="op">=</span> df[<span class="st">'bedrooms_2019'</span>] <span class="op">/</span> (df[<span class="st">'total_rooms_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb101-20"><a href="#cb101-20" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'rooms_per_floor'</span>] <span class="op">=</span> df[<span class="st">'total_rooms_2019'</span>] <span class="op">/</span> (df[<span class="st">'floors_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb101-21"><a href="#cb101-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-22"><a href="#cb101-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Core interactions ===</span></span>
<span id="cb101-23"><a href="#cb101-23" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'bedrooms_x_floors'</span>] <span class="op">=</span> df[<span class="st">'bedrooms_2019'</span>] <span class="op">*</span> df[<span class="st">'floors_2019'</span>]</span>
<span id="cb101-24"><a href="#cb101-24" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'rooms_x_quality'</span>] <span class="op">=</span> df[<span class="st">'total_rooms_2019'</span>] <span class="op">*</span> df[<span class="st">'quality_2019'</span>]</span>
<span id="cb101-25"><a href="#cb101-25" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'log_area_x_grade'</span>] <span class="op">=</span> df[<span class="st">'log_building_area_2019'</span>] <span class="op">*</span> df[<span class="st">'grade_2019'</span>]</span>
<span id="cb101-26"><a href="#cb101-26" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'log_assess_x_age'</span>] <span class="op">=</span> df[<span class="st">'log_assessed_2018'</span>] <span class="op">*</span> df[<span class="st">'building_age'</span>]</span>
<span id="cb101-27"><a href="#cb101-27" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'assess_spread_neigh'</span>] <span class="op">=</span> df[<span class="st">'log_neigh_assess_q3'</span>] <span class="op">-</span> df[<span class="st">'log_neigh_assess_q1'</span>]</span>
<span id="cb101-28"><a href="#cb101-28" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'grade_quality_index'</span>] <span class="op">=</span> df[<span class="st">'grade_2019'</span>] <span class="op">*</span> df[<span class="st">'quality_2019'</span>]</span>
<span id="cb101-29"><a href="#cb101-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-30"><a href="#cb101-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Clean up ===</span></span>
<span id="cb101-31"><a href="#cb101-31" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.replace([np.inf, <span class="op">-</span>np.inf], np.nan)</span>
<span id="cb101-32"><a href="#cb101-32" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.fillna(<span class="dv">0</span>)</span>
<span id="cb101-33"><a href="#cb101-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb101-34"><a href="#cb101-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-35"><a href="#cb101-35" aria-hidden="true" tabindex="-1"></a><span class="co"># === Apply to train and test ===</span></span>
<span id="cb101-36"><a href="#cb101-36" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> add_features(train_merged)</span>
<span id="cb101-37"><a href="#cb101-37" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> add_features(test_merged)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="2ebdae67" class="cell">
<div class="sourceCode cell-code" id="cb102"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Select numeric columns only</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>numeric_features <span class="op">=</span> train_merged.select_dtypes(include<span class="op">=</span>[<span class="st">'int64'</span>, <span class="st">'float64'</span>])</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate skewness</span></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a>skewness <span class="op">=</span> numeric_features.skew(numeric_only<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter and sort features with skewness &gt; 30</span></span>
<span id="cb102-8"><a href="#cb102-8" aria-hidden="true" tabindex="-1"></a>highly_skewed <span class="op">=</span> skewness[skewness <span class="op">&gt;</span> <span class="dv">2</span>].sort_values(ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb102-9"><a href="#cb102-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-10"><a href="#cb102-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Features with skewness &gt; 2:"</span>)</span>
<span id="cb102-11"><a href="#cb102-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(highly_skewed)</span>
<span id="cb102-12"><a href="#cb102-12" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>📊 Features with skewness &gt; 2:
land_area_2017             792.639441
land_area_2018             721.010870
land_area_2015             656.661667
land_area_2016             560.378106
value_ratio                502.848761
                              ...    
floor_area_primary_2018      2.664604
floor_area_total_2017        2.621085
floor_area_primary_2017      2.414200
floor_area_total_2016        2.372924
floor_area_total_2015        2.224773
Length: 76, dtype: float64</code></pre>
</div>
</div>
<div id="73623d7c" class="cell">
<div class="sourceCode cell-code" id="cb104"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="co"># List of columns to drop due to extreme skewness</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> [<span class="st">'building_value_growth_missing'</span>, <span class="st">'land_value_growth_missing'</span>,<span class="st">'assessed_growth_missing'</span>]</span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop from both train and test</span></span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>, errors<span class="op">=</span><span class="st">'ignore'</span>)</span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>, errors<span class="op">=</span><span class="st">'ignore'</span>)</span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-8"><a href="#cb104-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Dropped extremely skewed columns related to value growth missingness."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>✅ Dropped extremely skewed columns related to value growth missingness.</code></pre>
</div>
</div>
<div id="d46be7d3" class="cell">
<div class="sourceCode cell-code" id="cb106"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Features to log-transform due to extreme skew</span></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a>skewed_cols <span class="op">=</span> [<span class="st">'price_per_sqft'</span>, <span class="st">'value_per_sqft'</span>, <span class="st">'porch_ratio'</span>, <span class="st">'value_ratio'</span>,<span class="st">'land_area_2015'</span>,<span class="st">'land_area_2016'</span>,<span class="st">'land_area_2017'</span>,<span class="st">'land_area_2018'</span>,<span class="st">'land_area_2019'</span>]</span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> col <span class="kw">in</span> skewed_cols:</span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb106-9"><a href="#cb106-9" aria-hidden="true" tabindex="-1"></a>            df[<span class="ss">f'log_</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">'</span>] <span class="op">=</span> np.log1p(df[col])</span>
<span id="cb106-10"><a href="#cb106-10" aria-hidden="true" tabindex="-1"></a>            df.drop(columns<span class="op">=</span>col, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb106-11"><a href="#cb106-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-12"><a href="#cb106-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Log-transformed and dropped raw versions of highly skewed ratio features."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>✅ Log-transformed and dropped raw versions of highly skewed ratio features.</code></pre>
</div>
</div>
<div id="019c5a07" class="cell" data-execution_count="57">
<div class="sourceCode cell-code" id="cb108"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">"TARGET"</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a>    train_merged.drop(<span class="st">"TARGET"</span>, axis<span class="op">=</span><span class="dv">1</span>,inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"TARGET not found in columns:"</span>, train_merged.columns.tolist())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="7839d78b" class="cell">
<div class="sourceCode cell-code" id="cb109"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define columns to drop</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>year_built_cols <span class="op">=</span> [<span class="ss">f'year_built_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)]</span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop if columns exist</span></span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>[col <span class="cf">for</span> col <span class="kw">in</span> year_built_cols <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>[col <span class="cf">for</span> col <span class="kw">in</span> year_built_cols <span class="cf">if</span> col <span class="kw">in</span> test_merged.columns], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Dropped year_built_2015 to year_built_2018 from both train and test sets."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>✅ Dropped year_built_2015 to year_built_2018 from both train and test sets.</code></pre>
</div>
</div>
<div id="550aa48d" class="cell">
<div class="sourceCode cell-code" id="cb111"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a>train_cols <span class="op">=</span> <span class="bu">set</span>(train_merged.columns)</span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>test_cols <span class="op">=</span> <span class="bu">set</span>(test_merged.columns)</span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a>missing_in_test <span class="op">=</span> train_cols <span class="op">-</span> test_cols</span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a>missing_in_train <span class="op">=</span> test_cols <span class="op">-</span> train_cols</span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Columns in train but not in test:"</span>)</span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">sorted</span>(missing_in_test))</span>
<span id="cb111-9"><a href="#cb111-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-10"><a href="#cb111-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> Columns in test but not in train:"</span>)</span>
<span id="cb111-11"><a href="#cb111-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">sorted</span>(missing_in_train))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>✅ Columns in train but not in test:
[]

❌ Columns in test but not in train:
[]</code></pre>
</div>
</div>
<div id="2348f6a4" class="cell" data-execution_count="60">
<div class="sourceCode cell-code" id="cb113"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Check if column sets match</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">set</span>(train_merged.columns) <span class="op">==</span> <span class="bu">set</span>(test_merged.columns))  <span class="co"># Should be True</span></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Check if column order matches</span></span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">list</span>(train_merged.columns) <span class="op">==</span> <span class="bu">list</span>(test_merged.columns))  <span class="co"># Must also be True</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>True
True</code></pre>
</div>
</div>
<div id="8e466ade" class="cell">
<div class="sourceCode cell-code" id="cb115"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> RidgeCV</span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.pipeline <span class="im">import</span> make_pipeline</span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> KFold</span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> root_mean_squared_error</span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> KFold</span>
<span id="cb115-9"><a href="#cb115-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-10"><a href="#cb115-10" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 2: Prepare training/test matrices ===</span></span>
<span id="cb115-11"><a href="#cb115-11" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> train_merged.copy()</span>
<span id="cb115-12"><a href="#cb115-12" aria-hidden="true" tabindex="-1"></a>X_test <span class="op">=</span> test_merged.copy()</span>
<span id="cb115-13"><a href="#cb115-13" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> pd.Series(y_train).values <span class="co"># use raw target (not log)</span></span>
<span id="cb115-14"><a href="#cb115-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-15"><a href="#cb115-15" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 3: RidgeCV pipeline ===</span></span>
<span id="cb115-16"><a href="#cb115-16" aria-hidden="true" tabindex="-1"></a>kf <span class="op">=</span> KFold(n_splits<span class="op">=</span><span class="dv">3</span>, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb115-17"><a href="#cb115-17" aria-hidden="true" tabindex="-1"></a>alphas <span class="op">=</span> np.logspace(<span class="op">-</span><span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">10</span>)</span>
<span id="cb115-18"><a href="#cb115-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-19"><a href="#cb115-19" aria-hidden="true" tabindex="-1"></a>ridge_oof <span class="op">=</span> np.zeros(<span class="bu">len</span>(X))</span>
<span id="cb115-20"><a href="#cb115-20" aria-hidden="true" tabindex="-1"></a>ridge_test_preds <span class="op">=</span> np.zeros(<span class="bu">len</span>(X_test))</span>
<span id="cb115-21"><a href="#cb115-21" aria-hidden="true" tabindex="-1"></a>best_alphas <span class="op">=</span> []</span>
<span id="cb115-22"><a href="#cb115-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-23"><a href="#cb115-23" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> fold, (train_idx, val_idx) <span class="kw">in</span> <span class="bu">enumerate</span>(kf.split(X)):</span>
<span id="cb115-24"><a href="#cb115-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss"> Fold </span><span class="sc">{</span>fold<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">/5"</span>)</span>
<span id="cb115-25"><a href="#cb115-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-26"><a href="#cb115-26" aria-hidden="true" tabindex="-1"></a>    X_train, y_train_fold <span class="op">=</span> X.iloc[train_idx], y[train_idx]</span>
<span id="cb115-27"><a href="#cb115-27" aria-hidden="true" tabindex="-1"></a>    X_val, y_val <span class="op">=</span> X.iloc[val_idx], y[val_idx]</span>
<span id="cb115-28"><a href="#cb115-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-29"><a href="#cb115-29" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> make_pipeline(</span>
<span id="cb115-30"><a href="#cb115-30" aria-hidden="true" tabindex="-1"></a>        StandardScaler(),</span>
<span id="cb115-31"><a href="#cb115-31" aria-hidden="true" tabindex="-1"></a>        RidgeCV(alphas<span class="op">=</span>alphas, cv<span class="op">=</span><span class="dv">3</span>, scoring<span class="op">=</span><span class="st">'neg_root_mean_squared_error'</span>)</span>
<span id="cb115-32"><a href="#cb115-32" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb115-33"><a href="#cb115-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-34"><a href="#cb115-34" aria-hidden="true" tabindex="-1"></a>    model.fit(X_train, y_train_fold)</span>
<span id="cb115-35"><a href="#cb115-35" aria-hidden="true" tabindex="-1"></a>    ridge_oof[val_idx] <span class="op">=</span> model.predict(X_val)</span>
<span id="cb115-36"><a href="#cb115-36" aria-hidden="true" tabindex="-1"></a>    ridge_test_preds <span class="op">+=</span> model.predict(X_test) <span class="op">/</span> kf.get_n_splits()</span>
<span id="cb115-37"><a href="#cb115-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-38"><a href="#cb115-38" aria-hidden="true" tabindex="-1"></a>    best_alpha <span class="op">=</span> model.named_steps[<span class="st">'ridgecv'</span>].alpha_</span>
<span id="cb115-39"><a href="#cb115-39" aria-hidden="true" tabindex="-1"></a>    best_alphas.append(best_alpha)</span>
<span id="cb115-40"><a href="#cb115-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb115-41"><a href="#cb115-41" aria-hidden="true" tabindex="-1"></a>    fold_rmse <span class="op">=</span> root_mean_squared_error(y_val, ridge_oof[val_idx])</span>
<span id="cb115-42"><a href="#cb115-42" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Fold </span><span class="sc">{</span>fold<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss"> RMSE: </span><span class="sc">{</span>fold_rmse<span class="sc">:,.2f}</span><span class="ss"> | Best alpha: </span><span class="sc">{</span>best_alpha<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb115-43"><a href="#cb115-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-44"><a href="#cb115-44" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 4: Final RMSE ===</span></span>
<span id="cb115-45"><a href="#cb115-45" aria-hidden="true" tabindex="-1"></a>final_rmse <span class="op">=</span> root_mean_squared_error(y, ridge_oof)</span>
<span id="cb115-46"><a href="#cb115-46" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss"> Final OOF RMSE (RidgeCV): </span><span class="sc">{</span>final_rmse<span class="sc">:,.2f}</span><span class="ss">"</span>)</span>
<span id="cb115-47"><a href="#cb115-47" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" Average best alpha across folds: </span><span class="sc">{</span>np<span class="sc">.</span>mean(best_alphas)<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb115-48"><a href="#cb115-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-49"><a href="#cb115-49" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 5: Save predictions ===</span></span>
<span id="cb115-50"><a href="#cb115-50" aria-hidden="true" tabindex="-1"></a>submission <span class="op">=</span> pd.DataFrame({</span>
<span id="cb115-51"><a href="#cb115-51" aria-hidden="true" tabindex="-1"></a>    <span class="st">"ACCOUNT"</span>: acct_test.values.ravel(),</span>
<span id="cb115-52"><a href="#cb115-52" aria-hidden="true" tabindex="-1"></a>    <span class="st">"TARGET"</span>: ridge_test_preds</span>
<span id="cb115-53"><a href="#cb115-53" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb115-54"><a href="#cb115-54" aria-hidden="true" tabindex="-1"></a>submission.to_csv(<span class="st">"submission_ridgecv_pipeline.csv"</span>, index<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb115-55"><a href="#cb115-55" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> Saved: submission_ridgecv_pipeline.csv"</span>)</span>
<span id="cb115-56"><a href="#cb115-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-57"><a href="#cb115-57" aria-hidden="true" tabindex="-1"></a><span class="co"># === Optional: Save OOF &amp; test preds for stacking or analysis ===</span></span>
<span id="cb115-58"><a href="#cb115-58" aria-hidden="true" tabindex="-1"></a>np.save(<span class="st">"ridgecv_oof_preds.npy"</span>, ridge_oof)</span>
<span id="cb115-59"><a href="#cb115-59" aria-hidden="true" tabindex="-1"></a>np.save(<span class="st">"ridgecv_test_preds.npy"</span>, ridge_test_preds)</span>
<span id="cb115-60"><a href="#cb115-60" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Saved: ridgecv_oof_preds.npy and ridgecv_test_preds.npy"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
📂 Fold 1/5
📉 Fold 1 RMSE: 42,050.33 | Best alpha: 2.1544

📂 Fold 2/5
📉 Fold 2 RMSE: 41,036.52 | Best alpha: 27.8256

📂 Fold 3/5
📉 Fold 3 RMSE: 40,619.40 | Best alpha: 0.5995

🏁 Final OOF RMSE (RidgeCV): 41,239.79
🔍 Average best alpha across folds: 10.1932

📤 Saved: submission_ridgecv_pipeline.csv
📦 Saved: ridgecv_oof_preds.npy and ridgecv_test_preds.npy</code></pre>
</div>
</div>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>