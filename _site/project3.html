<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>STA 9890 Project: Property Valuation ‚Äì Statisitical Learning for Data Mining Project Portfolio</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-6bd9cfa162949bde0a231f530c97869d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Statisitical Learning for Data Mining Project Portfolio</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./project1.qmd"> 
<span class="menu-text">Bias and Variance in Linear Regression</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./project2.qmd"> 
<span class="menu-text">Ensemble Learning Techniques for Fair Classification</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./project3.html" aria-current="page"> 
<span class="menu-text">Forecasting Property Valuations in a Mid-Sized U.S. City:A SHAP-Gain Feature Selection and ElasticNet-Ensembled Approach with Optuna-Tuned XGBoost</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#full-report" id="toc-full-report" class="nav-link active" data-scroll-target="#full-report">üìÑ Full Report</a></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">üîç Summary</a></li>
  <li><a href="#full-modeling-pipeline" id="toc-full-modeling-pipeline" class="nav-link" data-scroll-target="#full-modeling-pipeline">üöÄ Full Modeling Pipeline</a></li>
  <li><a href="#ridge-regression-pipeline" id="toc-ridge-regression-pipeline" class="nav-link" data-scroll-target="#ridge-regression-pipeline">Ridge Regression Pipeline</a></li>
  <li><a href="#xgboost-lightgbm-pipeline" id="toc-xgboost-lightgbm-pipeline" class="nav-link" data-scroll-target="#xgboost-lightgbm-pipeline">XGBoost &amp; LightGBM Pipeline</a></li>
  <li><a href="#rmse-optimization" id="toc-rmse-optimization" class="nav-link" data-scroll-target="#rmse-optimization">RMSE Optimization</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">STA 9890 Project: Property Valuation</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="full-report" class="level2">
<h2 class="anchored" data-anchor-id="full-report">üìÑ Full Report</h2>
<p><a href="files/9890_Final_Report.pdf">Download the full PDF report</a></p>
</section>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">üîç Summary</h2>
<ul>
<li><strong>Task</strong>: Predict 2019 assessed property value using structured property records from 2015‚Äì2019</li>
<li><strong>Models</strong>: RidgeCV, XGBoost, LightGBM</li>
<li><strong>Feature Selection</strong>: SHAP + Gain union</li>
<li><strong>Ensembling</strong>: Optuna weights + ElasticNet stacked</li>
<li><strong>Top RMSE</strong>: 36,021 on private leaderboard (ElasticNet ensemble)</li>
</ul>
<hr>
</section>
<section id="full-modeling-pipeline" class="level2">
<h2 class="anchored" data-anchor-id="full-modeling-pipeline">üöÄ Full Modeling Pipeline</h2>
</section>
<section id="ridge-regression-pipeline" class="level1">
<h1>Ridge Regression Pipeline</h1>
<div id="392eced3" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># ===== Load Data =====</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>folder_path <span class="op">=</span> <span class="st">'/Users/Srijith97/Downloads/STA 9890 Housing Data/'</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>building_years <span class="op">=</span> []</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>):</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.read_csv(folder_path <span class="op">+</span> <span class="ss">f'building_details_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">.csv'</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'year'</span>] <span class="op">=</span> year</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    building_years.append(df)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>building_all <span class="op">=</span> pd.concat(building_years, ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>building_all <span class="op">=</span> building_all.drop_duplicates(subset<span class="op">=</span>[<span class="st">'acct'</span>, <span class="st">'year'</span>], keep<span class="op">=</span><span class="st">'first'</span>)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>pivoted <span class="op">=</span> building_all.pivot(index<span class="op">=</span><span class="st">'acct'</span>, columns<span class="op">=</span><span class="st">'year'</span>)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>pivoted.columns <span class="op">=</span> [<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> col, year <span class="kw">in</span> pivoted.columns]</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>pivoted <span class="op">=</span> pivoted.reset_index()</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>train <span class="op">=</span> pd.read_csv(folder_path <span class="op">+</span> <span class="st">'assessment_history_train.csv'</span>)</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>test <span class="op">=</span> pd.read_csv(folder_path <span class="op">+</span> <span class="st">'assessment_history_test.csv'</span>)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> train.merge(pivoted, on<span class="op">=</span><span class="st">'acct'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> test.merge(pivoted, on<span class="op">=</span><span class="st">'acct'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="4a8b9a91" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1: Identify all '2019' columns in train</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>train_2019_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> <span class="st">'2019'</span> <span class="kw">in</span> col]</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 2: Find which 2019 columns are missing in test</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>train_only_2019_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_2019_cols <span class="cf">if</span> col <span class="kw">not</span> <span class="kw">in</span> test_merged.columns]</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 3: Always drop 'protested_2019' due to leakage risk</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>train_only_2019_cols.append(<span class="st">'protested_2019'</span>)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 4: Drop the identified columns from train</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> train_merged.drop(columns<span class="op">=</span>train_only_2019_cols, errors<span class="op">=</span><span class="st">'ignore'</span>)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 5: Optional logging</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Dropped </span><span class="sc">{</span><span class="bu">len</span>(train_only_2019_cols)<span class="sc">}</span><span class="ss"> columns from train (including protested_2019 if present):"</span>)</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(train_only_2019_cols)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="3d342133" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'protested_2019'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        df.drop(columns<span class="op">=</span><span class="st">'protested_2019'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Dropped 'protested_2019' from </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"'protested_2019' not found in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="8fccbdce" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">## Get all '2019' columns in train and test</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>train_2019_cols <span class="op">=</span> <span class="bu">sorted</span>([col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> <span class="st">'2019'</span> <span class="kw">in</span> col])</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>test_2019_cols <span class="op">=</span> <span class="bu">sorted</span>([col <span class="cf">for</span> col <span class="kw">in</span> test_merged.columns <span class="cf">if</span> <span class="st">'2019'</span> <span class="kw">in</span> col])</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Print train columns</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"2019 Columns in train_merged:"</span>)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> train_2019_cols:</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" - </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> 2019 Columns in test_merged:"</span>)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> test_2019_cols:</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" - </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="e7852aff" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compare sets</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>train_only_2019 <span class="op">=</span> <span class="bu">sorted</span>(<span class="bu">list</span>(<span class="bu">set</span>(train_2019_cols) <span class="op">-</span> <span class="bu">set</span>(test_2019_cols)))</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>test_only_2019 <span class="op">=</span> <span class="bu">sorted</span>(<span class="bu">list</span>(<span class="bu">set</span>(test_2019_cols) <span class="op">-</span> <span class="bu">set</span>(train_2019_cols)))</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Print comparison result</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> train_only_2019 <span class="kw">and</span> <span class="kw">not</span> test_only_2019:</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> All 2019 columns match between train_merged and test_merged."</span>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> Mismatched 2019 columns found:"</span>)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> train_only_2019:</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">" In train_merged but not in test_merged:"</span>)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> col <span class="kw">in</span> train_only_2019:</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"   - </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> test_only_2019:</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">" In test_merged but not in train_merged:"</span>)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> col <span class="kw">in</span> test_only_2019:</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"   - </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="0660cbe1" class="cell" data-execution_count="6">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1: Store target separately</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>y_train <span class="op">=</span> train_merged[<span class="st">"TARGET"</span>].values</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 4: Confirm sizes</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Train shape: </span><span class="sc">{</span>train<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Test shape: </span><span class="sc">{</span>test<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="30d7fbac" class="cell" data-execution_count="7">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate % of missing values in each column of TRAIN only</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>train_na <span class="op">=</span> (train_merged.isnull().<span class="bu">sum</span>() <span class="op">/</span> train_merged.shape[<span class="dv">0</span>]) <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop columns with no missing values, sort the rest</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>train_na <span class="op">=</span> train_na[train_na <span class="op">&gt;</span> <span class="dv">0</span>].sort_values(ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Optional: Show top 200 missing features</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>missing_data <span class="op">=</span> pd.DataFrame({<span class="st">'Missing Ratio (%)'</span>: train_na})</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Display</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Top columns with missing data (based on training set only):"</span>)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>missing_data.head(<span class="dv">20</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="1f1225ba" class="cell" data-execution_count="8">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_floor_area_totals(df, years):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> y <span class="kw">in</span> years:</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        primary_col <span class="op">=</span> <span class="ss">f'floor_area_primary_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">'</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        upper_col   <span class="op">=</span> <span class="ss">f'floor_area_upper_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">'</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        lower_col   <span class="op">=</span> <span class="ss">f'floor_area_lower_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">'</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        total_col   <span class="op">=</span> <span class="ss">f'floor_area_total_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">'</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">all</span>(col <span class="kw">in</span> df.columns <span class="cf">for</span> col <span class="kw">in</span> [primary_col, upper_col, lower_col]):</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>            df[total_col] <span class="op">=</span> (</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>                df[primary_col].fillna(<span class="dv">0</span>) <span class="op">+</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>                df[upper_col].fillna(<span class="dv">0</span>) <span class="op">+</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>                df[lower_col].fillna(<span class="dv">0</span>)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Created: </span><span class="sc">{</span>total_col<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipping </span><span class="sc">{</span>total_col<span class="sc">}</span><span class="ss"> ‚Äî one or more components missing."</span>)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply for years 2015‚Äì2019</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2015'</span>, <span class="st">'2016'</span>, <span class="st">'2017'</span>, <span class="st">'2018'</span>, <span class="st">'2019'</span>]</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> create_floor_area_totals(train_merged, years)</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> create_floor_area_totals(test_merged, years)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="2612c8aa" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>zero_pct <span class="op">=</span> (train_merged[<span class="st">'mobile_home_area_2015'</span>] <span class="op">==</span> <span class="dv">0</span>).mean() <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" mobile_home_area_2015 is 0 in </span><span class="sc">{</span>zero_pct<span class="sc">:.2f}</span><span class="ss">% of training rows"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="5b889904" class="cell" data-execution_count="10">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> col.startswith(<span class="st">"mobile_home_area"</span>)]</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop from both sets</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" Dropped columns from train/test: </span><span class="sc">{</span>cols_to_drop<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="86c37dbb" class="cell" data-execution_count="11">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>zero_pct <span class="op">=</span> (train_merged[<span class="st">'deck_area_2015'</span>] <span class="op">==</span> <span class="dv">0</span>).mean() <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" deck_area_2015 is 0 in </span><span class="sc">{</span>zero_pct<span class="sc">:.2f}</span><span class="ss">% of training rows"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="bef10a97" class="cell" data-execution_count="12">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Use training columns to identify which deck_area columns exist</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> col.startswith(<span class="st">"deck_area"</span>)]</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop those columns from both datasets</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" Dropped columns from train/test: </span><span class="sc">{</span>cols_to_drop<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="4a418853" class="cell" data-execution_count="13">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_yearly_features(df, base_features, years):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> feature <span class="kw">in</span> base_features:</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>        cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Backfill all relevant year columns in-place</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>            df[cols] <span class="op">=</span> df[cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Backfilled: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> across </span><span class="sc">{</span>cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipping </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> ‚Äî not enough year columns found."</span>)</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Years in reverse so that bfill works from most recent (2019) to oldest (2015)</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>features <span class="op">=</span> [<span class="st">'garage_area'</span>, <span class="st">'porch_area'</span>]</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to both train and test</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_yearly_features(train_merged, features, years)</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_yearly_features(test_merged, features, years)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="d60dbb83" class="cell" data-execution_count="14">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_yearly_features(df, features, years):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> feature <span class="kw">in</span> features:</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>        year_cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(year_cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>            df[year_cols] <span class="op">=</span> df[year_cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Backfilled: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> across </span><span class="sc">{</span>year_cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipped: Not enough year columns for '</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">'"</span>)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Use years in reverse for proper backfill (newest to oldest)</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>features <span class="op">=</span> [<span class="st">'floors'</span>, <span class="st">'half_bath'</span>, <span class="st">'full_bath'</span>, <span class="st">'total_rooms'</span>, <span class="st">'bedrooms'</span>]</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to both train and test</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_yearly_features(train_merged, features, years)</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_yearly_features(test_merged, features, years)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="f2a98486" class="cell" data-execution_count="15">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Identify elevator-related columns from training set</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>elevator_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> col.startswith(<span class="st">"elevator"</span>)]</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop from both train and test</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>elevator_cols, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>elevator_cols, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"üóëÔ∏è Dropped elevator-related columns from train/test: </span><span class="sc">{</span>elevator_cols<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="9ed1af53" class="cell" data-execution_count="16">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_year_features(df, features, years):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> feature <span class="kw">in</span> features:</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>        cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>            df[cols] <span class="op">=</span> df[cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Backfilled: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> across </span><span class="sc">{</span>cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipped </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> ‚Äî not enough year-based columns found."</span>)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_year_built_final(df):</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    year_cols <span class="op">=</span> [<span class="ss">f"year_built_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>] <span class="cf">if</span> <span class="ss">f"year_built_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> year_cols:</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'year_built_final'</span>] <span class="op">=</span> df[year_cols].bfill(axis<span class="op">=</span><span class="dv">1</span>).iloc[:, <span class="dv">0</span>]</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Created year_built_final from: </span><span class="sc">{</span>year_cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">" Skipped: no year_built_* columns found."</span>)</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Define reverse years for backfill (latest ‚Üí oldest)</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>features_to_backfill <span class="op">=</span> [<span class="st">'fireplaces'</span>, <span class="st">'quality'</span>, <span class="st">'quality_description'</span>]</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to both train and test</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_year_features(train_merged, features_to_backfill, years)</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> create_year_built_final(train_merged)</span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_year_features(test_merged, features_to_backfill, years)</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> create_year_built_final(test_merged)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="c1dbc057" class="cell" data-execution_count="17">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">## Identify columns to drop from training data</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> col.startswith(<span class="st">"year_remodeled"</span>)]</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop from both train and test</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"üóëÔ∏è Dropped year_remodeled-related columns from train/test: </span><span class="sc">{</span>cols_to_drop<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="922a3195" class="cell" data-execution_count="18">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_categorical_year_features(df, features, years):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> feature <span class="kw">in</span> features:</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>        year_cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(year_cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>            df[year_cols] <span class="op">=</span> df[year_cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Backfilled: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> across </span><span class="sc">{</span>year_cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipped: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> ‚Äî not enough year-based columns."</span>)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Backfill from most recent year to oldest</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>features <span class="op">=</span> [<span class="st">'building_condition'</span>, <span class="st">'foundation_type'</span>, <span class="st">'grade'</span>, <span class="st">'has_cooling'</span>, </span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>            <span class="st">'has_heat'</span>, <span class="st">'physical_condition'</span>, <span class="st">'exterior_walls'</span>]</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to train and test</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_categorical_year_features(train_merged, features, years)</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_categorical_year_features(test_merged, features, years)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="6fca3547" class="cell" data-execution_count="19">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_year_columns(df, features, years):</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> feature <span class="kw">in</span> features:</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>        cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>            df[cols] <span class="op">=</span> df[cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Backfilled: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> across </span><span class="sc">{</span>cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipped: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> ‚Äî not enough year-based columns found."</span>)</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Define year ranges</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>area_years <span class="op">=</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>value_years <span class="op">=</span> [<span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Define feature groups</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>area_features <span class="op">=</span> [<span class="st">'building_area'</span>, <span class="st">'land_area'</span>]</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>value_features <span class="op">=</span> [<span class="st">'building_value'</span>, <span class="st">'land_value'</span>, <span class="st">'assessed'</span>]</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to train and test</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_year_columns(train_merged, area_features, area_years)</span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_year_columns(train_merged, value_features, value_years)</span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_year_columns(test_merged, area_features, area_years)</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_year_columns(test_merged, value_features, value_years)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="dc5f9fad" class="cell" data-execution_count="20">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_protested_columns(df, years):</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    cols <span class="op">=</span> [<span class="ss">f"protested_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"protested_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>        df[cols] <span class="op">=</span> df[cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Backfilled: protested across </span><span class="sc">{</span>cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">" Skipped protested ‚Äî not enough year-based columns found."</span>)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Only use pre-2019 years to avoid leakage</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to both datasets</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_protested_columns(train_merged, years)</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_protested_columns(test_merged, years)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="6cca3787" class="cell" data-execution_count="21">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Save 'acct' from test_merged only</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>acct_test <span class="op">=</span> test_merged[[<span class="st">'acct'</span>]].copy() <span class="cf">if</span> <span class="st">'acct'</span> <span class="kw">in</span> test_merged.columns <span class="cf">else</span> <span class="va">None</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop 'acct' from both train and test</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'acct'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>        df.drop(columns<span class="op">=</span><span class="st">'acct'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"üóëÔ∏è Dropped 'acct' from </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="d9e015b2" class="cell" data-execution_count="22">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> [<span class="st">'zone'</span>, <span class="st">'subneighborhood'</span>, <span class="st">'neighborhood'</span>, <span class="st">'region'</span>]:</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>train_merged[col]<span class="sc">.</span>nunique()<span class="sc">}</span><span class="ss"> unique values in training set"</span>)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"‚ö†Ô∏è </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> not found in training set"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="d497ad70" class="cell" data-execution_count="23">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> [<span class="st">'neighborhood'</span>, <span class="st">'region'</span>,<span class="st">'zone'</span>,<span class="st">'subneighborhood'</span>]:</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 1: Compute frequency from training data</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>        freq_map <span class="op">=</span> train_merged[col].value_counts(normalize<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 2: Apply to both datasets</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>        train_merged[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_freq'</span>] <span class="op">=</span> train_merged[col].<span class="bu">map</span>(freq_map)</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>        test_merged[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_freq'</span>] <span class="op">=</span> test_merged[col].<span class="bu">map</span>(freq_map)</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Frequency encoded: </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> ‚Üí </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_freq (based on training set)"</span>)</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Column '</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">' not found in training set"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="1e8c412b" class="cell" data-execution_count="24">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">all</span>(col <span class="kw">in</span> train_merged.columns <span class="cf">for</span> col <span class="kw">in</span> [<span class="st">'land_area_2019'</span>, <span class="st">'land_area_2015'</span>]):</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    growth <span class="op">=</span> train_merged[<span class="st">'land_area_2019'</span>] <span class="op">-</span> train_merged[<span class="st">'land_area_2015'</span>]</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    changed_pct <span class="op">=</span> (growth <span class="op">!=</span> <span class="dv">0</span>).mean() <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Percentage of homes with land area change (2015‚Üí2019): </span><span class="sc">{</span>changed_pct<span class="sc">:.2f}</span><span class="ss">%"</span>)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">" One or both columns ('land_area_2015', 'land_area_2019') not found in training set"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="e6d3c6a4" class="cell" data-execution_count="25">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'year_built_final'</span>] <span class="op">=</span> df[<span class="st">'year_built_final'</span>].astype(<span class="bu">str</span>)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Converted 'year_built_final' to string in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" 'year_built_final' not found in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="310dc68e" class="cell" data-execution_count="26">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'floor_area_total_final'</span> <span class="kw">in</span> df.columns <span class="kw">and</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>        df.loc[df[<span class="st">'floor_area_total_final'</span>] <span class="op">==</span> <span class="dv">0</span>, <span class="st">'year_built_final'</span>] <span class="op">=</span> <span class="st">'None'</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Set 'year_built_final' to 'None' where 'floor_area_total_final' == 0 in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Required columns missing in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="87119e4c" class="cell" data-execution_count="27">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define year ranges per feature type</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>value_years <span class="op">=</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2019</span>)   <span class="co"># 2015‚Äì2018 for value columns</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>area_years  <span class="op">=</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)   <span class="co"># 2015‚Äì2019 for area columns</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Define base columns</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>base_cols_year_map <span class="op">=</span> {</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_value'</span>: value_years,</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">'land_value'</span>: value_years,</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_area'</span>: area_years,</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">'land_area'</span>: area_years,</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate full list of columns to impute</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>cols_to_impute <span class="op">=</span> []</span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> base, years <span class="kw">in</span> base_cols_year_map.items():</span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> year <span class="kw">in</span> years:</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>        cols_to_impute.append(<span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Impute using neighborhood ‚Üí region strategy</span></span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> cols_to_impute:</span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># First, fill by neighborhood (train only)</span></span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'neighborhood'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a>        medians_by_neigh <span class="op">=</span> train_merged.groupby(<span class="st">'neighborhood'</span>)[col].median()</span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a>        train_merged[col] <span class="op">=</span> train_merged.<span class="bu">apply</span>(</span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a>            <span class="kw">lambda</span> row: medians_by_neigh[row[<span class="st">'neighborhood'</span>]] <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb27-26"><a href="#cb27-26" aria-hidden="true" tabindex="-1"></a>        test_merged[col] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb27-27"><a href="#cb27-27" aria-hidden="true" tabindex="-1"></a>            <span class="kw">lambda</span> row: medians_by_neigh.get(row[<span class="st">'neighborhood'</span>], np.nan) <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb27-28"><a href="#cb27-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-29"><a href="#cb27-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Then, fill remaining by region (train only)</span></span>
<span id="cb27-30"><a href="#cb27-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'region'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb27-31"><a href="#cb27-31" aria-hidden="true" tabindex="-1"></a>        medians_by_region <span class="op">=</span> train_merged.groupby(<span class="st">'region'</span>)[col].median()</span>
<span id="cb27-32"><a href="#cb27-32" aria-hidden="true" tabindex="-1"></a>        train_merged[col] <span class="op">=</span> train_merged.<span class="bu">apply</span>(</span>
<span id="cb27-33"><a href="#cb27-33" aria-hidden="true" tabindex="-1"></a>            <span class="kw">lambda</span> row: medians_by_region[row[<span class="st">'region'</span>]] <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb27-34"><a href="#cb27-34" aria-hidden="true" tabindex="-1"></a>        test_merged[col] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb27-35"><a href="#cb27-35" aria-hidden="true" tabindex="-1"></a>            <span class="kw">lambda</span> row: medians_by_region.get(row[<span class="st">'region'</span>], np.nan) <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb27-36"><a href="#cb27-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-37"><a href="#cb27-37" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Imputed '</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">' using group medians (neighborhood ‚Üí region) from training data"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="eb483d14" class="cell" data-execution_count="28">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pandas.api.types <span class="im">import</span> is_numeric_dtype</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1: Coerce non-numeric to NaN in both sets</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'year_built_final'</span>] <span class="op">=</span> pd.to_numeric(df[<span class="st">'year_built_final'</span>], errors<span class="op">=</span><span class="st">'coerce'</span>)</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Coerced 'year_built_final' to numeric in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 2: Group-based imputation (use training data only)</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> train_merged.columns <span class="kw">and</span> <span class="st">'neighborhood'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Neighborhood-based median from train</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>    neigh_medians <span class="op">=</span> train_merged.groupby(<span class="st">'neighborhood'</span>)[<span class="st">'year_built_final'</span>].median()</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Apply to train</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>    train_merged[<span class="st">'year_built_final'</span>] <span class="op">=</span> train_merged.<span class="bu">apply</span>(</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: neigh_medians[row[<span class="st">'neighborhood'</span>]] <span class="cf">if</span> pd.isna(row[<span class="st">'year_built_final'</span>]) <span class="cf">else</span> row[<span class="st">'year_built_final'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Apply to test</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>    test_merged[<span class="st">'year_built_final'</span>] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: neigh_medians.get(row[<span class="st">'neighborhood'</span>], np.nan) <span class="cf">if</span> pd.isna(row[<span class="st">'year_built_final'</span>]) <span class="cf">else</span> row[<span class="st">'year_built_final'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'region'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Region-based fallback median from train</span></span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a>    region_medians <span class="op">=</span> train_merged.groupby(<span class="st">'region'</span>)[<span class="st">'year_built_final'</span>].median()</span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a>    train_merged[<span class="st">'year_built_final'</span>] <span class="op">=</span> train_merged.<span class="bu">apply</span>(</span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: region_medians[row[<span class="st">'region'</span>]] <span class="cf">if</span> pd.isna(row[<span class="st">'year_built_final'</span>]) <span class="cf">else</span> row[<span class="st">'year_built_final'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a>    test_merged[<span class="st">'year_built_final'</span>] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: region_medians.get(row[<span class="st">'region'</span>], np.nan) <span class="cf">if</span> pd.isna(row[<span class="st">'year_built_final'</span>]) <span class="cf">else</span> row[<span class="st">'year_built_final'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-32"><a href="#cb28-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Imputed 'year_built_final' using neighborhood ‚Üí region medians from training set"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="bb7d26b7" class="cell" data-execution_count="29">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># List of all assessed columns to impute</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>assessed_cols <span class="op">=</span> [<span class="st">'assessed_2015'</span>, <span class="st">'assessed_2016'</span>, <span class="st">'assessed_2017'</span>, <span class="st">'assessed_2018'</span>]</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> assessed_cols:</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">not</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: Compute medians from training data only</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    neigh_medians <span class="op">=</span> train_merged.groupby(<span class="st">'neighborhood'</span>)[col].median()</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    region_medians <span class="op">=</span> train_merged.groupby(<span class="st">'region'</span>)[col].median()</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>    global_median <span class="op">=</span> train_merged[col].median()</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 2: Train set imputation</span></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>    train_merged[col] <span class="op">=</span> train_merged.<span class="bu">apply</span>(</span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: neigh_medians[row[<span class="st">'neighborhood'</span>]]</span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pd.isna(row[col]) <span class="kw">and</span> row[<span class="st">'neighborhood'</span>] <span class="kw">in</span> neigh_medians <span class="cf">else</span></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>        region_medians[row[<span class="st">'region'</span>]]</span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pd.isna(row[col]) <span class="kw">and</span> row[<span class="st">'region'</span>] <span class="kw">in</span> region_medians <span class="cf">else</span></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a>        global_median</span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span></span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a>        row[col],</span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a>        axis<span class="op">=</span><span class="dv">1</span></span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 3: Test set imputation (using train medians only)</span></span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true" tabindex="-1"></a>    test_merged[col] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb29-27"><a href="#cb29-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: neigh_medians.get(row[<span class="st">'neighborhood'</span>], np.nan)</span>
<span id="cb29-28"><a href="#cb29-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col],</span>
<span id="cb29-29"><a href="#cb29-29" aria-hidden="true" tabindex="-1"></a>        axis<span class="op">=</span><span class="dv">1</span></span>
<span id="cb29-30"><a href="#cb29-30" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb29-31"><a href="#cb29-31" aria-hidden="true" tabindex="-1"></a>    test_merged[col] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb29-32"><a href="#cb29-32" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: region_medians.get(row[<span class="st">'region'</span>], np.nan)</span>
<span id="cb29-33"><a href="#cb29-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col],</span>
<span id="cb29-34"><a href="#cb29-34" aria-hidden="true" tabindex="-1"></a>        axis<span class="op">=</span><span class="dv">1</span></span>
<span id="cb29-35"><a href="#cb29-35" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb29-36"><a href="#cb29-36" aria-hidden="true" tabindex="-1"></a>    test_merged[col].fillna(global_median, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb29-37"><a href="#cb29-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-38"><a href="#cb29-38" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Imputed '</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">' using neighborhood ‚Üí region ‚Üí global medians (from training data)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="41e10cef" class="cell" data-execution_count="30">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 1: Compute neighborhood-level stats ===</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>neigh_stats <span class="op">=</span> train_merged.groupby(<span class="st">'neighborhood'</span>)[<span class="st">'assessed_2018'</span>].agg([</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'neigh_assess_mean'</span>, <span class="st">'mean'</span>),</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'neigh_assess_median'</span>, <span class="st">'median'</span>),</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'neigh_assess_std'</span>, <span class="st">'std'</span>),</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'neigh_assess_q1'</span>, <span class="kw">lambda</span> x: x.quantile(<span class="fl">0.25</span>)),</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'neigh_assess_q3'</span>, <span class="kw">lambda</span> x: x.quantile(<span class="fl">0.75</span>)),</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>]).reset_index()</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>neigh_stats[<span class="st">'neigh_assess_iqr'</span>] <span class="op">=</span> neigh_stats[<span class="st">'neigh_assess_q3'</span>] <span class="op">-</span> neigh_stats[<span class="st">'neigh_assess_q1'</span>]</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 2: Compute region-level stats ===</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>region_stats <span class="op">=</span> train_merged.groupby(<span class="st">'region'</span>)[<span class="st">'assessed_2018'</span>].agg([</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'region_assess_mean'</span>, <span class="st">'mean'</span>),</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'region_assess_median'</span>, <span class="st">'median'</span>),</span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'region_assess_std'</span>, <span class="st">'std'</span>),</span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'region_assess_q1'</span>, <span class="kw">lambda</span> x: x.quantile(<span class="fl">0.25</span>)),</span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'region_assess_q3'</span>, <span class="kw">lambda</span> x: x.quantile(<span class="fl">0.75</span>)),</span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>]).reset_index()</span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a>region_stats[<span class="st">'region_assess_iqr'</span>] <span class="op">=</span> region_stats[<span class="st">'region_assess_q3'</span>] <span class="op">-</span> region_stats[<span class="st">'region_assess_q1'</span>]</span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 3: Fallback std maps from training data ===</span></span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a><span class="co"># For neighborhood fallback, group region medians of neighborhood std</span></span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a>neigh_std_by_region <span class="op">=</span> neigh_stats.merge(train_merged[[<span class="st">'neighborhood'</span>, <span class="st">'region'</span>]], on<span class="op">=</span><span class="st">'neighborhood'</span>, how<span class="op">=</span><span class="st">'left'</span>) <span class="op">\</span></span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a>                                  .groupby(<span class="st">'region'</span>)[<span class="st">'neigh_assess_std'</span>].median()</span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a>global_neigh_std <span class="op">=</span> neigh_stats[<span class="st">'neigh_assess_std'</span>].median()</span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a>region_std_by_neigh <span class="op">=</span> region_stats.merge(train_merged[[<span class="st">'neighborhood'</span>, <span class="st">'region'</span>]], on<span class="op">=</span><span class="st">'region'</span>, how<span class="op">=</span><span class="st">'left'</span>) <span class="op">\</span></span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a>                                   .groupby(<span class="st">'neighborhood'</span>)[<span class="st">'region_assess_std'</span>].median()</span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a>global_region_std <span class="op">=</span> region_stats[<span class="st">'region_assess_std'</span>].median()</span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 4: Merge into train/test and compute features ===</span></span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.merge(neigh_stats, on<span class="op">=</span><span class="st">'neighborhood'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.merge(region_stats, on<span class="op">=</span><span class="st">'region'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-36"><a href="#cb30-36" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill missing std values via fallback</span></span>
<span id="cb30-37"><a href="#cb30-37" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'neigh_assess_std'</span>] <span class="op">=</span> df[<span class="st">'neigh_assess_std'</span>].fillna(</span>
<span id="cb30-38"><a href="#cb30-38" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'region'</span>].<span class="bu">map</span>(neigh_std_by_region)</span>
<span id="cb30-39"><a href="#cb30-39" aria-hidden="true" tabindex="-1"></a>    ).fillna(global_neigh_std)</span>
<span id="cb30-40"><a href="#cb30-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-41"><a href="#cb30-41" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'region_assess_std'</span>] <span class="op">=</span> df[<span class="st">'region_assess_std'</span>].fillna(</span>
<span id="cb30-42"><a href="#cb30-42" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'neighborhood'</span>].<span class="bu">map</span>(region_std_by_neigh)</span>
<span id="cb30-43"><a href="#cb30-43" aria-hidden="true" tabindex="-1"></a>    ).fillna(global_region_std)</span>
<span id="cb30-44"><a href="#cb30-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-45"><a href="#cb30-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute derived features</span></span>
<span id="cb30-46"><a href="#cb30-46" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'assess_minus_neigh_mean'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">-</span> df[<span class="st">'neigh_assess_mean'</span>]</span>
<span id="cb30-47"><a href="#cb30-47" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'assess_ratio_neigh_mean'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">/</span> (df[<span class="st">'neigh_assess_mean'</span>] <span class="op">+</span> <span class="fl">1e-6</span>)</span>
<span id="cb30-48"><a href="#cb30-48" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'z_score_assess_neigh'</span>] <span class="op">=</span> df[<span class="st">'assess_minus_neigh_mean'</span>] <span class="op">/</span> (df[<span class="st">'neigh_assess_std'</span>] <span class="op">+</span> <span class="fl">1e-6</span>)</span>
<span id="cb30-49"><a href="#cb30-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-50"><a href="#cb30-50" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'assess_minus_region_mean'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">-</span> df[<span class="st">'region_assess_mean'</span>]</span>
<span id="cb30-51"><a href="#cb30-51" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'assess_ratio_region_mean'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">/</span> (df[<span class="st">'region_assess_mean'</span>] <span class="op">+</span> <span class="fl">1e-6</span>)</span>
<span id="cb30-52"><a href="#cb30-52" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'z_score_assess_region'</span>] <span class="op">=</span> df[<span class="st">'assess_minus_region_mean'</span>] <span class="op">/</span> (df[<span class="st">'region_assess_std'</span>] <span class="op">+</span> <span class="fl">1e-6</span>)</span>
<span id="cb30-53"><a href="#cb30-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-54"><a href="#cb30-54" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Save back</span></span>
<span id="cb30-55"><a href="#cb30-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> df_name <span class="op">==</span> <span class="st">'train_merged'</span>:</span>
<span id="cb30-56"><a href="#cb30-56" aria-hidden="true" tabindex="-1"></a>        train_merged <span class="op">=</span> df</span>
<span id="cb30-57"><a href="#cb30-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb30-58"><a href="#cb30-58" aria-hidden="true" tabindex="-1"></a>        test_merged <span class="op">=</span> df</span>
<span id="cb30-59"><a href="#cb30-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-60"><a href="#cb30-60" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Completed: Stats merge + std fallback + z-score computation."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="266bbf3a" class="cell" data-execution_count="31">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> [<span class="st">'neighborhood'</span>, <span class="st">'region'</span>,<span class="st">'zone'</span>,<span class="st">'subneighborhood'</span>]</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    drop_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> cols_to_drop <span class="cf">if</span> col <span class="kw">in</span> df.columns]</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> drop_cols:</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>        df.drop(columns<span class="op">=</span>drop_cols, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"üóëÔ∏è Dropped columns from </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>drop_cols<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="c1f83e40" class="cell" data-execution_count="32">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>growth_pairs <span class="op">=</span> {</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_value_growth'</span>: (<span class="st">'building_value_2018'</span>, <span class="st">'building_value_2015'</span>),</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">'land_value_growth'</span>:     (<span class="st">'land_value_2018'</span>, <span class="st">'land_value_2015'</span>),</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">'assessed_growth'</span>:       (<span class="st">'assessed_2018'</span>, <span class="st">'assessed_2015'</span>)</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> new_col, (final_col, base_col) <span class="kw">in</span> growth_pairs.items():</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> final_col <span class="kw">in</span> df.columns <span class="kw">and</span> base_col <span class="kw">in</span> df.columns:</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>            df[new_col] <span class="op">=</span> df[final_col] <span class="op">-</span> df[base_col]</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Created </span><span class="sc">{</span>new_col<span class="sc">}</span><span class="ss"> in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipped </span><span class="sc">{</span>new_col<span class="sc">}</span><span class="ss"> in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">: missing </span><span class="sc">{</span>final_col<span class="sc">}</span><span class="ss"> or </span><span class="sc">{</span>base_col<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Building Age ===</span></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'year_built_final'</span>] <span class="op">=</span> pd.to_numeric(df[<span class="st">'year_built_final'</span>], errors<span class="op">=</span><span class="st">'coerce'</span>)  <span class="co"># handle 'Vacant', etc.</span></span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'building_age'</span>] <span class="op">=</span> <span class="dv">2018</span> <span class="op">-</span> df[<span class="st">'year_built_final'</span>]</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Created building_age in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Skipped building_age in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">: missing year_built_final"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="e1c08db3" class="cell" data-execution_count="33">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'school_dist'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    missing_pct <span class="op">=</span> train_merged[<span class="st">'school_dist'</span>].isna().mean() <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    missing_count <span class="op">=</span> train_merged[<span class="st">'school_dist'</span>].isna().<span class="bu">sum</span>()</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" 'school_dist' has </span><span class="sc">{</span>missing_count<span class="sc">}</span><span class="ss"> missing values (</span><span class="sc">{</span>missing_pct<span class="sc">:.2f}</span><span class="ss">%) in training set"</span>)</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">" 'school_dist' not found in training set"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="b953676c" class="cell" data-execution_count="34">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'school_dist'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    school_dist_median <span class="op">=</span> train_merged[<span class="st">'school_dist'</span>].median()</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="st">'school_dist'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>            df[<span class="st">'school_dist'</span>] <span class="op">=</span> df[<span class="st">'school_dist'</span>].fillna(school_dist_median)</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Filled missing 'school_dist' in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss"> using train median (</span><span class="sc">{</span>school_dist_median<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">" 'school_dist' not found in train_merged"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="83c3e477" class="cell" data-execution_count="35">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    missing_pct <span class="op">=</span> train_merged[<span class="st">'year_built_final'</span>].isna().mean() <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    missing_count <span class="op">=</span> train_merged[<span class="st">'year_built_final'</span>].isna().<span class="bu">sum</span>()</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" 'year_built_final' has </span><span class="sc">{</span>missing_count<span class="sc">}</span><span class="ss"> missing values (</span><span class="sc">{</span>missing_pct<span class="sc">:.2f}</span><span class="ss">%) in training set"</span>)</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">" 'year_built_final' not found in training set"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="a3eb9baf" class="cell" data-execution_count="36">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 0: Define base feature names ===</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>numeric_bases <span class="op">=</span> [</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">'garage_area'</span>, <span class="st">'porch_area'</span>, <span class="st">'floors'</span>, <span class="st">'half_bath'</span>, <span class="st">'full_bath'</span>,</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">'total_rooms'</span>, <span class="st">'bedrooms'</span>, <span class="st">'fireplaces'</span>, <span class="st">'building_area'</span>, <span class="st">'building_value'</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>categorical_fill_map <span class="op">=</span> {</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality'</span>: <span class="st">'None'</span>,</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality_description'</span>: <span class="st">'None'</span>,</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_condition'</span>: <span class="st">'None'</span>,</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>    <span class="st">'foundation_type'</span>: <span class="st">'None'</span>,</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>    <span class="st">'grade'</span>: <span class="st">'None'</span>,</span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">'has_cooling'</span>: <span class="va">False</span>,</span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">'has_heat'</span>: <span class="va">False</span>,</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>    <span class="st">'physical_condition'</span>: <span class="st">'None'</span>,</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">'exterior_walls'</span>: <span class="st">'None'</span>,</span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>    <span class="st">'protested'</span>: <span class="va">False</span></span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate full list of columns (2015‚Äì2019 only, no final columns)</span></span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a>numeric_cols_to_zero <span class="op">=</span> [</span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a>    <span class="ss">f'</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> base <span class="kw">in</span> numeric_bases <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)</span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a>] <span class="op">+</span> [<span class="st">'building_value_growth'</span>]</span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a>categorical_cols_to_fill <span class="op">=</span> {</span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a>    <span class="ss">f'</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">'</span>: val</span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> base, val <span class="kw">in</span> categorical_fill_map.items()</span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)</span>
<span id="cb36-29"><a href="#cb36-29" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb36-30"><a href="#cb36-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-31"><a href="#cb36-31" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 1: Apply imputation if floor_area_total_2019 == 0 ===</span></span>
<span id="cb36-32"><a href="#cb36-32" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb36-33"><a href="#cb36-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'floor_area_total_2019'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb36-34"><a href="#cb36-34" aria-hidden="true" tabindex="-1"></a>        zero_floor_mask <span class="op">=</span> df[<span class="st">'floor_area_total_2019'</span>] <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb36-35"><a href="#cb36-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-36"><a href="#cb36-36" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Fill numeric columns with 0</span></span>
<span id="cb36-37"><a href="#cb36-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> col <span class="kw">in</span> numeric_cols_to_zero:</span>
<span id="cb36-38"><a href="#cb36-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb36-39"><a href="#cb36-39" aria-hidden="true" tabindex="-1"></a>                df.loc[zero_floor_mask, col] <span class="op">=</span> df.loc[zero_floor_mask, col].fillna(<span class="dv">0</span>)</span>
<span id="cb36-40"><a href="#cb36-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-41"><a href="#cb36-41" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Fill categorical/boolean columns</span></span>
<span id="cb36-42"><a href="#cb36-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> col, fill_val <span class="kw">in</span> categorical_cols_to_fill.items():</span>
<span id="cb36-43"><a href="#cb36-43" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb36-44"><a href="#cb36-44" aria-hidden="true" tabindex="-1"></a>                df.loc[zero_floor_mask, col] <span class="op">=</span> df.loc[zero_floor_mask, col].fillna(fill_val)</span>
<span id="cb36-45"><a href="#cb36-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-46"><a href="#cb36-46" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Filled structure-dependent missing values in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss"> for </span><span class="sc">{</span>zero_floor_mask<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ss"> rows"</span>)</span>
<span id="cb36-47"><a href="#cb36-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb36-48"><a href="#cb36-48" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" 'floor_area_total_2019' not found in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="1c96e4a5" class="cell" data-execution_count="37">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> OrdinalEncoder</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> KFold</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Clear specific variables</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> var <span class="kw">in</span> [<span class="st">'ordinal_cols_all'</span>, <span class="st">'bool_cols_all'</span>]:</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> var <span class="kw">in</span> <span class="bu">locals</span>():</span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">del</span> <span class="bu">globals</span>()[var]</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 1: Boolean Encoding (2015‚Äì2019 only) ===</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>bool_bases <span class="op">=</span> [<span class="st">'has_cooling'</span>, <span class="st">'has_heat'</span>, <span class="st">'protested'</span>]</span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>bool_cols_all <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> base <span class="kw">in</span> bool_bases <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)]</span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> bool_cols_all:</span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>        mode_val <span class="op">=</span> train_merged[col].mode(dropna<span class="op">=</span><span class="va">True</span>)[<span class="dv">0</span>]</span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>        train_merged[col] <span class="op">=</span> train_merged[col].fillna(mode_val).astype(<span class="bu">int</span>)</span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>        test_merged[col] <span class="op">=</span> test_merged[col].fillna(mode_val).astype(<span class="bu">int</span>)</span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 2: Ordinal Cleaning and Encoding (2015‚Äì2019 only) ===</span></span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a>ordinal_bases <span class="op">=</span> [</span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality'</span>, <span class="st">'quality_description'</span>, <span class="st">'grade'</span>,</span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_condition'</span>, <span class="st">'physical_condition'</span></span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb37-26"><a href="#cb37-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-27"><a href="#cb37-27" aria-hidden="true" tabindex="-1"></a>ordinal_cols_all <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> base <span class="kw">in</span> ordinal_bases <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)]</span>
<span id="cb37-28"><a href="#cb37-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-29"><a href="#cb37-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Column-specific replacements</span></span>
<span id="cb37-30"><a href="#cb37-30" aria-hidden="true" tabindex="-1"></a>replacement_maps <span class="op">=</span> {</span>
<span id="cb37-31"><a href="#cb37-31" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality'</span>: {<span class="st">'E'</span>: <span class="st">'D'</span>, <span class="st">'F'</span>: <span class="st">'D'</span>, <span class="st">'X'</span>: np.nan, <span class="st">'None'</span>: np.nan},</span>
<span id="cb37-32"><a href="#cb37-32" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality_description'</span>: {<span class="st">'Poor'</span>: <span class="st">'Very Low'</span>, <span class="st">'None'</span>: np.nan},</span>
<span id="cb37-33"><a href="#cb37-33" aria-hidden="true" tabindex="-1"></a>    <span class="st">'grade'</span>: {<span class="st">'X'</span>: <span class="st">'F'</span>, <span class="st">'X-'</span>: <span class="st">'F'</span>, <span class="st">'X+'</span>: <span class="st">'F'</span>, <span class="st">'E'</span>: <span class="st">'D'</span>, <span class="st">'E-'</span>: <span class="st">'D-'</span>, <span class="st">'E+'</span>: <span class="st">'D+'</span>, <span class="st">'None'</span>: np.nan},</span>
<span id="cb37-34"><a href="#cb37-34" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_condition'</span>: {<span class="st">'Very Poor'</span>: <span class="st">'Poor'</span>, <span class="st">'Unsound'</span>: <span class="st">'Poor'</span>, <span class="st">'None'</span>: np.nan},</span>
<span id="cb37-35"><a href="#cb37-35" aria-hidden="true" tabindex="-1"></a>    <span class="st">'physical_condition'</span>: {<span class="st">'Very Poor'</span>: <span class="st">'Poor'</span>, <span class="st">'Unsound'</span>: <span class="st">'Poor'</span>, <span class="st">'None'</span>: np.nan}</span>
<span id="cb37-36"><a href="#cb37-36" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb37-37"><a href="#cb37-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-38"><a href="#cb37-38" aria-hidden="true" tabindex="-1"></a><span class="co"># Ordinal category order</span></span>
<span id="cb37-39"><a href="#cb37-39" aria-hidden="true" tabindex="-1"></a>ord_categories <span class="op">=</span> {</span>
<span id="cb37-40"><a href="#cb37-40" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality'</span>: [<span class="st">'D'</span>, <span class="st">'C'</span>, <span class="st">'B'</span>, <span class="st">'A'</span>],</span>
<span id="cb37-41"><a href="#cb37-41" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality_description'</span>: [<span class="st">'Very Low'</span>, <span class="st">'Low'</span>, <span class="st">'Average'</span>, <span class="st">'Good'</span>, <span class="st">'Excellent'</span>, <span class="st">'Superior'</span>],</span>
<span id="cb37-42"><a href="#cb37-42" aria-hidden="true" tabindex="-1"></a>    <span class="st">'grade'</span>: [<span class="st">'F'</span>, <span class="st">'D-'</span>, <span class="st">'D'</span>, <span class="st">'D+'</span>, <span class="st">'C-'</span>, <span class="st">'C'</span>, <span class="st">'C+'</span>, <span class="st">'B-'</span>, <span class="st">'B'</span>, <span class="st">'B+'</span>, <span class="st">'A-'</span>, <span class="st">'A'</span>, <span class="st">'A+'</span>],</span>
<span id="cb37-43"><a href="#cb37-43" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_condition'</span>: [<span class="st">'Poor'</span>, <span class="st">'Fair'</span>, <span class="st">'Average'</span>, <span class="st">'Good'</span>, <span class="st">'Very Good'</span>, <span class="st">'Excellent'</span>],</span>
<span id="cb37-44"><a href="#cb37-44" aria-hidden="true" tabindex="-1"></a>    <span class="st">'physical_condition'</span>: [<span class="st">'Poor'</span>, <span class="st">'Fair'</span>, <span class="st">'Average'</span>, <span class="st">'Good'</span>, <span class="st">'Very Good'</span>, <span class="st">'Excellent'</span>]</span>
<span id="cb37-45"><a href="#cb37-45" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb37-46"><a href="#cb37-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-47"><a href="#cb37-47" aria-hidden="true" tabindex="-1"></a><span class="co"># Clean and encode</span></span>
<span id="cb37-48"><a href="#cb37-48" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> base <span class="kw">in</span> ordinal_bases:</span>
<span id="cb37-49"><a href="#cb37-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>):</span>
<span id="cb37-50"><a href="#cb37-50" aria-hidden="true" tabindex="-1"></a>        col <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb37-51"><a href="#cb37-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb37-52"><a href="#cb37-52" aria-hidden="true" tabindex="-1"></a>            replacements <span class="op">=</span> replacement_maps.get(base, {})</span>
<span id="cb37-53"><a href="#cb37-53" aria-hidden="true" tabindex="-1"></a>            train_merged[col] <span class="op">=</span> train_merged[col].replace(replacements)</span>
<span id="cb37-54"><a href="#cb37-54" aria-hidden="true" tabindex="-1"></a>            test_merged[col] <span class="op">=</span> test_merged[col].replace(replacements)</span>
<span id="cb37-55"><a href="#cb37-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-56"><a href="#cb37-56" aria-hidden="true" tabindex="-1"></a>            mode_val <span class="op">=</span> train_merged[col].mode(dropna<span class="op">=</span><span class="va">True</span>)[<span class="dv">0</span>]</span>
<span id="cb37-57"><a href="#cb37-57" aria-hidden="true" tabindex="-1"></a>            train_merged[col] <span class="op">=</span> train_merged[col].fillna(mode_val)</span>
<span id="cb37-58"><a href="#cb37-58" aria-hidden="true" tabindex="-1"></a>            test_merged[col] <span class="op">=</span> test_merged[col].fillna(mode_val)</span>
<span id="cb37-59"><a href="#cb37-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-60"><a href="#cb37-60" aria-hidden="true" tabindex="-1"></a>            encoder <span class="op">=</span> OrdinalEncoder(categories<span class="op">=</span>[ord_categories[base]], handle_unknown<span class="op">=</span><span class="st">'use_encoded_value'</span>, unknown_value<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb37-61"><a href="#cb37-61" aria-hidden="true" tabindex="-1"></a>            train_merged[[col]] <span class="op">=</span> encoder.fit_transform(train_merged[[col]])</span>
<span id="cb37-62"><a href="#cb37-62" aria-hidden="true" tabindex="-1"></a>            test_merged[[col]] <span class="op">=</span> encoder.transform(test_merged[[col]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="091d2c0e" class="cell" data-execution_count="38">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 3: Target Encoding (2015‚Äì2019 only) ===</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> group_and_target_encode_cv(train_df, test_df, target_name, column, rare_threshold<span class="op">=</span><span class="fl">0.001</span>, smoothing<span class="op">=</span><span class="dv">10</span>, n_splits<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    freq <span class="op">=</span> train_df[column].value_counts(normalize<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    rare_cats <span class="op">=</span> freq[freq <span class="op">&lt;</span> rare_threshold].index</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>    train_df[column] <span class="op">=</span> train_df[column].replace(rare_cats, <span class="st">'Other'</span>)</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    test_df[column] <span class="op">=</span> test_df[column].replace(rare_cats, <span class="st">'Other'</span>)</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>    global_mean <span class="op">=</span> train_df[target_name].mean()</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>    oof_encoded <span class="op">=</span> pd.Series(index<span class="op">=</span>train_df.index, dtype<span class="op">=</span><span class="st">'float64'</span>)</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>    kf <span class="op">=</span> KFold(n_splits<span class="op">=</span>n_splits, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> train_idx, val_idx <span class="kw">in</span> kf.split(train_df):</span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>        X_tr, X_val <span class="op">=</span> train_df.iloc[train_idx], train_df.iloc[val_idx]</span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>        stats <span class="op">=</span> X_tr.groupby(column)[target_name].agg([<span class="st">'mean'</span>, <span class="st">'count'</span>])</span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>        smooth <span class="op">=</span> (stats[<span class="st">'mean'</span>] <span class="op">*</span> stats[<span class="st">'count'</span>] <span class="op">+</span> global_mean <span class="op">*</span> smoothing) <span class="op">/</span> (stats[<span class="st">'count'</span>] <span class="op">+</span> smoothing)</span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>        oof_encoded.iloc[val_idx] <span class="op">=</span> X_val[column].<span class="bu">map</span>(smooth).fillna(global_mean)</span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>    final_stats <span class="op">=</span> train_df.groupby(column)[target_name].agg([<span class="st">'mean'</span>, <span class="st">'count'</span>])</span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>    final_smooth <span class="op">=</span> (final_stats[<span class="st">'mean'</span>] <span class="op">*</span> final_stats[<span class="st">'count'</span>] <span class="op">+</span> global_mean <span class="op">*</span> smoothing) <span class="op">/</span> (final_stats[<span class="st">'count'</span>] <span class="op">+</span> smoothing)</span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>    test_encoded <span class="op">=</span> test_df[column].<span class="bu">map</span>(final_smooth).fillna(global_mean)</span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> oof_encoded, test_encoded</span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Target-encodable nominal columns</span></span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a>target_encodable_bases <span class="op">=</span> [<span class="st">'foundation_type'</span>, <span class="st">'exterior_walls'</span>]</span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a>target_encodable_cols_all <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> base <span class="kw">in</span> target_encodable_bases <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)]</span>
<span id="cb38-27"><a href="#cb38-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-28"><a href="#cb38-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply target encoding</span></span>
<span id="cb38-29"><a href="#cb38-29" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> target_encodable_cols_all:</span>
<span id="cb38-30"><a href="#cb38-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb38-31"><a href="#cb38-31" aria-hidden="true" tabindex="-1"></a>        mode_val <span class="op">=</span> train_merged[col].mode(dropna<span class="op">=</span><span class="va">True</span>)[<span class="dv">0</span>]</span>
<span id="cb38-32"><a href="#cb38-32" aria-hidden="true" tabindex="-1"></a>        train_merged[col] <span class="op">=</span> train_merged[col].fillna(mode_val)</span>
<span id="cb38-33"><a href="#cb38-33" aria-hidden="true" tabindex="-1"></a>        test_merged[col] <span class="op">=</span> test_merged[col].fillna(mode_val)</span>
<span id="cb38-34"><a href="#cb38-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-35"><a href="#cb38-35" aria-hidden="true" tabindex="-1"></a>        train_merged[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_te'</span>], test_merged[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_te'</span>] <span class="op">=</span> group_and_target_encode_cv(</span>
<span id="cb38-36"><a href="#cb38-36" aria-hidden="true" tabindex="-1"></a>            train_merged, test_merged, target_name<span class="op">=</span><span class="st">'assessed_2018'</span>, column<span class="op">=</span>col,</span>
<span id="cb38-37"><a href="#cb38-37" aria-hidden="true" tabindex="-1"></a>            rare_threshold<span class="op">=</span><span class="fl">0.001</span>, smoothing<span class="op">=</span><span class="dv">10</span>, n_splits<span class="op">=</span><span class="dv">5</span></span>
<span id="cb38-38"><a href="#cb38-38" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb38-39"><a href="#cb38-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-40"><a href="#cb38-40" aria-hidden="true" tabindex="-1"></a>        train_merged.drop(columns<span class="op">=</span>[col], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb38-41"><a href="#cb38-41" aria-hidden="true" tabindex="-1"></a>        test_merged.drop(columns<span class="op">=</span>[col], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb38-42"><a href="#cb38-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-43"><a href="#cb38-43" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Done: Boolean, Ordinal, and Target Encoding for 2015‚Äì2019 features only."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="490123c1" class="cell" data-execution_count="39">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1: Get growth columns from training set</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>growth_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> <span class="st">'_growth'</span> <span class="kw">in</span> col]</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 2: Compute medians from train_merged only</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>growth_medians <span class="op">=</span> {col: train_merged[col].median() <span class="cf">for</span> col <span class="kw">in</span> growth_cols}</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 3: Apply to both train and test</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> col <span class="kw">in</span> growth_cols:</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>            df[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_missing'</span>] <span class="op">=</span> df[col].isna().astype(<span class="bu">int</span>)</span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>            df[col].fillna(growth_medians[col], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Filled and flagged missing values in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss"> for: </span><span class="sc">{</span>growth_cols<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="875426da" class="cell" data-execution_count="40">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 1: List your growth features ===</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>growth_features <span class="op">=</span> [<span class="st">'land_value_growth'</span>, <span class="st">'building_value_growth'</span>, <span class="st">'assessed_growth'</span>]</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 2: Binning Function (train-based binning) ===</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bin_growth_feature_safe(train_df, test_df, feature, bins<span class="op">=</span><span class="dv">4</span>):</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Quantile binning on train only</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>        train_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>], bin_edges <span class="op">=</span> pd.qcut(train_df[feature], q<span class="op">=</span>bins, labels<span class="op">=</span><span class="va">False</span>, retbins<span class="op">=</span><span class="va">True</span>, duplicates<span class="op">=</span><span class="st">'drop'</span>)</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>        test_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>] <span class="op">=</span> pd.cut(test_df[feature], bins<span class="op">=</span>bin_edges, labels<span class="op">=</span><span class="va">False</span>, include_lowest<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">ValueError</span>:</span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Fallback: Equal-width binning</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>        min_val <span class="op">=</span> train_df[feature].<span class="bu">min</span>()</span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>        max_val <span class="op">=</span> train_df[feature].<span class="bu">max</span>()</span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>        bin_edges <span class="op">=</span> np.linspace(min_val, max_val, bins <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>        train_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>] <span class="op">=</span> pd.cut(train_df[feature], bins<span class="op">=</span>bin_edges, labels<span class="op">=</span><span class="va">False</span>, include_lowest<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>        test_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>] <span class="op">=</span> pd.cut(test_df[feature], bins<span class="op">=</span>bin_edges, labels<span class="op">=</span><span class="va">False</span>, include_lowest<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert to category</span></span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a>    train_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>] <span class="op">=</span> train_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>].astype(<span class="st">'category'</span>)</span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a>    test_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>] <span class="op">=</span> test_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>].astype(<span class="st">'category'</span>)</span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> train_df, test_df</span>
<span id="cb40-22"><a href="#cb40-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-23"><a href="#cb40-23" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 3: Apply to train_merged and test_merged ===</span></span>
<span id="cb40-24"><a href="#cb40-24" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> feature <span class="kw">in</span> growth_features:</span>
<span id="cb40-25"><a href="#cb40-25" aria-hidden="true" tabindex="-1"></a>    train_merged, test_merged <span class="op">=</span> bin_growth_feature_safe(train_merged, test_merged, feature)</span>
<span id="cb40-26"><a href="#cb40-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-27"><a href="#cb40-27" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 4: Bin year_built_final using train-based quantiles ===</span></span>
<span id="cb40-28"><a href="#cb40-28" aria-hidden="true" tabindex="-1"></a>train_merged[<span class="st">'year_built_bin'</span>], bin_edges <span class="op">=</span> pd.qcut(</span>
<span id="cb40-29"><a href="#cb40-29" aria-hidden="true" tabindex="-1"></a>    train_merged[<span class="st">'year_built_final'</span>], q<span class="op">=</span><span class="dv">5</span>, retbins<span class="op">=</span><span class="va">True</span>, labels<span class="op">=</span><span class="va">False</span>, duplicates<span class="op">=</span><span class="st">'drop'</span></span>
<span id="cb40-30"><a href="#cb40-30" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb40-31"><a href="#cb40-31" aria-hidden="true" tabindex="-1"></a>test_merged[<span class="st">'year_built_bin'</span>] <span class="op">=</span> pd.cut(</span>
<span id="cb40-32"><a href="#cb40-32" aria-hidden="true" tabindex="-1"></a>    test_merged[<span class="st">'year_built_final'</span>], bins<span class="op">=</span>bin_edges, labels<span class="op">=</span><span class="va">False</span>, include_lowest<span class="op">=</span><span class="va">True</span></span>
<span id="cb40-33"><a href="#cb40-33" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb40-34"><a href="#cb40-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-35"><a href="#cb40-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert to category</span></span>
<span id="cb40-36"><a href="#cb40-36" aria-hidden="true" tabindex="-1"></a>train_merged[<span class="st">'year_built_bin'</span>] <span class="op">=</span> train_merged[<span class="st">'year_built_bin'</span>].astype(<span class="st">'category'</span>)</span>
<span id="cb40-37"><a href="#cb40-37" aria-hidden="true" tabindex="-1"></a>test_merged[<span class="st">'year_built_bin'</span>] <span class="op">=</span> test_merged[<span class="st">'year_built_bin'</span>].astype(<span class="st">'category'</span>)</span>
<span id="cb40-38"><a href="#cb40-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-39"><a href="#cb40-39" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 5: Drop original continuous columns ===</span></span>
<span id="cb40-40"><a href="#cb40-40" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> growth_features <span class="op">+</span> [<span class="st">'year_built_final'</span>]</span>
<span id="cb40-41"><a href="#cb40-41" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb40-42"><a href="#cb40-42" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb40-43"><a href="#cb40-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-44"><a href="#cb40-44" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Binned growth &amp; year_built features safely with no leakage."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="b4d6eae0" class="cell" data-execution_count="41">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>rare_threshold <span class="op">=</span> <span class="fl">0.001</span>  <span class="co"># 0.1%</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>cat_cols <span class="op">=</span> [</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"quality_description_final"</span>,</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">"foundation_type_final_te"</span>,</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">"physical_condition_final"</span>,</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">"exterior_walls_final_te"</span>,</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">"region_freq"</span>,</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">"neighborhood_freq"</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> cat_cols:</span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>        freq <span class="op">=</span> train_merged[col].value_counts(normalize<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>        rare <span class="op">=</span> freq[freq <span class="op">&lt;</span> rare_threshold]</span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> rare.empty:</span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss"> Rare categories in '</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">' (less than 0.1% of training data):</span><span class="ch">\n</span><span class="sc">{</span>rare<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Column '</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">' not found in train_merged"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="94e3207d" class="cell" data-execution_count="42">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define frequency columns and threshold</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>freq_cols <span class="op">=</span> [<span class="st">'region_freq'</span>, <span class="st">'neighborhood_freq'</span>, <span class="st">'zone_freq'</span>, <span class="st">'subneighborhood_freq'</span>]</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>rare_thresh <span class="op">=</span> <span class="fl">0.001</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply rare value replacement for each frequency column</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> freq_cols:</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>        rare_vals <span class="op">=</span> train_merged[col].value_counts(normalize<span class="op">=</span><span class="va">True</span>)[<span class="kw">lambda</span> x: x <span class="op">&lt;</span> rare_thresh].index</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>        train_merged[col] <span class="op">=</span> train_merged[col].replace(rare_vals, <span class="dv">0</span>)</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>        test_merged[col] <span class="op">=</span> test_merged[col].replace(rare_vals, <span class="dv">0</span>)</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Replaced rare values in </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> using train_merged threshold &lt; </span><span class="sc">{</span>rare_thresh<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Column </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> not found in train_merged ‚Äî skipping."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="cbae0392" class="cell" data-execution_count="43">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 1: Skew-based Log Transformation (2015‚Äì2019 only) ===</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>log_bases <span class="op">=</span> [</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">'floor_area_total'</span>, <span class="st">'porch_area'</span>, <span class="st">'building_area'</span>, <span class="st">'land_area'</span>,</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_value'</span>, <span class="st">'land_value'</span>, <span class="st">'assessed'</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>neigh_stat_cols <span class="op">=</span> [</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">'neigh_assess_mean'</span>, <span class="st">'neigh_assess_std'</span>, <span class="st">'neigh_assess_median'</span>,</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">'neigh_assess_q1'</span>, <span class="st">'neigh_assess_q3'</span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Collect log-transformable columns (2015‚Äì2019 + neighborhood stats)</span></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>log_transform_cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> base <span class="kw">in</span> log_bases <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)]</span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a>log_transform_cols <span class="op">+=</span> neigh_stat_cols</span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute skewness on train and apply log1p only if skew &gt; 2</span></span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> log_transform_cols:</span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a>        skew <span class="op">=</span> train_merged[col].skew()</span>
<span id="cb43-21"><a href="#cb43-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> skew <span class="op">&gt;</span> <span class="dv">2</span>:</span>
<span id="cb43-22"><a href="#cb43-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> df <span class="kw">in</span> [train_merged, test_merged]:</span>
<span id="cb43-23"><a href="#cb43-23" aria-hidden="true" tabindex="-1"></a>                df[<span class="ss">f"log_</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">"</span>] <span class="op">=</span> np.log1p(df[col])</span>
<span id="cb43-24"><a href="#cb43-24" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Log-transformed: </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> (skew=</span><span class="sc">{</span>skew<span class="sc">:.2f}</span><span class="ss">)"</span>)</span>
<span id="cb43-25"><a href="#cb43-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb43-26"><a href="#cb43-26" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"‚Ñπ Skipped: </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> (skew=</span><span class="sc">{</span>skew<span class="sc">:.2f}</span><span class="ss">)"</span>)</span>
<span id="cb43-27"><a href="#cb43-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-28"><a href="#cb43-28" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 2: Percentile Clipping at 0.1%‚Äì99.9% ===</span></span>
<span id="cb43-29"><a href="#cb43-29" aria-hidden="true" tabindex="-1"></a>clip_bases <span class="op">=</span> [<span class="st">'floors'</span>, <span class="st">'full_bath'</span>, <span class="st">'total_rooms'</span>, <span class="st">'bedrooms'</span>]</span>
<span id="cb43-30"><a href="#cb43-30" aria-hidden="true" tabindex="-1"></a>clip_cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> base <span class="kw">in</span> clip_bases <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)]</span>
<span id="cb43-31"><a href="#cb43-31" aria-hidden="true" tabindex="-1"></a>clip_cols <span class="op">+=</span> [<span class="st">'neigh_count'</span>]  <span class="co"># add any other specific columns if needed</span></span>
<span id="cb43-32"><a href="#cb43-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-33"><a href="#cb43-33" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute clipping bounds from train</span></span>
<span id="cb43-34"><a href="#cb43-34" aria-hidden="true" tabindex="-1"></a>clip_bounds <span class="op">=</span> {</span>
<span id="cb43-35"><a href="#cb43-35" aria-hidden="true" tabindex="-1"></a>    col: (</span>
<span id="cb43-36"><a href="#cb43-36" aria-hidden="true" tabindex="-1"></a>        train_merged[col].quantile(<span class="fl">0.001</span>),</span>
<span id="cb43-37"><a href="#cb43-37" aria-hidden="true" tabindex="-1"></a>        train_merged[col].quantile(<span class="fl">0.999</span>)</span>
<span id="cb43-38"><a href="#cb43-38" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb43-39"><a href="#cb43-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> col <span class="kw">in</span> clip_cols <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns</span>
<span id="cb43-40"><a href="#cb43-40" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb43-41"><a href="#cb43-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-42"><a href="#cb43-42" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply clipping to both train and test</span></span>
<span id="cb43-43"><a href="#cb43-43" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col, (lower, upper) <span class="kw">in</span> clip_bounds.items():</span>
<span id="cb43-44"><a href="#cb43-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> df <span class="kw">in</span> [train_merged, test_merged]:</span>
<span id="cb43-45"><a href="#cb43-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb43-46"><a href="#cb43-46" aria-hidden="true" tabindex="-1"></a>            df[col] <span class="op">=</span> np.clip(df[col], lower, upper)</span>
<span id="cb43-47"><a href="#cb43-47" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Clipped: </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> to [</span><span class="sc">{</span>lower<span class="sc">:.2f}</span><span class="ss">, </span><span class="sc">{</span>upper<span class="sc">:.2f}</span><span class="ss">]"</span>)</span>
<span id="cb43-48"><a href="#cb43-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-49"><a href="#cb43-49" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> Finished: Skew-aware log transformation + 0.001‚Äì0.999 percentile clipping."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="2205c79c" class="cell" data-execution_count="44">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add_features(df):</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.copy()</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Ratio features ===</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'area_ratio'</span>] <span class="op">=</span> df[<span class="st">'building_area_2019'</span>] <span class="op">/</span> (df[<span class="st">'land_area_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'porch_ratio'</span>] <span class="op">=</span> df[<span class="st">'porch_area_2019'</span>] <span class="op">/</span> (df[<span class="st">'building_area_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'floor_density'</span>] <span class="op">=</span> df[<span class="st">'floor_area_total_2019'</span>] <span class="op">/</span> (df[<span class="st">'land_area_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'log_build_density'</span>] <span class="op">=</span> df[<span class="st">'log_building_area_2019'</span>] <span class="op">-</span> df[<span class="st">'log_land_area_2019'</span>]</span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'log_land_to_build_ratio'</span>] <span class="op">=</span> df[<span class="st">'log_land_area_2019'</span>] <span class="op">-</span> df[<span class="st">'log_building_area_2019'</span>]</span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'value_ratio'</span>] <span class="op">=</span> df[<span class="st">'building_value_2018'</span>] <span class="op">/</span> (df[<span class="st">'land_value_2018'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'log_value_diff'</span>] <span class="op">=</span> df[<span class="st">'log_building_value_2018'</span>] <span class="op">-</span> df[<span class="st">'log_land_value_2018'</span>]</span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'value_per_sqft'</span>] <span class="op">=</span> df[<span class="st">'building_value_2018'</span>] <span class="op">/</span> (df[<span class="st">'building_area_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'price_per_sqft'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">/</span> (df[<span class="st">'building_area_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Bathroom &amp; room structure ===</span></span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'bathroom_score'</span>] <span class="op">=</span> df[<span class="st">'full_bath_2019'</span>] <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> df[<span class="st">'half_bath_2019'</span>]</span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'bathroom_density'</span>] <span class="op">=</span> df[<span class="st">'bathroom_score'</span>] <span class="op">/</span> (df[<span class="st">'total_rooms_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb44-19"><a href="#cb44-19" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'bedroom_ratio'</span>] <span class="op">=</span> df[<span class="st">'bedrooms_2019'</span>] <span class="op">/</span> (df[<span class="st">'total_rooms_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb44-20"><a href="#cb44-20" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'rooms_per_floor'</span>] <span class="op">=</span> df[<span class="st">'total_rooms_2019'</span>] <span class="op">/</span> (df[<span class="st">'floors_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb44-21"><a href="#cb44-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-22"><a href="#cb44-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Core interactions ===</span></span>
<span id="cb44-23"><a href="#cb44-23" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'bedrooms_x_floors'</span>] <span class="op">=</span> df[<span class="st">'bedrooms_2019'</span>] <span class="op">*</span> df[<span class="st">'floors_2019'</span>]</span>
<span id="cb44-24"><a href="#cb44-24" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'rooms_x_quality'</span>] <span class="op">=</span> df[<span class="st">'total_rooms_2019'</span>] <span class="op">*</span> df[<span class="st">'quality_2019'</span>]</span>
<span id="cb44-25"><a href="#cb44-25" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'log_area_x_grade'</span>] <span class="op">=</span> df[<span class="st">'log_building_area_2019'</span>] <span class="op">*</span> df[<span class="st">'grade_2019'</span>]</span>
<span id="cb44-26"><a href="#cb44-26" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'log_assess_x_age'</span>] <span class="op">=</span> df[<span class="st">'log_assessed_2018'</span>] <span class="op">*</span> df[<span class="st">'building_age'</span>]</span>
<span id="cb44-27"><a href="#cb44-27" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'assess_spread_neigh'</span>] <span class="op">=</span> df[<span class="st">'log_neigh_assess_q3'</span>] <span class="op">-</span> df[<span class="st">'log_neigh_assess_q1'</span>]</span>
<span id="cb44-28"><a href="#cb44-28" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'grade_quality_index'</span>] <span class="op">=</span> df[<span class="st">'grade_2019'</span>] <span class="op">*</span> df[<span class="st">'quality_2019'</span>]</span>
<span id="cb44-29"><a href="#cb44-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-30"><a href="#cb44-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Clean up ===</span></span>
<span id="cb44-31"><a href="#cb44-31" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.replace([np.inf, <span class="op">-</span>np.inf], np.nan)</span>
<span id="cb44-32"><a href="#cb44-32" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.fillna(<span class="dv">0</span>)</span>
<span id="cb44-33"><a href="#cb44-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb44-34"><a href="#cb44-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-35"><a href="#cb44-35" aria-hidden="true" tabindex="-1"></a><span class="co"># === Apply to train and test ===</span></span>
<span id="cb44-36"><a href="#cb44-36" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> add_features(train_merged)</span>
<span id="cb44-37"><a href="#cb44-37" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> add_features(test_merged)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="74bfd08b" class="cell" data-execution_count="45">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Select numeric columns only</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>numeric_features <span class="op">=</span> train_merged.select_dtypes(include<span class="op">=</span>[<span class="st">'int64'</span>, <span class="st">'float64'</span>])</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate skewness</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>skewness <span class="op">=</span> numeric_features.skew(numeric_only<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter and sort features with skewness &gt; 30</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>highly_skewed <span class="op">=</span> skewness[skewness <span class="op">&gt;</span> <span class="dv">2</span>].sort_values(ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Features with skewness &gt; 2:"</span>)</span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(highly_skewed)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="a8e0d9f2" class="cell" data-execution_count="46">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co"># List of columns to drop due to extreme skewness</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> [<span class="st">'building_value_growth_missing'</span>, <span class="st">'land_value_growth_missing'</span>,<span class="st">'assessed_growth_missing'</span>]</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop from both train and test</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>, errors<span class="op">=</span><span class="st">'ignore'</span>)</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>, errors<span class="op">=</span><span class="st">'ignore'</span>)</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Dropped extremely skewed columns related to value growth missingness."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="d01fd379" class="cell" data-execution_count="47">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Features to log-transform due to extreme skew</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>skewed_cols <span class="op">=</span> [<span class="st">'price_per_sqft'</span>, <span class="st">'value_per_sqft'</span>, <span class="st">'porch_ratio'</span>, <span class="st">'value_ratio'</span>,<span class="st">'land_area_2015'</span>,<span class="st">'land_area_2016'</span>,<span class="st">'land_area_2017'</span>,<span class="st">'land_area_2018'</span>,<span class="st">'land_area_2019'</span>]</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> col <span class="kw">in</span> skewed_cols:</span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>            df[<span class="ss">f'log_</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">'</span>] <span class="op">=</span> np.log1p(df[col])</span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>            df.drop(columns<span class="op">=</span>col, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Log-transformed and dropped raw versions of highly skewed ratio features."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="7cf3d4c4" class="cell" data-execution_count="48">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">"TARGET"</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    train_merged.drop(<span class="st">"TARGET"</span>, axis<span class="op">=</span><span class="dv">1</span>,inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"TARGET not found in columns:"</span>, train_merged.columns.tolist())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="bebd1967" class="cell" data-execution_count="49">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define columns to drop</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>year_built_cols <span class="op">=</span> [<span class="ss">f'year_built_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)]</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop if columns exist</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>[col <span class="cf">for</span> col <span class="kw">in</span> year_built_cols <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>[col <span class="cf">for</span> col <span class="kw">in</span> year_built_cols <span class="cf">if</span> col <span class="kw">in</span> test_merged.columns], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Dropped year_built_2015 to year_built_2018 from both train and test sets."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="0cb29fb0" class="cell" data-execution_count="50">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>train_cols <span class="op">=</span> <span class="bu">set</span>(train_merged.columns)</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>test_cols <span class="op">=</span> <span class="bu">set</span>(test_merged.columns)</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>missing_in_test <span class="op">=</span> train_cols <span class="op">-</span> test_cols</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>missing_in_train <span class="op">=</span> test_cols <span class="op">-</span> train_cols</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Columns in train but not in test:"</span>)</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">sorted</span>(missing_in_test))</span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> Columns in test but not in train:"</span>)</span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">sorted</span>(missing_in_train))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="64a941dd" class="cell" data-execution_count="51">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Check if column sets match</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">set</span>(train_merged.columns) <span class="op">==</span> <span class="bu">set</span>(test_merged.columns))  <span class="co"># Should be True</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Check if column order matches</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">list</span>(train_merged.columns) <span class="op">==</span> <span class="bu">list</span>(test_merged.columns))  <span class="co"># Must also be True</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="53eb4b51" class="cell" data-execution_count="52">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> RidgeCV</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.pipeline <span class="im">import</span> make_pipeline</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> KFold</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> root_mean_squared_error</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> KFold</span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 2: Prepare training/test matrices ===</span></span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> train_merged.copy()</span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a>X_test <span class="op">=</span> test_merged.copy()</span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> pd.Series(y_train).values <span class="co"># use raw target (not log)</span></span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 3: RidgeCV pipeline ===</span></span>
<span id="cb52-16"><a href="#cb52-16" aria-hidden="true" tabindex="-1"></a>kf <span class="op">=</span> KFold(n_splits<span class="op">=</span><span class="dv">3</span>, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb52-17"><a href="#cb52-17" aria-hidden="true" tabindex="-1"></a>alphas <span class="op">=</span> np.logspace(<span class="op">-</span><span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">10</span>)</span>
<span id="cb52-18"><a href="#cb52-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-19"><a href="#cb52-19" aria-hidden="true" tabindex="-1"></a>ridge_oof <span class="op">=</span> np.zeros(<span class="bu">len</span>(X))</span>
<span id="cb52-20"><a href="#cb52-20" aria-hidden="true" tabindex="-1"></a>ridge_test_preds <span class="op">=</span> np.zeros(<span class="bu">len</span>(X_test))</span>
<span id="cb52-21"><a href="#cb52-21" aria-hidden="true" tabindex="-1"></a>best_alphas <span class="op">=</span> []</span>
<span id="cb52-22"><a href="#cb52-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-23"><a href="#cb52-23" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> fold, (train_idx, val_idx) <span class="kw">in</span> <span class="bu">enumerate</span>(kf.split(X)):</span>
<span id="cb52-24"><a href="#cb52-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss"> Fold </span><span class="sc">{</span>fold<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">/5"</span>)</span>
<span id="cb52-25"><a href="#cb52-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-26"><a href="#cb52-26" aria-hidden="true" tabindex="-1"></a>    X_train, y_train_fold <span class="op">=</span> X.iloc[train_idx], y[train_idx]</span>
<span id="cb52-27"><a href="#cb52-27" aria-hidden="true" tabindex="-1"></a>    X_val, y_val <span class="op">=</span> X.iloc[val_idx], y[val_idx]</span>
<span id="cb52-28"><a href="#cb52-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-29"><a href="#cb52-29" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> make_pipeline(</span>
<span id="cb52-30"><a href="#cb52-30" aria-hidden="true" tabindex="-1"></a>        StandardScaler(),</span>
<span id="cb52-31"><a href="#cb52-31" aria-hidden="true" tabindex="-1"></a>        RidgeCV(alphas<span class="op">=</span>alphas, cv<span class="op">=</span><span class="dv">3</span>, scoring<span class="op">=</span><span class="st">'neg_root_mean_squared_error'</span>)</span>
<span id="cb52-32"><a href="#cb52-32" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb52-33"><a href="#cb52-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-34"><a href="#cb52-34" aria-hidden="true" tabindex="-1"></a>    model.fit(X_train, y_train_fold)</span>
<span id="cb52-35"><a href="#cb52-35" aria-hidden="true" tabindex="-1"></a>    ridge_oof[val_idx] <span class="op">=</span> model.predict(X_val)</span>
<span id="cb52-36"><a href="#cb52-36" aria-hidden="true" tabindex="-1"></a>    ridge_test_preds <span class="op">+=</span> model.predict(X_test) <span class="op">/</span> kf.get_n_splits()</span>
<span id="cb52-37"><a href="#cb52-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-38"><a href="#cb52-38" aria-hidden="true" tabindex="-1"></a>    best_alpha <span class="op">=</span> model.named_steps[<span class="st">'ridgecv'</span>].alpha_</span>
<span id="cb52-39"><a href="#cb52-39" aria-hidden="true" tabindex="-1"></a>    best_alphas.append(best_alpha)</span>
<span id="cb52-40"><a href="#cb52-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb52-41"><a href="#cb52-41" aria-hidden="true" tabindex="-1"></a>    fold_rmse <span class="op">=</span> root_mean_squared_error(y_val, ridge_oof[val_idx])</span>
<span id="cb52-42"><a href="#cb52-42" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Fold </span><span class="sc">{</span>fold<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss"> RMSE: </span><span class="sc">{</span>fold_rmse<span class="sc">:,.2f}</span><span class="ss"> | Best alpha: </span><span class="sc">{</span>best_alpha<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb52-43"><a href="#cb52-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-44"><a href="#cb52-44" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 4: Final RMSE ===</span></span>
<span id="cb52-45"><a href="#cb52-45" aria-hidden="true" tabindex="-1"></a>final_rmse <span class="op">=</span> root_mean_squared_error(y, ridge_oof)</span>
<span id="cb52-46"><a href="#cb52-46" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss"> Final OOF RMSE (RidgeCV): </span><span class="sc">{</span>final_rmse<span class="sc">:,.2f}</span><span class="ss">"</span>)</span>
<span id="cb52-47"><a href="#cb52-47" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" Average best alpha across folds: </span><span class="sc">{</span>np<span class="sc">.</span>mean(best_alphas)<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb52-48"><a href="#cb52-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-49"><a href="#cb52-49" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 5: Save predictions ===</span></span>
<span id="cb52-50"><a href="#cb52-50" aria-hidden="true" tabindex="-1"></a>submission <span class="op">=</span> pd.DataFrame({</span>
<span id="cb52-51"><a href="#cb52-51" aria-hidden="true" tabindex="-1"></a>    <span class="st">"ACCOUNT"</span>: acct_test.values.ravel(),</span>
<span id="cb52-52"><a href="#cb52-52" aria-hidden="true" tabindex="-1"></a>    <span class="st">"TARGET"</span>: ridge_test_preds</span>
<span id="cb52-53"><a href="#cb52-53" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb52-54"><a href="#cb52-54" aria-hidden="true" tabindex="-1"></a>submission.to_csv(<span class="st">"submission_ridgecv_pipeline.csv"</span>, index<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb52-55"><a href="#cb52-55" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> Saved: submission_ridgecv_pipeline.csv"</span>)</span>
<span id="cb52-56"><a href="#cb52-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-57"><a href="#cb52-57" aria-hidden="true" tabindex="-1"></a><span class="co"># === Optional: Save OOF &amp; test preds for stacking or analysis ===</span></span>
<span id="cb52-58"><a href="#cb52-58" aria-hidden="true" tabindex="-1"></a>np.save(<span class="st">"ridgecv_oof_preds.npy"</span>, ridge_oof)</span>
<span id="cb52-59"><a href="#cb52-59" aria-hidden="true" tabindex="-1"></a>np.save(<span class="st">"ridgecv_test_preds.npy"</span>, ridge_test_preds)</span>
<span id="cb52-60"><a href="#cb52-60" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Saved: ridgecv_oof_preds.npy and ridgecv_test_preds.npy"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="xgboost-lightgbm-pipeline" class="level1">
<h1>XGBoost &amp; LightGBM Pipeline</h1>
<div id="6bacdccb" class="cell" data-execution_count="53">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="co"># ===== Load Data =====</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>folder_path <span class="op">=</span> <span class="st">'/Users/Srijith97/Downloads/STA 9890 Housing Data/'</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>building_years <span class="op">=</span> []</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>):</span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.read_csv(folder_path <span class="op">+</span> <span class="ss">f'building_details_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">.csv'</span>)</span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'year'</span>] <span class="op">=</span> year</span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>    building_years.append(df)</span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>building_all <span class="op">=</span> pd.concat(building_years, ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>building_all <span class="op">=</span> building_all.drop_duplicates(subset<span class="op">=</span>[<span class="st">'acct'</span>, <span class="st">'year'</span>], keep<span class="op">=</span><span class="st">'first'</span>)</span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>pivoted <span class="op">=</span> building_all.pivot(index<span class="op">=</span><span class="st">'acct'</span>, columns<span class="op">=</span><span class="st">'year'</span>)</span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a>pivoted.columns <span class="op">=</span> [<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> col, year <span class="kw">in</span> pivoted.columns]</span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a>pivoted <span class="op">=</span> pivoted.reset_index()</span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true" tabindex="-1"></a>train <span class="op">=</span> pd.read_csv(folder_path <span class="op">+</span> <span class="st">'assessment_history_train.csv'</span>)</span>
<span id="cb53-20"><a href="#cb53-20" aria-hidden="true" tabindex="-1"></a>test <span class="op">=</span> pd.read_csv(folder_path <span class="op">+</span> <span class="st">'assessment_history_test.csv'</span>)</span>
<span id="cb53-21"><a href="#cb53-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-22"><a href="#cb53-22" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> train.merge(pivoted, on<span class="op">=</span><span class="st">'acct'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb53-23"><a href="#cb53-23" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> test.merge(pivoted, on<span class="op">=</span><span class="st">'acct'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="60160f45" class="cell" data-execution_count="54">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1: Identify all '2019' columns in train</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>train_2019_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> <span class="st">'2019'</span> <span class="kw">in</span> col]</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 2: Find which 2019 columns are missing in test</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>train_only_2019_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_2019_cols <span class="cf">if</span> col <span class="kw">not</span> <span class="kw">in</span> test_merged.columns]</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 3: Always drop 'protested_2019' due to leakage risk</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>train_only_2019_cols.append(<span class="st">'protested_2019'</span>)</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 4: Drop the identified columns from train</span></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> train_merged.drop(columns<span class="op">=</span>train_only_2019_cols, errors<span class="op">=</span><span class="st">'ignore'</span>)</span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 5: Optional logging</span></span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" Dropped </span><span class="sc">{</span><span class="bu">len</span>(train_only_2019_cols)<span class="sc">}</span><span class="ss"> columns from train (including protested_2019 if present):"</span>)</span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(train_only_2019_cols)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="fe25f198" class="cell" data-execution_count="55">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'protested_2019'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>        df.drop(columns<span class="op">=</span><span class="st">'protested_2019'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Dropped 'protested_2019' from </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" 'protested_2019' not found in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="5f0f1301" class="cell" data-execution_count="56">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="co">## Get all '2019' columns in train and test</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>train_2019_cols <span class="op">=</span> <span class="bu">sorted</span>([col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> <span class="st">'2019'</span> <span class="kw">in</span> col])</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>test_2019_cols <span class="op">=</span> <span class="bu">sorted</span>([col <span class="cf">for</span> col <span class="kw">in</span> test_merged.columns <span class="cf">if</span> <span class="st">'2019'</span> <span class="kw">in</span> col])</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Print train columns</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" 2019 Columns in train_merged:"</span>)</span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> train_2019_cols:</span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" - </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> 2019 Columns in test_merged:"</span>)</span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> test_2019_cols:</span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" - </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="4ffb1130" class="cell" data-execution_count="57">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compare sets</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>train_only_2019 <span class="op">=</span> <span class="bu">sorted</span>(<span class="bu">list</span>(<span class="bu">set</span>(train_2019_cols) <span class="op">-</span> <span class="bu">set</span>(test_2019_cols)))</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>test_only_2019 <span class="op">=</span> <span class="bu">sorted</span>(<span class="bu">list</span>(<span class="bu">set</span>(test_2019_cols) <span class="op">-</span> <span class="bu">set</span>(train_2019_cols)))</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Print comparison result</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> train_only_2019 <span class="kw">and</span> <span class="kw">not</span> test_only_2019:</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> All 2019 columns match between train_merged and test_merged."</span>)</span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> Mismatched 2019 columns found:"</span>)</span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> train_only_2019:</span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">" In train_merged but not in test_merged:"</span>)</span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> col <span class="kw">in</span> train_only_2019:</span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"   - </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> test_only_2019:</span>
<span id="cb57-17"><a href="#cb57-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">" In test_merged but not in train_merged:"</span>)</span>
<span id="cb57-18"><a href="#cb57-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> col <span class="kw">in</span> test_only_2019:</span>
<span id="cb57-19"><a href="#cb57-19" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"   - </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="73de267a" class="cell" data-execution_count="58">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1: Store target separately</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>y_train <span class="op">=</span> train_merged[<span class="st">"TARGET"</span>].values</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 4: Confirm sizes</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Train shape: </span><span class="sc">{</span>train<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Test shape: </span><span class="sc">{</span>test<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="9ec1148e" class="cell" data-execution_count="59">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate % of missing values in each column of TRAIN only</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>train_na <span class="op">=</span> (train_merged.isnull().<span class="bu">sum</span>() <span class="op">/</span> train_merged.shape[<span class="dv">0</span>]) <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop columns with no missing values, sort the rest</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>train_na <span class="op">=</span> train_na[train_na <span class="op">&gt;</span> <span class="dv">0</span>].sort_values(ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Optional: Show top 200 missing features</span></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a>missing_data <span class="op">=</span> pd.DataFrame({<span class="st">'Missing Ratio (%)'</span>: train_na})</span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Display</span></span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Top columns with missing data (based on training set only):"</span>)</span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a>missing_data.head(<span class="dv">20</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="305a299e" class="cell" data-execution_count="60">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_floor_area_totals(df, years):</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> y <span class="kw">in</span> years:</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>        primary_col <span class="op">=</span> <span class="ss">f'floor_area_primary_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">'</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>        upper_col   <span class="op">=</span> <span class="ss">f'floor_area_upper_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">'</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>        lower_col   <span class="op">=</span> <span class="ss">f'floor_area_lower_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">'</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>        total_col   <span class="op">=</span> <span class="ss">f'floor_area_total_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">'</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">all</span>(col <span class="kw">in</span> df.columns <span class="cf">for</span> col <span class="kw">in</span> [primary_col, upper_col, lower_col]):</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>            df[total_col] <span class="op">=</span> (</span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>                df[primary_col].fillna(<span class="dv">0</span>) <span class="op">+</span></span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>                df[upper_col].fillna(<span class="dv">0</span>) <span class="op">+</span></span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a>                df[lower_col].fillna(<span class="dv">0</span>)</span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Created: </span><span class="sc">{</span>total_col<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipping </span><span class="sc">{</span>total_col<span class="sc">}</span><span class="ss"> ‚Äî one or more components missing."</span>)</span>
<span id="cb60-17"><a href="#cb60-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb60-18"><a href="#cb60-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-19"><a href="#cb60-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply for years 2015‚Äì2019</span></span>
<span id="cb60-20"><a href="#cb60-20" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2015'</span>, <span class="st">'2016'</span>, <span class="st">'2017'</span>, <span class="st">'2018'</span>, <span class="st">'2019'</span>]</span>
<span id="cb60-21"><a href="#cb60-21" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> create_floor_area_totals(train_merged, years)</span>
<span id="cb60-22"><a href="#cb60-22" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> create_floor_area_totals(test_merged, years)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="dead704d" class="cell" data-execution_count="61">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>zero_pct <span class="op">=</span> (train_merged[<span class="st">'mobile_home_area_2015'</span>] <span class="op">==</span> <span class="dv">0</span>).mean() <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" mobile_home_area_2015 is 0 in </span><span class="sc">{</span>zero_pct<span class="sc">:.2f}</span><span class="ss">% of training rows"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="95809def" class="cell" data-execution_count="62">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> col.startswith(<span class="st">"mobile_home_area"</span>)]</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop from both sets</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>, errors<span class="op">=</span><span class="st">'ignore'</span>)</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>, errors<span class="op">=</span><span class="st">'ignore'</span>)</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" Dropped columns from train/test: </span><span class="sc">{</span>cols_to_drop<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="357369db" class="cell" data-execution_count="63">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>zero_pct <span class="op">=</span> (train_merged[<span class="st">'deck_area_2015'</span>] <span class="op">==</span> <span class="dv">0</span>).mean() <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" deck_area_2015 is 0 in </span><span class="sc">{</span>zero_pct<span class="sc">:.2f}</span><span class="ss">% of training rows"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="ca33d505" class="cell" data-execution_count="64">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Use training columns to identify which deck_area columns exist</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> col.startswith(<span class="st">"deck_area"</span>)]</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop those columns from both datasets</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" Dropped columns from train/test: </span><span class="sc">{</span>cols_to_drop<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="4ccd7fc7" class="cell" data-execution_count="65">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_yearly_features(df, base_features, years):</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> feature <span class="kw">in</span> base_features:</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>        cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Backfill all relevant year columns in-place</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>            df[cols] <span class="op">=</span> df[cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Backfilled: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> across </span><span class="sc">{</span>cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipping </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> ‚Äî not enough year columns found."</span>)</span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Years in reverse so that bfill works from most recent (2019) to oldest (2015)</span></span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>features <span class="op">=</span> [<span class="st">'garage_area'</span>, <span class="st">'porch_area'</span>]</span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to both train and test</span></span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_yearly_features(train_merged, features, years)</span>
<span id="cb65-18"><a href="#cb65-18" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_yearly_features(test_merged, features, years)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="8b73679f" class="cell" data-execution_count="66">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_yearly_features(df, features, years):</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> feature <span class="kw">in</span> features:</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>        year_cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(year_cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>            df[year_cols] <span class="op">=</span> df[year_cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Backfilled: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> across </span><span class="sc">{</span>year_cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipped: Not enough year columns for '</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">'"</span>)</span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Use years in reverse for proper backfill (newest to oldest)</span></span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a>features <span class="op">=</span> [<span class="st">'floors'</span>, <span class="st">'half_bath'</span>, <span class="st">'full_bath'</span>, <span class="st">'total_rooms'</span>, <span class="st">'bedrooms'</span>]</span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to both train and test</span></span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_yearly_features(train_merged, features, years)</span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_yearly_features(test_merged, features, years)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="e8946bf3" class="cell" data-execution_count="67">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Identify elevator-related columns from training set</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>elevator_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> col.startswith(<span class="st">"elevator"</span>)]</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop from both train and test</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>elevator_cols, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>elevator_cols, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" Dropped elevator-related columns from train/test: </span><span class="sc">{</span>elevator_cols<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="db9fef04" class="cell" data-execution_count="68">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_year_features(df, features, years):</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> feature <span class="kw">in</span> features:</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>        cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>            df[cols] <span class="op">=</span> df[cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Backfilled: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> across </span><span class="sc">{</span>cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipped </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> ‚Äî not enough year-based columns found."</span>)</span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_year_built_final(df):</span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a>    year_cols <span class="op">=</span> [<span class="ss">f"year_built_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>] <span class="cf">if</span> <span class="ss">f"year_built_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> year_cols:</span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'year_built_final'</span>] <span class="op">=</span> df[year_cols].bfill(axis<span class="op">=</span><span class="dv">1</span>).iloc[:, <span class="dv">0</span>]</span>
<span id="cb68-15"><a href="#cb68-15" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Created year_built_final from: </span><span class="sc">{</span>year_cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb68-16"><a href="#cb68-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb68-17"><a href="#cb68-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">" Skipped: no year_built_* columns found."</span>)</span>
<span id="cb68-18"><a href="#cb68-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb68-19"><a href="#cb68-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-20"><a href="#cb68-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Define reverse years for backfill (latest ‚Üí oldest)</span></span>
<span id="cb68-21"><a href="#cb68-21" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb68-22"><a href="#cb68-22" aria-hidden="true" tabindex="-1"></a>features_to_backfill <span class="op">=</span> [<span class="st">'fireplaces'</span>, <span class="st">'quality'</span>, <span class="st">'quality_description'</span>]</span>
<span id="cb68-23"><a href="#cb68-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-24"><a href="#cb68-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to both train and test</span></span>
<span id="cb68-25"><a href="#cb68-25" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_year_features(train_merged, features_to_backfill, years)</span>
<span id="cb68-26"><a href="#cb68-26" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> create_year_built_final(train_merged)</span>
<span id="cb68-27"><a href="#cb68-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-28"><a href="#cb68-28" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_year_features(test_merged, features_to_backfill, years)</span>
<span id="cb68-29"><a href="#cb68-29" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> create_year_built_final(test_merged)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="e981d2df" class="cell" data-execution_count="69">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="co">## Identify columns to drop from training data</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> col.startswith(<span class="st">"year_remodeled"</span>)]</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop from both train and test</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"üóëÔ∏è Dropped year_remodeled-related columns from train/test: </span><span class="sc">{</span>cols_to_drop<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="9a83c25b" class="cell" data-execution_count="70">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_categorical_year_features(df, features, years):</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> feature <span class="kw">in</span> features:</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>        year_cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(year_cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>            df[year_cols] <span class="op">=</span> df[year_cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Backfilled: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> across </span><span class="sc">{</span>year_cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipped: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> ‚Äî not enough year-based columns."</span>)</span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb70-10"><a href="#cb70-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-11"><a href="#cb70-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Backfill from most recent year to oldest</span></span>
<span id="cb70-12"><a href="#cb70-12" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb70-13"><a href="#cb70-13" aria-hidden="true" tabindex="-1"></a>features <span class="op">=</span> [<span class="st">'building_condition'</span>, <span class="st">'foundation_type'</span>, <span class="st">'grade'</span>, <span class="st">'has_cooling'</span>, </span>
<span id="cb70-14"><a href="#cb70-14" aria-hidden="true" tabindex="-1"></a>            <span class="st">'has_heat'</span>, <span class="st">'physical_condition'</span>, <span class="st">'exterior_walls'</span>]</span>
<span id="cb70-15"><a href="#cb70-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-16"><a href="#cb70-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to train and test</span></span>
<span id="cb70-17"><a href="#cb70-17" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_categorical_year_features(train_merged, features, years)</span>
<span id="cb70-18"><a href="#cb70-18" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_categorical_year_features(test_merged, features, years)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="35ebf22f" class="cell" data-execution_count="71">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_year_columns(df, features, years):</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> feature <span class="kw">in</span> features:</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>        cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>            df[cols] <span class="op">=</span> df[cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Backfilled: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> across </span><span class="sc">{</span>cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipped: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> ‚Äî not enough year-based columns found."</span>)</span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Define year ranges</span></span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true" tabindex="-1"></a>area_years <span class="op">=</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true" tabindex="-1"></a>value_years <span class="op">=</span> [<span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb71-14"><a href="#cb71-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-15"><a href="#cb71-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Define feature groups</span></span>
<span id="cb71-16"><a href="#cb71-16" aria-hidden="true" tabindex="-1"></a>area_features <span class="op">=</span> [<span class="st">'building_area'</span>, <span class="st">'land_area'</span>]</span>
<span id="cb71-17"><a href="#cb71-17" aria-hidden="true" tabindex="-1"></a>value_features <span class="op">=</span> [<span class="st">'building_value'</span>, <span class="st">'land_value'</span>, <span class="st">'assessed'</span>]</span>
<span id="cb71-18"><a href="#cb71-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-19"><a href="#cb71-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to train and test</span></span>
<span id="cb71-20"><a href="#cb71-20" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_year_columns(train_merged, area_features, area_years)</span>
<span id="cb71-21"><a href="#cb71-21" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_year_columns(train_merged, value_features, value_years)</span>
<span id="cb71-22"><a href="#cb71-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-23"><a href="#cb71-23" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_year_columns(test_merged, area_features, area_years)</span>
<span id="cb71-24"><a href="#cb71-24" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_year_columns(test_merged, value_features, value_years)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="9cc2d296" class="cell" data-execution_count="72">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_protested_columns(df, years):</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>    cols <span class="op">=</span> [<span class="ss">f"protested_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"protested_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>        df[cols] <span class="op">=</span> df[cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Backfilled: protested across </span><span class="sc">{</span>cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">" Skipped protested ‚Äî not enough year-based columns found."</span>)</span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Only use pre-2019 years to avoid leakage</span></span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to both datasets</span></span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_protested_columns(train_merged, years)</span>
<span id="cb72-15"><a href="#cb72-15" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_protested_columns(test_merged, years)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="97471c71" class="cell" data-execution_count="73">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Save 'acct' from test_merged only</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>acct_test <span class="op">=</span> test_merged[[<span class="st">'acct'</span>]].copy() <span class="cf">if</span> <span class="st">'acct'</span> <span class="kw">in</span> test_merged.columns <span class="cf">else</span> <span class="va">None</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop 'acct' from both train and test</span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'acct'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>        df.drop(columns<span class="op">=</span><span class="st">'acct'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Dropped 'acct' from </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="122edd2c" class="cell" data-execution_count="74">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> [<span class="st">'zone'</span>, <span class="st">'subneighborhood'</span>, <span class="st">'neighborhood'</span>, <span class="st">'region'</span>]:</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>train_merged[col]<span class="sc">.</span>nunique()<span class="sc">}</span><span class="ss"> unique values in training set"</span>)</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> not found in training set"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>cols_to_drop = [‚Äòzone‚Äô, ‚Äòsubneighborhood‚Äô]</p>
<p>for df_name, df in [(‚Äòtrain_merged‚Äô, train_merged), (‚Äòtest_merged‚Äô, test_merged)]: drop_cols = [col for col in cols_to_drop if col in df.columns] if drop_cols: df.drop(columns=drop_cols, inplace=True) print(f‚ÄùüóëÔ∏è Dropped columns from {df_name}: {drop_cols}‚Äú)</p>
<div id="688cc498" class="cell" data-execution_count="75">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> [<span class="st">'neighborhood'</span>, <span class="st">'region'</span>,<span class="st">'zone'</span>,<span class="st">'subneighborhood'</span>]:</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 1: Compute frequency from training data</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>        freq_map <span class="op">=</span> train_merged[col].value_counts(normalize<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 2: Apply to both datasets</span></span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a>        train_merged[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_freq'</span>] <span class="op">=</span> train_merged[col].<span class="bu">map</span>(freq_map)</span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a>        test_merged[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_freq'</span>] <span class="op">=</span> test_merged[col].<span class="bu">map</span>(freq_map)</span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Frequency encoded: </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> ‚Üí </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_freq (based on training set)"</span>)</span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb75-12"><a href="#cb75-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Column '</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">' not found in training set"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="324715a8" class="cell" data-execution_count="76">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">all</span>(col <span class="kw">in</span> train_merged.columns <span class="cf">for</span> col <span class="kw">in</span> [<span class="st">'land_area_2019'</span>, <span class="st">'land_area_2015'</span>]):</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>    growth <span class="op">=</span> train_merged[<span class="st">'land_area_2019'</span>] <span class="op">-</span> train_merged[<span class="st">'land_area_2015'</span>]</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>    changed_pct <span class="op">=</span> (growth <span class="op">!=</span> <span class="dv">0</span>).mean() <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Percentage of homes with land area change (2015‚Üí2019): </span><span class="sc">{</span>changed_pct<span class="sc">:.2f}</span><span class="ss">%"</span>)</span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">" One or both columns ('land_area_2015', 'land_area_2019') not found in training set"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="7d43d473" class="cell" data-execution_count="77">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'year_built_final'</span>] <span class="op">=</span> df[<span class="st">'year_built_final'</span>].astype(<span class="bu">str</span>)</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Converted 'year_built_final' to string in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" 'year_built_final' not found in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="b758b8ad" class="cell" data-execution_count="78">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'floor_area_total_final'</span> <span class="kw">in</span> df.columns <span class="kw">and</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>        df.loc[df[<span class="st">'floor_area_total_final'</span>] <span class="op">==</span> <span class="dv">0</span>, <span class="st">'year_built_final'</span>] <span class="op">=</span> <span class="st">'None'</span></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Set 'year_built_final' to 'None' where 'floor_area_total_final' == 0 in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Required columns missing in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="8a4ffd03" class="cell" data-execution_count="79">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define year ranges per feature type</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>value_years <span class="op">=</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2019</span>)   <span class="co"># 2015‚Äì2018 for value columns</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>area_years  <span class="op">=</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)   <span class="co"># 2015‚Äì2019 for area columns</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Define base columns</span></span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>base_cols_year_map <span class="op">=</span> {</span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_value'</span>: value_years,</span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">'land_value'</span>: value_years,</span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_area'</span>: area_years,</span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">'land_area'</span>: area_years,</span>
<span id="cb79-11"><a href="#cb79-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb79-12"><a href="#cb79-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-13"><a href="#cb79-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate full list of columns to impute</span></span>
<span id="cb79-14"><a href="#cb79-14" aria-hidden="true" tabindex="-1"></a>cols_to_impute <span class="op">=</span> []</span>
<span id="cb79-15"><a href="#cb79-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> base, years <span class="kw">in</span> base_cols_year_map.items():</span>
<span id="cb79-16"><a href="#cb79-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> year <span class="kw">in</span> years:</span>
<span id="cb79-17"><a href="#cb79-17" aria-hidden="true" tabindex="-1"></a>        cols_to_impute.append(<span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb79-18"><a href="#cb79-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-19"><a href="#cb79-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Impute using neighborhood ‚Üí region strategy</span></span>
<span id="cb79-20"><a href="#cb79-20" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> cols_to_impute:</span>
<span id="cb79-21"><a href="#cb79-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># First, fill by neighborhood (train only)</span></span>
<span id="cb79-22"><a href="#cb79-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'neighborhood'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb79-23"><a href="#cb79-23" aria-hidden="true" tabindex="-1"></a>        medians_by_neigh <span class="op">=</span> train_merged.groupby(<span class="st">'neighborhood'</span>)[col].median()</span>
<span id="cb79-24"><a href="#cb79-24" aria-hidden="true" tabindex="-1"></a>        train_merged[col] <span class="op">=</span> train_merged.<span class="bu">apply</span>(</span>
<span id="cb79-25"><a href="#cb79-25" aria-hidden="true" tabindex="-1"></a>            <span class="kw">lambda</span> row: medians_by_neigh[row[<span class="st">'neighborhood'</span>]] <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb79-26"><a href="#cb79-26" aria-hidden="true" tabindex="-1"></a>        test_merged[col] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb79-27"><a href="#cb79-27" aria-hidden="true" tabindex="-1"></a>            <span class="kw">lambda</span> row: medians_by_neigh.get(row[<span class="st">'neighborhood'</span>], np.nan) <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb79-28"><a href="#cb79-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-29"><a href="#cb79-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Then, fill remaining by region (train only)</span></span>
<span id="cb79-30"><a href="#cb79-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'region'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb79-31"><a href="#cb79-31" aria-hidden="true" tabindex="-1"></a>        medians_by_region <span class="op">=</span> train_merged.groupby(<span class="st">'region'</span>)[col].median()</span>
<span id="cb79-32"><a href="#cb79-32" aria-hidden="true" tabindex="-1"></a>        train_merged[col] <span class="op">=</span> train_merged.<span class="bu">apply</span>(</span>
<span id="cb79-33"><a href="#cb79-33" aria-hidden="true" tabindex="-1"></a>            <span class="kw">lambda</span> row: medians_by_region[row[<span class="st">'region'</span>]] <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb79-34"><a href="#cb79-34" aria-hidden="true" tabindex="-1"></a>        test_merged[col] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb79-35"><a href="#cb79-35" aria-hidden="true" tabindex="-1"></a>            <span class="kw">lambda</span> row: medians_by_region.get(row[<span class="st">'region'</span>], np.nan) <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb79-36"><a href="#cb79-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-37"><a href="#cb79-37" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Imputed '</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">' using group medians (neighborhood ‚Üí region) from training data"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="6ecde140" class="cell" data-execution_count="80">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb80"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pandas.api.types <span class="im">import</span> is_numeric_dtype</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1: Coerce non-numeric to NaN in both sets</span></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'year_built_final'</span>] <span class="op">=</span> pd.to_numeric(df[<span class="st">'year_built_final'</span>], errors<span class="op">=</span><span class="st">'coerce'</span>)</span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Coerced 'year_built_final' to numeric in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 2: Group-based imputation (use training data only)</span></span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> train_merged.columns <span class="kw">and</span> <span class="st">'neighborhood'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb80-11"><a href="#cb80-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Neighborhood-based median from train</span></span>
<span id="cb80-12"><a href="#cb80-12" aria-hidden="true" tabindex="-1"></a>    neigh_medians <span class="op">=</span> train_merged.groupby(<span class="st">'neighborhood'</span>)[<span class="st">'year_built_final'</span>].median()</span>
<span id="cb80-13"><a href="#cb80-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-14"><a href="#cb80-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Apply to train</span></span>
<span id="cb80-15"><a href="#cb80-15" aria-hidden="true" tabindex="-1"></a>    train_merged[<span class="st">'year_built_final'</span>] <span class="op">=</span> train_merged.<span class="bu">apply</span>(</span>
<span id="cb80-16"><a href="#cb80-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: neigh_medians[row[<span class="st">'neighborhood'</span>]] <span class="cf">if</span> pd.isna(row[<span class="st">'year_built_final'</span>]) <span class="cf">else</span> row[<span class="st">'year_built_final'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb80-17"><a href="#cb80-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-18"><a href="#cb80-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Apply to test</span></span>
<span id="cb80-19"><a href="#cb80-19" aria-hidden="true" tabindex="-1"></a>    test_merged[<span class="st">'year_built_final'</span>] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb80-20"><a href="#cb80-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: neigh_medians.get(row[<span class="st">'neighborhood'</span>], np.nan) <span class="cf">if</span> pd.isna(row[<span class="st">'year_built_final'</span>]) <span class="cf">else</span> row[<span class="st">'year_built_final'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb80-21"><a href="#cb80-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-22"><a href="#cb80-22" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'region'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb80-23"><a href="#cb80-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Region-based fallback median from train</span></span>
<span id="cb80-24"><a href="#cb80-24" aria-hidden="true" tabindex="-1"></a>    region_medians <span class="op">=</span> train_merged.groupby(<span class="st">'region'</span>)[<span class="st">'year_built_final'</span>].median()</span>
<span id="cb80-25"><a href="#cb80-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-26"><a href="#cb80-26" aria-hidden="true" tabindex="-1"></a>    train_merged[<span class="st">'year_built_final'</span>] <span class="op">=</span> train_merged.<span class="bu">apply</span>(</span>
<span id="cb80-27"><a href="#cb80-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: region_medians[row[<span class="st">'region'</span>]] <span class="cf">if</span> pd.isna(row[<span class="st">'year_built_final'</span>]) <span class="cf">else</span> row[<span class="st">'year_built_final'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb80-28"><a href="#cb80-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-29"><a href="#cb80-29" aria-hidden="true" tabindex="-1"></a>    test_merged[<span class="st">'year_built_final'</span>] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb80-30"><a href="#cb80-30" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: region_medians.get(row[<span class="st">'region'</span>], np.nan) <span class="cf">if</span> pd.isna(row[<span class="st">'year_built_final'</span>]) <span class="cf">else</span> row[<span class="st">'year_built_final'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb80-31"><a href="#cb80-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-32"><a href="#cb80-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Imputed 'year_built_final' using neighborhood ‚Üí region medians from training set"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="381f00e0" class="cell" data-execution_count="81">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="co"># List of all assessed columns to impute</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>assessed_cols <span class="op">=</span> [<span class="st">'assessed_2015'</span>, <span class="st">'assessed_2016'</span>, <span class="st">'assessed_2017'</span>, <span class="st">'assessed_2018'</span>]</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> assessed_cols:</span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">not</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: Compute medians from training data only</span></span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a>    neigh_medians <span class="op">=</span> train_merged.groupby(<span class="st">'neighborhood'</span>)[col].median()</span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a>    region_medians <span class="op">=</span> train_merged.groupby(<span class="st">'region'</span>)[col].median()</span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true" tabindex="-1"></a>    global_median <span class="op">=</span> train_merged[col].median()</span>
<span id="cb81-12"><a href="#cb81-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-13"><a href="#cb81-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 2: Train set imputation</span></span>
<span id="cb81-14"><a href="#cb81-14" aria-hidden="true" tabindex="-1"></a>    train_merged[col] <span class="op">=</span> train_merged.<span class="bu">apply</span>(</span>
<span id="cb81-15"><a href="#cb81-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: neigh_medians[row[<span class="st">'neighborhood'</span>]]</span>
<span id="cb81-16"><a href="#cb81-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pd.isna(row[col]) <span class="kw">and</span> row[<span class="st">'neighborhood'</span>] <span class="kw">in</span> neigh_medians <span class="cf">else</span></span>
<span id="cb81-17"><a href="#cb81-17" aria-hidden="true" tabindex="-1"></a>        region_medians[row[<span class="st">'region'</span>]]</span>
<span id="cb81-18"><a href="#cb81-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pd.isna(row[col]) <span class="kw">and</span> row[<span class="st">'region'</span>] <span class="kw">in</span> region_medians <span class="cf">else</span></span>
<span id="cb81-19"><a href="#cb81-19" aria-hidden="true" tabindex="-1"></a>        global_median</span>
<span id="cb81-20"><a href="#cb81-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span></span>
<span id="cb81-21"><a href="#cb81-21" aria-hidden="true" tabindex="-1"></a>        row[col],</span>
<span id="cb81-22"><a href="#cb81-22" aria-hidden="true" tabindex="-1"></a>        axis<span class="op">=</span><span class="dv">1</span></span>
<span id="cb81-23"><a href="#cb81-23" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb81-24"><a href="#cb81-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-25"><a href="#cb81-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 3: Test set imputation (using train medians only)</span></span>
<span id="cb81-26"><a href="#cb81-26" aria-hidden="true" tabindex="-1"></a>    test_merged[col] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb81-27"><a href="#cb81-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: neigh_medians.get(row[<span class="st">'neighborhood'</span>], np.nan)</span>
<span id="cb81-28"><a href="#cb81-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col],</span>
<span id="cb81-29"><a href="#cb81-29" aria-hidden="true" tabindex="-1"></a>        axis<span class="op">=</span><span class="dv">1</span></span>
<span id="cb81-30"><a href="#cb81-30" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb81-31"><a href="#cb81-31" aria-hidden="true" tabindex="-1"></a>    test_merged[col] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb81-32"><a href="#cb81-32" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: region_medians.get(row[<span class="st">'region'</span>], np.nan)</span>
<span id="cb81-33"><a href="#cb81-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col],</span>
<span id="cb81-34"><a href="#cb81-34" aria-hidden="true" tabindex="-1"></a>        axis<span class="op">=</span><span class="dv">1</span></span>
<span id="cb81-35"><a href="#cb81-35" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb81-36"><a href="#cb81-36" aria-hidden="true" tabindex="-1"></a>    test_merged[col].fillna(global_median, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb81-37"><a href="#cb81-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-38"><a href="#cb81-38" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Imputed '</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">' using neighborhood ‚Üí region ‚Üí global medians (from training data)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="31c83105" class="cell" data-execution_count="82">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 1: Compute neighborhood-level stats ===</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>neigh_stats <span class="op">=</span> train_merged.groupby(<span class="st">'neighborhood'</span>)[<span class="st">'assessed_2018'</span>].agg([</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'neigh_assess_mean'</span>, <span class="st">'mean'</span>),</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'neigh_assess_median'</span>, <span class="st">'median'</span>),</span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'neigh_assess_std'</span>, <span class="st">'std'</span>),</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'neigh_assess_q1'</span>, <span class="kw">lambda</span> x: x.quantile(<span class="fl">0.25</span>)),</span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'neigh_assess_q3'</span>, <span class="kw">lambda</span> x: x.quantile(<span class="fl">0.75</span>)),</span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a>]).reset_index()</span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a>neigh_stats[<span class="st">'neigh_assess_iqr'</span>] <span class="op">=</span> neigh_stats[<span class="st">'neigh_assess_q3'</span>] <span class="op">-</span> neigh_stats[<span class="st">'neigh_assess_q1'</span>]</span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 2: Compute region-level stats ===</span></span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true" tabindex="-1"></a>region_stats <span class="op">=</span> train_merged.groupby(<span class="st">'region'</span>)[<span class="st">'assessed_2018'</span>].agg([</span>
<span id="cb82-13"><a href="#cb82-13" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'region_assess_mean'</span>, <span class="st">'mean'</span>),</span>
<span id="cb82-14"><a href="#cb82-14" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'region_assess_median'</span>, <span class="st">'median'</span>),</span>
<span id="cb82-15"><a href="#cb82-15" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'region_assess_std'</span>, <span class="st">'std'</span>),</span>
<span id="cb82-16"><a href="#cb82-16" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'region_assess_q1'</span>, <span class="kw">lambda</span> x: x.quantile(<span class="fl">0.25</span>)),</span>
<span id="cb82-17"><a href="#cb82-17" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'region_assess_q3'</span>, <span class="kw">lambda</span> x: x.quantile(<span class="fl">0.75</span>)),</span>
<span id="cb82-18"><a href="#cb82-18" aria-hidden="true" tabindex="-1"></a>]).reset_index()</span>
<span id="cb82-19"><a href="#cb82-19" aria-hidden="true" tabindex="-1"></a>region_stats[<span class="st">'region_assess_iqr'</span>] <span class="op">=</span> region_stats[<span class="st">'region_assess_q3'</span>] <span class="op">-</span> region_stats[<span class="st">'region_assess_q1'</span>]</span>
<span id="cb82-20"><a href="#cb82-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-21"><a href="#cb82-21" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 3: Fallback std maps from training data ===</span></span>
<span id="cb82-22"><a href="#cb82-22" aria-hidden="true" tabindex="-1"></a><span class="co"># For neighborhood fallback, group region medians of neighborhood std</span></span>
<span id="cb82-23"><a href="#cb82-23" aria-hidden="true" tabindex="-1"></a>neigh_std_by_region <span class="op">=</span> neigh_stats.merge(train_merged[[<span class="st">'neighborhood'</span>, <span class="st">'region'</span>]], on<span class="op">=</span><span class="st">'neighborhood'</span>, how<span class="op">=</span><span class="st">'left'</span>) <span class="op">\</span></span>
<span id="cb82-24"><a href="#cb82-24" aria-hidden="true" tabindex="-1"></a>                                  .groupby(<span class="st">'region'</span>)[<span class="st">'neigh_assess_std'</span>].median()</span>
<span id="cb82-25"><a href="#cb82-25" aria-hidden="true" tabindex="-1"></a>global_neigh_std <span class="op">=</span> neigh_stats[<span class="st">'neigh_assess_std'</span>].median()</span>
<span id="cb82-26"><a href="#cb82-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-27"><a href="#cb82-27" aria-hidden="true" tabindex="-1"></a>region_std_by_neigh <span class="op">=</span> region_stats.merge(train_merged[[<span class="st">'neighborhood'</span>, <span class="st">'region'</span>]], on<span class="op">=</span><span class="st">'region'</span>, how<span class="op">=</span><span class="st">'left'</span>) <span class="op">\</span></span>
<span id="cb82-28"><a href="#cb82-28" aria-hidden="true" tabindex="-1"></a>                                   .groupby(<span class="st">'neighborhood'</span>)[<span class="st">'region_assess_std'</span>].median()</span>
<span id="cb82-29"><a href="#cb82-29" aria-hidden="true" tabindex="-1"></a>global_region_std <span class="op">=</span> region_stats[<span class="st">'region_assess_std'</span>].median()</span>
<span id="cb82-30"><a href="#cb82-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-31"><a href="#cb82-31" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 4: Merge into train/test and compute features ===</span></span>
<span id="cb82-32"><a href="#cb82-32" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb82-33"><a href="#cb82-33" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.merge(neigh_stats, on<span class="op">=</span><span class="st">'neighborhood'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb82-34"><a href="#cb82-34" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.merge(region_stats, on<span class="op">=</span><span class="st">'region'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb82-35"><a href="#cb82-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-36"><a href="#cb82-36" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill missing std values via fallback</span></span>
<span id="cb82-37"><a href="#cb82-37" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'neigh_assess_std'</span>] <span class="op">=</span> df[<span class="st">'neigh_assess_std'</span>].fillna(</span>
<span id="cb82-38"><a href="#cb82-38" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'region'</span>].<span class="bu">map</span>(neigh_std_by_region)</span>
<span id="cb82-39"><a href="#cb82-39" aria-hidden="true" tabindex="-1"></a>    ).fillna(global_neigh_std)</span>
<span id="cb82-40"><a href="#cb82-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-41"><a href="#cb82-41" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'region_assess_std'</span>] <span class="op">=</span> df[<span class="st">'region_assess_std'</span>].fillna(</span>
<span id="cb82-42"><a href="#cb82-42" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'neighborhood'</span>].<span class="bu">map</span>(region_std_by_neigh)</span>
<span id="cb82-43"><a href="#cb82-43" aria-hidden="true" tabindex="-1"></a>    ).fillna(global_region_std)</span>
<span id="cb82-44"><a href="#cb82-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-45"><a href="#cb82-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute derived features</span></span>
<span id="cb82-46"><a href="#cb82-46" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'assess_minus_neigh_mean'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">-</span> df[<span class="st">'neigh_assess_mean'</span>]</span>
<span id="cb82-47"><a href="#cb82-47" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'assess_ratio_neigh_mean'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">/</span> (df[<span class="st">'neigh_assess_mean'</span>] <span class="op">+</span> <span class="fl">1e-6</span>)</span>
<span id="cb82-48"><a href="#cb82-48" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'z_score_assess_neigh'</span>] <span class="op">=</span> df[<span class="st">'assess_minus_neigh_mean'</span>] <span class="op">/</span> (df[<span class="st">'neigh_assess_std'</span>] <span class="op">+</span> <span class="fl">1e-6</span>)</span>
<span id="cb82-49"><a href="#cb82-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-50"><a href="#cb82-50" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'assess_minus_region_mean'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">-</span> df[<span class="st">'region_assess_mean'</span>]</span>
<span id="cb82-51"><a href="#cb82-51" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'assess_ratio_region_mean'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">/</span> (df[<span class="st">'region_assess_mean'</span>] <span class="op">+</span> <span class="fl">1e-6</span>)</span>
<span id="cb82-52"><a href="#cb82-52" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'z_score_assess_region'</span>] <span class="op">=</span> df[<span class="st">'assess_minus_region_mean'</span>] <span class="op">/</span> (df[<span class="st">'region_assess_std'</span>] <span class="op">+</span> <span class="fl">1e-6</span>)</span>
<span id="cb82-53"><a href="#cb82-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-54"><a href="#cb82-54" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Save back</span></span>
<span id="cb82-55"><a href="#cb82-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> df_name <span class="op">==</span> <span class="st">'train_merged'</span>:</span>
<span id="cb82-56"><a href="#cb82-56" aria-hidden="true" tabindex="-1"></a>        train_merged <span class="op">=</span> df</span>
<span id="cb82-57"><a href="#cb82-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb82-58"><a href="#cb82-58" aria-hidden="true" tabindex="-1"></a>        test_merged <span class="op">=</span> df</span>
<span id="cb82-59"><a href="#cb82-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-60"><a href="#cb82-60" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Completed: Stats merge + std fallback + z-score computation."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="5ef02bbc" class="cell" data-execution_count="83">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> [<span class="st">'neighborhood'</span>, <span class="st">'region'</span>,<span class="st">'zone'</span>,<span class="st">'subneighborhood'</span>]</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>    drop_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> cols_to_drop <span class="cf">if</span> col <span class="kw">in</span> df.columns]</span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> drop_cols:</span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a>        df.drop(columns<span class="op">=</span>drop_cols, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Dropped columns from </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>drop_cols<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="d21a7dbd" class="cell" data-execution_count="84">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb84"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>growth_pairs <span class="op">=</span> {</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_value_growth'</span>: (<span class="st">'building_value_2018'</span>, <span class="st">'building_value_2015'</span>),</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">'land_value_growth'</span>:     (<span class="st">'land_value_2018'</span>, <span class="st">'land_value_2015'</span>),</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">'assessed_growth'</span>:       (<span class="st">'assessed_2018'</span>, <span class="st">'assessed_2015'</span>)</span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> new_col, (final_col, base_col) <span class="kw">in</span> growth_pairs.items():</span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> final_col <span class="kw">in</span> df.columns <span class="kw">and</span> base_col <span class="kw">in</span> df.columns:</span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a>            df[new_col] <span class="op">=</span> df[final_col] <span class="op">-</span> df[base_col]</span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Created </span><span class="sc">{</span>new_col<span class="sc">}</span><span class="ss"> in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb84-12"><a href="#cb84-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb84-13"><a href="#cb84-13" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipped </span><span class="sc">{</span>new_col<span class="sc">}</span><span class="ss"> in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">: missing </span><span class="sc">{</span>final_col<span class="sc">}</span><span class="ss"> or </span><span class="sc">{</span>base_col<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb84-14"><a href="#cb84-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-15"><a href="#cb84-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Building Age ===</span></span>
<span id="cb84-16"><a href="#cb84-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb84-17"><a href="#cb84-17" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'year_built_final'</span>] <span class="op">=</span> pd.to_numeric(df[<span class="st">'year_built_final'</span>], errors<span class="op">=</span><span class="st">'coerce'</span>)  <span class="co"># handle 'Vacant', etc.</span></span>
<span id="cb84-18"><a href="#cb84-18" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'building_age'</span>] <span class="op">=</span> <span class="dv">2018</span> <span class="op">-</span> df[<span class="st">'year_built_final'</span>]</span>
<span id="cb84-19"><a href="#cb84-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Created building_age in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb84-20"><a href="#cb84-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb84-21"><a href="#cb84-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Skipped building_age in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">: missing year_built_final"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="c1d5a594" class="cell" data-execution_count="85">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb85"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'school_dist'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>    missing_pct <span class="op">=</span> train_merged[<span class="st">'school_dist'</span>].isna().mean() <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>    missing_count <span class="op">=</span> train_merged[<span class="st">'school_dist'</span>].isna().<span class="bu">sum</span>()</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" 'school_dist' has </span><span class="sc">{</span>missing_count<span class="sc">}</span><span class="ss"> missing values (</span><span class="sc">{</span>missing_pct<span class="sc">:.2f}</span><span class="ss">%) in training set"</span>)</span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">" 'school_dist' not found in training set"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="38c677ae" class="cell" data-execution_count="86">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'school_dist'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>    school_dist_median <span class="op">=</span> train_merged[<span class="st">'school_dist'</span>].median()</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="st">'school_dist'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>            df[<span class="st">'school_dist'</span>] <span class="op">=</span> df[<span class="st">'school_dist'</span>].fillna(school_dist_median)</span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Filled missing 'school_dist' in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss"> using train median (</span><span class="sc">{</span>school_dist_median<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">" 'school_dist' not found in train_merged"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="bafa3a48" class="cell" data-execution_count="87">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb87"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>    missing_pct <span class="op">=</span> train_merged[<span class="st">'year_built_final'</span>].isna().mean() <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>    missing_count <span class="op">=</span> train_merged[<span class="st">'year_built_final'</span>].isna().<span class="bu">sum</span>()</span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" 'year_built_final' has </span><span class="sc">{</span>missing_count<span class="sc">}</span><span class="ss"> missing values (</span><span class="sc">{</span>missing_pct<span class="sc">:.2f}</span><span class="ss">%) in training set"</span>)</span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">" 'year_built_final' not found in training set"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="37b4fe39" class="cell" data-execution_count="88">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb88"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 0: Define base feature names ===</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>numeric_bases <span class="op">=</span> [</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">'garage_area'</span>, <span class="st">'porch_area'</span>, <span class="st">'floors'</span>, <span class="st">'half_bath'</span>, <span class="st">'full_bath'</span>,</span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">'total_rooms'</span>, <span class="st">'bedrooms'</span>, <span class="st">'fireplaces'</span>, <span class="st">'building_area'</span>, <span class="st">'building_value'</span></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>categorical_fill_map <span class="op">=</span> {</span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality'</span>: <span class="st">'None'</span>,</span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality_description'</span>: <span class="st">'None'</span>,</span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_condition'</span>: <span class="st">'None'</span>,</span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a>    <span class="st">'foundation_type'</span>: <span class="st">'None'</span>,</span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a>    <span class="st">'grade'</span>: <span class="st">'None'</span>,</span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">'has_cooling'</span>: <span class="va">False</span>,</span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">'has_heat'</span>: <span class="va">False</span>,</span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true" tabindex="-1"></a>    <span class="st">'physical_condition'</span>: <span class="st">'None'</span>,</span>
<span id="cb88-16"><a href="#cb88-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">'exterior_walls'</span>: <span class="st">'None'</span>,</span>
<span id="cb88-17"><a href="#cb88-17" aria-hidden="true" tabindex="-1"></a>    <span class="st">'protested'</span>: <span class="va">False</span></span>
<span id="cb88-18"><a href="#cb88-18" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb88-19"><a href="#cb88-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-20"><a href="#cb88-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate full list of columns (2015‚Äì2019 only, no final columns)</span></span>
<span id="cb88-21"><a href="#cb88-21" aria-hidden="true" tabindex="-1"></a>numeric_cols_to_zero <span class="op">=</span> [</span>
<span id="cb88-22"><a href="#cb88-22" aria-hidden="true" tabindex="-1"></a>    <span class="ss">f'</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> base <span class="kw">in</span> numeric_bases <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)</span>
<span id="cb88-23"><a href="#cb88-23" aria-hidden="true" tabindex="-1"></a>] <span class="op">+</span> [<span class="st">'building_value_growth'</span>]</span>
<span id="cb88-24"><a href="#cb88-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-25"><a href="#cb88-25" aria-hidden="true" tabindex="-1"></a>categorical_cols_to_fill <span class="op">=</span> {</span>
<span id="cb88-26"><a href="#cb88-26" aria-hidden="true" tabindex="-1"></a>    <span class="ss">f'</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">'</span>: val</span>
<span id="cb88-27"><a href="#cb88-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> base, val <span class="kw">in</span> categorical_fill_map.items()</span>
<span id="cb88-28"><a href="#cb88-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)</span>
<span id="cb88-29"><a href="#cb88-29" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb88-30"><a href="#cb88-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-31"><a href="#cb88-31" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 1: Apply imputation if floor_area_total_2019 == 0 ===</span></span>
<span id="cb88-32"><a href="#cb88-32" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb88-33"><a href="#cb88-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'floor_area_total_2019'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb88-34"><a href="#cb88-34" aria-hidden="true" tabindex="-1"></a>        zero_floor_mask <span class="op">=</span> df[<span class="st">'floor_area_total_2019'</span>] <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb88-35"><a href="#cb88-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-36"><a href="#cb88-36" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Fill numeric columns with 0</span></span>
<span id="cb88-37"><a href="#cb88-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> col <span class="kw">in</span> numeric_cols_to_zero:</span>
<span id="cb88-38"><a href="#cb88-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb88-39"><a href="#cb88-39" aria-hidden="true" tabindex="-1"></a>                df.loc[zero_floor_mask, col] <span class="op">=</span> df.loc[zero_floor_mask, col].fillna(<span class="dv">0</span>)</span>
<span id="cb88-40"><a href="#cb88-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-41"><a href="#cb88-41" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Fill categorical/boolean columns</span></span>
<span id="cb88-42"><a href="#cb88-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> col, fill_val <span class="kw">in</span> categorical_cols_to_fill.items():</span>
<span id="cb88-43"><a href="#cb88-43" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb88-44"><a href="#cb88-44" aria-hidden="true" tabindex="-1"></a>                df.loc[zero_floor_mask, col] <span class="op">=</span> df.loc[zero_floor_mask, col].fillna(fill_val)</span>
<span id="cb88-45"><a href="#cb88-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-46"><a href="#cb88-46" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Filled structure-dependent missing values in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss"> for </span><span class="sc">{</span>zero_floor_mask<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ss"> rows"</span>)</span>
<span id="cb88-47"><a href="#cb88-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb88-48"><a href="#cb88-48" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" 'floor_area_total_2019' not found in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="fd6ffb88" class="cell" data-execution_count="89">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb89"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> OrdinalEncoder</span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> KFold</span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Clear specific variables</span></span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> var <span class="kw">in</span> [<span class="st">'ordinal_cols_all'</span>, <span class="st">'bool_cols_all'</span>]:</span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> var <span class="kw">in</span> <span class="bu">locals</span>():</span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">del</span> <span class="bu">globals</span>()[var]</span>
<span id="cb89-10"><a href="#cb89-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-11"><a href="#cb89-11" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 1: Boolean Encoding (2015‚Äì2019 only) ===</span></span>
<span id="cb89-12"><a href="#cb89-12" aria-hidden="true" tabindex="-1"></a>bool_bases <span class="op">=</span> [<span class="st">'has_cooling'</span>, <span class="st">'has_heat'</span>, <span class="st">'protested'</span>]</span>
<span id="cb89-13"><a href="#cb89-13" aria-hidden="true" tabindex="-1"></a>bool_cols_all <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> base <span class="kw">in</span> bool_bases <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)]</span>
<span id="cb89-14"><a href="#cb89-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-15"><a href="#cb89-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> bool_cols_all:</span>
<span id="cb89-16"><a href="#cb89-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb89-17"><a href="#cb89-17" aria-hidden="true" tabindex="-1"></a>        mode_val <span class="op">=</span> train_merged[col].mode(dropna<span class="op">=</span><span class="va">True</span>)[<span class="dv">0</span>]</span>
<span id="cb89-18"><a href="#cb89-18" aria-hidden="true" tabindex="-1"></a>        train_merged[col] <span class="op">=</span> train_merged[col].fillna(mode_val).astype(<span class="bu">int</span>)</span>
<span id="cb89-19"><a href="#cb89-19" aria-hidden="true" tabindex="-1"></a>        test_merged[col] <span class="op">=</span> test_merged[col].fillna(mode_val).astype(<span class="bu">int</span>)</span>
<span id="cb89-20"><a href="#cb89-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-21"><a href="#cb89-21" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 2: Ordinal Cleaning and Encoding (2015‚Äì2019 only) ===</span></span>
<span id="cb89-22"><a href="#cb89-22" aria-hidden="true" tabindex="-1"></a>ordinal_bases <span class="op">=</span> [</span>
<span id="cb89-23"><a href="#cb89-23" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality'</span>, <span class="st">'quality_description'</span>, <span class="st">'grade'</span>,</span>
<span id="cb89-24"><a href="#cb89-24" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_condition'</span>, <span class="st">'physical_condition'</span></span>
<span id="cb89-25"><a href="#cb89-25" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb89-26"><a href="#cb89-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-27"><a href="#cb89-27" aria-hidden="true" tabindex="-1"></a>ordinal_cols_all <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> base <span class="kw">in</span> ordinal_bases <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)]</span>
<span id="cb89-28"><a href="#cb89-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-29"><a href="#cb89-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Column-specific replacements</span></span>
<span id="cb89-30"><a href="#cb89-30" aria-hidden="true" tabindex="-1"></a>replacement_maps <span class="op">=</span> {</span>
<span id="cb89-31"><a href="#cb89-31" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality'</span>: {<span class="st">'E'</span>: <span class="st">'D'</span>, <span class="st">'F'</span>: <span class="st">'D'</span>, <span class="st">'X'</span>: np.nan, <span class="st">'None'</span>: np.nan},</span>
<span id="cb89-32"><a href="#cb89-32" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality_description'</span>: {<span class="st">'Poor'</span>: <span class="st">'Very Low'</span>, <span class="st">'None'</span>: np.nan},</span>
<span id="cb89-33"><a href="#cb89-33" aria-hidden="true" tabindex="-1"></a>    <span class="st">'grade'</span>: {<span class="st">'X'</span>: <span class="st">'F'</span>, <span class="st">'X-'</span>: <span class="st">'F'</span>, <span class="st">'X+'</span>: <span class="st">'F'</span>, <span class="st">'E'</span>: <span class="st">'D'</span>, <span class="st">'E-'</span>: <span class="st">'D-'</span>, <span class="st">'E+'</span>: <span class="st">'D+'</span>, <span class="st">'None'</span>: np.nan},</span>
<span id="cb89-34"><a href="#cb89-34" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_condition'</span>: {<span class="st">'Very Poor'</span>: <span class="st">'Poor'</span>, <span class="st">'Unsound'</span>: <span class="st">'Poor'</span>, <span class="st">'None'</span>: np.nan},</span>
<span id="cb89-35"><a href="#cb89-35" aria-hidden="true" tabindex="-1"></a>    <span class="st">'physical_condition'</span>: {<span class="st">'Very Poor'</span>: <span class="st">'Poor'</span>, <span class="st">'Unsound'</span>: <span class="st">'Poor'</span>, <span class="st">'None'</span>: np.nan}</span>
<span id="cb89-36"><a href="#cb89-36" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb89-37"><a href="#cb89-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-38"><a href="#cb89-38" aria-hidden="true" tabindex="-1"></a><span class="co"># Ordinal category order</span></span>
<span id="cb89-39"><a href="#cb89-39" aria-hidden="true" tabindex="-1"></a>ord_categories <span class="op">=</span> {</span>
<span id="cb89-40"><a href="#cb89-40" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality'</span>: [<span class="st">'D'</span>, <span class="st">'C'</span>, <span class="st">'B'</span>, <span class="st">'A'</span>],</span>
<span id="cb89-41"><a href="#cb89-41" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality_description'</span>: [<span class="st">'Very Low'</span>, <span class="st">'Low'</span>, <span class="st">'Average'</span>, <span class="st">'Good'</span>, <span class="st">'Excellent'</span>, <span class="st">'Superior'</span>],</span>
<span id="cb89-42"><a href="#cb89-42" aria-hidden="true" tabindex="-1"></a>    <span class="st">'grade'</span>: [<span class="st">'F'</span>, <span class="st">'D-'</span>, <span class="st">'D'</span>, <span class="st">'D+'</span>, <span class="st">'C-'</span>, <span class="st">'C'</span>, <span class="st">'C+'</span>, <span class="st">'B-'</span>, <span class="st">'B'</span>, <span class="st">'B+'</span>, <span class="st">'A-'</span>, <span class="st">'A'</span>, <span class="st">'A+'</span>],</span>
<span id="cb89-43"><a href="#cb89-43" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_condition'</span>: [<span class="st">'Poor'</span>, <span class="st">'Fair'</span>, <span class="st">'Average'</span>, <span class="st">'Good'</span>, <span class="st">'Very Good'</span>, <span class="st">'Excellent'</span>],</span>
<span id="cb89-44"><a href="#cb89-44" aria-hidden="true" tabindex="-1"></a>    <span class="st">'physical_condition'</span>: [<span class="st">'Poor'</span>, <span class="st">'Fair'</span>, <span class="st">'Average'</span>, <span class="st">'Good'</span>, <span class="st">'Very Good'</span>, <span class="st">'Excellent'</span>]</span>
<span id="cb89-45"><a href="#cb89-45" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb89-46"><a href="#cb89-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-47"><a href="#cb89-47" aria-hidden="true" tabindex="-1"></a><span class="co"># Clean and encode</span></span>
<span id="cb89-48"><a href="#cb89-48" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> base <span class="kw">in</span> ordinal_bases:</span>
<span id="cb89-49"><a href="#cb89-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>):</span>
<span id="cb89-50"><a href="#cb89-50" aria-hidden="true" tabindex="-1"></a>        col <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb89-51"><a href="#cb89-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb89-52"><a href="#cb89-52" aria-hidden="true" tabindex="-1"></a>            replacements <span class="op">=</span> replacement_maps.get(base, {})</span>
<span id="cb89-53"><a href="#cb89-53" aria-hidden="true" tabindex="-1"></a>            train_merged[col] <span class="op">=</span> train_merged[col].replace(replacements)</span>
<span id="cb89-54"><a href="#cb89-54" aria-hidden="true" tabindex="-1"></a>            test_merged[col] <span class="op">=</span> test_merged[col].replace(replacements)</span>
<span id="cb89-55"><a href="#cb89-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-56"><a href="#cb89-56" aria-hidden="true" tabindex="-1"></a>            mode_val <span class="op">=</span> train_merged[col].mode(dropna<span class="op">=</span><span class="va">True</span>)[<span class="dv">0</span>]</span>
<span id="cb89-57"><a href="#cb89-57" aria-hidden="true" tabindex="-1"></a>            train_merged[col] <span class="op">=</span> train_merged[col].fillna(mode_val)</span>
<span id="cb89-58"><a href="#cb89-58" aria-hidden="true" tabindex="-1"></a>            test_merged[col] <span class="op">=</span> test_merged[col].fillna(mode_val)</span>
<span id="cb89-59"><a href="#cb89-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-60"><a href="#cb89-60" aria-hidden="true" tabindex="-1"></a>            encoder <span class="op">=</span> OrdinalEncoder(categories<span class="op">=</span>[ord_categories[base]], handle_unknown<span class="op">=</span><span class="st">'use_encoded_value'</span>, unknown_value<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb89-61"><a href="#cb89-61" aria-hidden="true" tabindex="-1"></a>            train_merged[[col]] <span class="op">=</span> encoder.fit_transform(train_merged[[col]])</span>
<span id="cb89-62"><a href="#cb89-62" aria-hidden="true" tabindex="-1"></a>            test_merged[[col]] <span class="op">=</span> encoder.transform(test_merged[[col]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="ef8e83ed" class="cell" data-execution_count="90">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb90"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 3: Target Encoding (2015‚Äì2019 only) ===</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> group_and_target_encode_cv(train_df, test_df, target_name, column, rare_threshold<span class="op">=</span><span class="fl">0.001</span>, smoothing<span class="op">=</span><span class="dv">10</span>, n_splits<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>    freq <span class="op">=</span> train_df[column].value_counts(normalize<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>    rare_cats <span class="op">=</span> freq[freq <span class="op">&lt;</span> rare_threshold].index</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>    train_df[column] <span class="op">=</span> train_df[column].replace(rare_cats, <span class="st">'Other'</span>)</span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a>    test_df[column] <span class="op">=</span> test_df[column].replace(rare_cats, <span class="st">'Other'</span>)</span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a>    global_mean <span class="op">=</span> train_df[target_name].mean()</span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true" tabindex="-1"></a>    oof_encoded <span class="op">=</span> pd.Series(index<span class="op">=</span>train_df.index, dtype<span class="op">=</span><span class="st">'float64'</span>)</span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-11"><a href="#cb90-11" aria-hidden="true" tabindex="-1"></a>    kf <span class="op">=</span> KFold(n_splits<span class="op">=</span>n_splits, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb90-12"><a href="#cb90-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> train_idx, val_idx <span class="kw">in</span> kf.split(train_df):</span>
<span id="cb90-13"><a href="#cb90-13" aria-hidden="true" tabindex="-1"></a>        X_tr, X_val <span class="op">=</span> train_df.iloc[train_idx], train_df.iloc[val_idx]</span>
<span id="cb90-14"><a href="#cb90-14" aria-hidden="true" tabindex="-1"></a>        stats <span class="op">=</span> X_tr.groupby(column)[target_name].agg([<span class="st">'mean'</span>, <span class="st">'count'</span>])</span>
<span id="cb90-15"><a href="#cb90-15" aria-hidden="true" tabindex="-1"></a>        smooth <span class="op">=</span> (stats[<span class="st">'mean'</span>] <span class="op">*</span> stats[<span class="st">'count'</span>] <span class="op">+</span> global_mean <span class="op">*</span> smoothing) <span class="op">/</span> (stats[<span class="st">'count'</span>] <span class="op">+</span> smoothing)</span>
<span id="cb90-16"><a href="#cb90-16" aria-hidden="true" tabindex="-1"></a>        oof_encoded.iloc[val_idx] <span class="op">=</span> X_val[column].<span class="bu">map</span>(smooth).fillna(global_mean)</span>
<span id="cb90-17"><a href="#cb90-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-18"><a href="#cb90-18" aria-hidden="true" tabindex="-1"></a>    final_stats <span class="op">=</span> train_df.groupby(column)[target_name].agg([<span class="st">'mean'</span>, <span class="st">'count'</span>])</span>
<span id="cb90-19"><a href="#cb90-19" aria-hidden="true" tabindex="-1"></a>    final_smooth <span class="op">=</span> (final_stats[<span class="st">'mean'</span>] <span class="op">*</span> final_stats[<span class="st">'count'</span>] <span class="op">+</span> global_mean <span class="op">*</span> smoothing) <span class="op">/</span> (final_stats[<span class="st">'count'</span>] <span class="op">+</span> smoothing)</span>
<span id="cb90-20"><a href="#cb90-20" aria-hidden="true" tabindex="-1"></a>    test_encoded <span class="op">=</span> test_df[column].<span class="bu">map</span>(final_smooth).fillna(global_mean)</span>
<span id="cb90-21"><a href="#cb90-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-22"><a href="#cb90-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> oof_encoded, test_encoded</span>
<span id="cb90-23"><a href="#cb90-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-24"><a href="#cb90-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Target-encodable nominal columns</span></span>
<span id="cb90-25"><a href="#cb90-25" aria-hidden="true" tabindex="-1"></a>target_encodable_bases <span class="op">=</span> [<span class="st">'foundation_type'</span>, <span class="st">'exterior_walls'</span>]</span>
<span id="cb90-26"><a href="#cb90-26" aria-hidden="true" tabindex="-1"></a>target_encodable_cols_all <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> base <span class="kw">in</span> target_encodable_bases <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)]</span>
<span id="cb90-27"><a href="#cb90-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-28"><a href="#cb90-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply target encoding</span></span>
<span id="cb90-29"><a href="#cb90-29" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> target_encodable_cols_all:</span>
<span id="cb90-30"><a href="#cb90-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb90-31"><a href="#cb90-31" aria-hidden="true" tabindex="-1"></a>        mode_val <span class="op">=</span> train_merged[col].mode(dropna<span class="op">=</span><span class="va">True</span>)[<span class="dv">0</span>]</span>
<span id="cb90-32"><a href="#cb90-32" aria-hidden="true" tabindex="-1"></a>        train_merged[col] <span class="op">=</span> train_merged[col].fillna(mode_val)</span>
<span id="cb90-33"><a href="#cb90-33" aria-hidden="true" tabindex="-1"></a>        test_merged[col] <span class="op">=</span> test_merged[col].fillna(mode_val)</span>
<span id="cb90-34"><a href="#cb90-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-35"><a href="#cb90-35" aria-hidden="true" tabindex="-1"></a>        train_merged[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_te'</span>], test_merged[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_te'</span>] <span class="op">=</span> group_and_target_encode_cv(</span>
<span id="cb90-36"><a href="#cb90-36" aria-hidden="true" tabindex="-1"></a>            train_merged, test_merged, target_name<span class="op">=</span><span class="st">'assessed_2018'</span>, column<span class="op">=</span>col,</span>
<span id="cb90-37"><a href="#cb90-37" aria-hidden="true" tabindex="-1"></a>            rare_threshold<span class="op">=</span><span class="fl">0.001</span>, smoothing<span class="op">=</span><span class="dv">10</span>, n_splits<span class="op">=</span><span class="dv">5</span></span>
<span id="cb90-38"><a href="#cb90-38" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb90-39"><a href="#cb90-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-40"><a href="#cb90-40" aria-hidden="true" tabindex="-1"></a>        train_merged.drop(columns<span class="op">=</span>[col], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb90-41"><a href="#cb90-41" aria-hidden="true" tabindex="-1"></a>        test_merged.drop(columns<span class="op">=</span>[col], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb90-42"><a href="#cb90-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-43"><a href="#cb90-43" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Done: Boolean, Ordinal, and Target Encoding for 2015‚Äì2019 features only."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="9047d7de" class="cell" data-execution_count="91">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb91"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1: Get growth columns from training set</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>growth_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> <span class="st">'_growth'</span> <span class="kw">in</span> col]</span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 2: Compute medians from train_merged only</span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>growth_medians <span class="op">=</span> {col: train_merged[col].median() <span class="cf">for</span> col <span class="kw">in</span> growth_cols}</span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 3: Apply to both train and test</span></span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> col <span class="kw">in</span> growth_cols:</span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a>            df[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_missing'</span>] <span class="op">=</span> df[col].isna().astype(<span class="bu">int</span>)</span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a>            df[col].fillna(growth_medians[col], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Filled and flagged missing values in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss"> for: </span><span class="sc">{</span>growth_cols<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="6a414721" class="cell" data-execution_count="92">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb92"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 1: List your growth features ===</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>growth_features <span class="op">=</span> [<span class="st">'land_value_growth'</span>, <span class="st">'building_value_growth'</span>, <span class="st">'assessed_growth'</span>]</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 2: Binning Function (train-based binning) ===</span></span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bin_growth_feature_safe(train_df, test_df, feature, bins<span class="op">=</span><span class="dv">4</span>):</span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Quantile binning on train only</span></span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true" tabindex="-1"></a>        train_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>], bin_edges <span class="op">=</span> pd.qcut(train_df[feature], q<span class="op">=</span>bins, labels<span class="op">=</span><span class="va">False</span>, retbins<span class="op">=</span><span class="va">True</span>, duplicates<span class="op">=</span><span class="st">'drop'</span>)</span>
<span id="cb92-9"><a href="#cb92-9" aria-hidden="true" tabindex="-1"></a>        test_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>] <span class="op">=</span> pd.cut(test_df[feature], bins<span class="op">=</span>bin_edges, labels<span class="op">=</span><span class="va">False</span>, include_lowest<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb92-10"><a href="#cb92-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">ValueError</span>:</span>
<span id="cb92-11"><a href="#cb92-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Fallback: Equal-width binning</span></span>
<span id="cb92-12"><a href="#cb92-12" aria-hidden="true" tabindex="-1"></a>        min_val <span class="op">=</span> train_df[feature].<span class="bu">min</span>()</span>
<span id="cb92-13"><a href="#cb92-13" aria-hidden="true" tabindex="-1"></a>        max_val <span class="op">=</span> train_df[feature].<span class="bu">max</span>()</span>
<span id="cb92-14"><a href="#cb92-14" aria-hidden="true" tabindex="-1"></a>        bin_edges <span class="op">=</span> np.linspace(min_val, max_val, bins <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb92-15"><a href="#cb92-15" aria-hidden="true" tabindex="-1"></a>        train_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>] <span class="op">=</span> pd.cut(train_df[feature], bins<span class="op">=</span>bin_edges, labels<span class="op">=</span><span class="va">False</span>, include_lowest<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb92-16"><a href="#cb92-16" aria-hidden="true" tabindex="-1"></a>        test_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>] <span class="op">=</span> pd.cut(test_df[feature], bins<span class="op">=</span>bin_edges, labels<span class="op">=</span><span class="va">False</span>, include_lowest<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb92-17"><a href="#cb92-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-18"><a href="#cb92-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert to category</span></span>
<span id="cb92-19"><a href="#cb92-19" aria-hidden="true" tabindex="-1"></a>    train_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>] <span class="op">=</span> train_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>].astype(<span class="st">'category'</span>)</span>
<span id="cb92-20"><a href="#cb92-20" aria-hidden="true" tabindex="-1"></a>    test_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>] <span class="op">=</span> test_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>].astype(<span class="st">'category'</span>)</span>
<span id="cb92-21"><a href="#cb92-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> train_df, test_df</span>
<span id="cb92-22"><a href="#cb92-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-23"><a href="#cb92-23" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 3: Apply to train_merged and test_merged ===</span></span>
<span id="cb92-24"><a href="#cb92-24" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> feature <span class="kw">in</span> growth_features:</span>
<span id="cb92-25"><a href="#cb92-25" aria-hidden="true" tabindex="-1"></a>    train_merged, test_merged <span class="op">=</span> bin_growth_feature_safe(train_merged, test_merged, feature)</span>
<span id="cb92-26"><a href="#cb92-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-27"><a href="#cb92-27" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 4: Bin year_built_final using train-based quantiles ===</span></span>
<span id="cb92-28"><a href="#cb92-28" aria-hidden="true" tabindex="-1"></a>train_merged[<span class="st">'year_built_bin'</span>], bin_edges <span class="op">=</span> pd.qcut(</span>
<span id="cb92-29"><a href="#cb92-29" aria-hidden="true" tabindex="-1"></a>    train_merged[<span class="st">'year_built_final'</span>], q<span class="op">=</span><span class="dv">5</span>, retbins<span class="op">=</span><span class="va">True</span>, labels<span class="op">=</span><span class="va">False</span>, duplicates<span class="op">=</span><span class="st">'drop'</span></span>
<span id="cb92-30"><a href="#cb92-30" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb92-31"><a href="#cb92-31" aria-hidden="true" tabindex="-1"></a>test_merged[<span class="st">'year_built_bin'</span>] <span class="op">=</span> pd.cut(</span>
<span id="cb92-32"><a href="#cb92-32" aria-hidden="true" tabindex="-1"></a>    test_merged[<span class="st">'year_built_final'</span>], bins<span class="op">=</span>bin_edges, labels<span class="op">=</span><span class="va">False</span>, include_lowest<span class="op">=</span><span class="va">True</span></span>
<span id="cb92-33"><a href="#cb92-33" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb92-34"><a href="#cb92-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-35"><a href="#cb92-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert to category</span></span>
<span id="cb92-36"><a href="#cb92-36" aria-hidden="true" tabindex="-1"></a>train_merged[<span class="st">'year_built_bin'</span>] <span class="op">=</span> train_merged[<span class="st">'year_built_bin'</span>].astype(<span class="st">'category'</span>)</span>
<span id="cb92-37"><a href="#cb92-37" aria-hidden="true" tabindex="-1"></a>test_merged[<span class="st">'year_built_bin'</span>] <span class="op">=</span> test_merged[<span class="st">'year_built_bin'</span>].astype(<span class="st">'category'</span>)</span>
<span id="cb92-38"><a href="#cb92-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-39"><a href="#cb92-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-40"><a href="#cb92-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Binned growth &amp; year_built features safely with no leakage."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="a987e766" class="cell" data-execution_count="93">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb93"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 5: Drop original continuous columns ===</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> growth_features <span class="op">+</span> [<span class="st">'year_built_final'</span>]</span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>train_merged<span class="op">=</span>train_merged.drop(columns<span class="op">=</span>cols_to_drop)</span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>test_merged<span class="op">=</span>test_merged.drop(columns<span class="op">=</span>cols_to_drop)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="1362634c" class="cell" data-execution_count="94">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb94"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a>rare_threshold <span class="op">=</span> <span class="fl">0.001</span>  <span class="co"># 0.1%</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>cat_cols <span class="op">=</span> [</span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"quality_description_final"</span>,</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">"foundation_type_final_te"</span>,</span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">"physical_condition_final"</span>,</span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">"exterior_walls_final_te"</span>,</span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">"region_freq"</span>,</span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">"neighborhood_freq"</span></span>
<span id="cb94-10"><a href="#cb94-10" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb94-11"><a href="#cb94-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-12"><a href="#cb94-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> cat_cols:</span>
<span id="cb94-13"><a href="#cb94-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb94-14"><a href="#cb94-14" aria-hidden="true" tabindex="-1"></a>        freq <span class="op">=</span> train_merged[col].value_counts(normalize<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb94-15"><a href="#cb94-15" aria-hidden="true" tabindex="-1"></a>        rare <span class="op">=</span> freq[freq <span class="op">&lt;</span> rare_threshold]</span>
<span id="cb94-16"><a href="#cb94-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> rare.empty:</span>
<span id="cb94-17"><a href="#cb94-17" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss"> Rare categories in '</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">' (less than 0.1% of training data):</span><span class="ch">\n</span><span class="sc">{</span>rare<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb94-18"><a href="#cb94-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb94-19"><a href="#cb94-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Column '</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">' not found in train_merged"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="95be9edd" class="cell" data-execution_count="95">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb95"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define frequency columns and threshold</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>freq_cols <span class="op">=</span> [<span class="st">'region_freq'</span>, <span class="st">'neighborhood_freq'</span>, <span class="st">'zone_freq'</span>, <span class="st">'subneighborhood_freq'</span>]</span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>rare_thresh <span class="op">=</span> <span class="fl">0.001</span></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply rare value replacement for each frequency column</span></span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> freq_cols:</span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb95-8"><a href="#cb95-8" aria-hidden="true" tabindex="-1"></a>        rare_vals <span class="op">=</span> train_merged[col].value_counts(normalize<span class="op">=</span><span class="va">True</span>)[<span class="kw">lambda</span> x: x <span class="op">&lt;</span> rare_thresh].index</span>
<span id="cb95-9"><a href="#cb95-9" aria-hidden="true" tabindex="-1"></a>        train_merged[col] <span class="op">=</span> train_merged[col].replace(rare_vals, <span class="dv">0</span>)</span>
<span id="cb95-10"><a href="#cb95-10" aria-hidden="true" tabindex="-1"></a>        test_merged[col] <span class="op">=</span> test_merged[col].replace(rare_vals, <span class="dv">0</span>)</span>
<span id="cb95-11"><a href="#cb95-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Replaced rare values in </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> using train_merged threshold &lt; </span><span class="sc">{</span>rare_thresh<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb95-12"><a href="#cb95-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb95-13"><a href="#cb95-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Column </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> not found in train_merged ‚Äî skipping."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="cead8dbf" class="cell" data-execution_count="96">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb96"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a><span class="co"># === Compute skewness for numeric columns ===</span></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>numeric_cols <span class="op">=</span> train_merged.select_dtypes(include<span class="op">=</span>[np.number])</span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a>skew_values <span class="op">=</span> numeric_cols.skew().sort_values(ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a><span class="co"># === Save skewness to CSV ===</span></span>
<span id="cb96-8"><a href="#cb96-8" aria-hidden="true" tabindex="-1"></a>skew_df <span class="op">=</span> skew_values.reset_index()</span>
<span id="cb96-9"><a href="#cb96-9" aria-hidden="true" tabindex="-1"></a>skew_df.columns <span class="op">=</span> [<span class="st">'feature'</span>, <span class="st">'skewness'</span>]</span>
<span id="cb96-10"><a href="#cb96-10" aria-hidden="true" tabindex="-1"></a>skew_df.to_csv(<span class="st">"feature_skewness.csv"</span>, index<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb96-11"><a href="#cb96-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-12"><a href="#cb96-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Saved skewness stats to 'feature_skewness.csv'"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="b78b7f99" class="cell" data-execution_count="97">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb97"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Load your skewness report</span></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>skew_df <span class="op">=</span> pd.read_csv(<span class="st">"feature_skewness.csv"</span>)  <span class="co"># Update path if needed</span></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 1: Categorize features by skew level ===</span></span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a>ultra_skewed <span class="op">=</span> []</span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a>moderately_skewed <span class="op">=</span> []</span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _, row <span class="kw">in</span> skew_df.iterrows():</span>
<span id="cb97-11"><a href="#cb97-11" aria-hidden="true" tabindex="-1"></a>    feature <span class="op">=</span> row[<span class="st">'feature'</span>]</span>
<span id="cb97-12"><a href="#cb97-12" aria-hidden="true" tabindex="-1"></a>    skew <span class="op">=</span> row[<span class="st">'skewness'</span>]</span>
<span id="cb97-13"><a href="#cb97-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb97-14"><a href="#cb97-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> feature <span class="kw">not</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb97-15"><a href="#cb97-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span></span>
<span id="cb97-16"><a href="#cb97-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-17"><a href="#cb97-17" aria-hidden="true" tabindex="-1"></a>    unique_vals <span class="op">=</span> train_merged[feature].nunique()</span>
<span id="cb97-18"><a href="#cb97-18" aria-hidden="true" tabindex="-1"></a>    is_binary <span class="op">=</span> <span class="bu">set</span>(train_merged[feature].dropna().unique()).issubset({<span class="dv">0</span>, <span class="dv">1</span>})</span>
<span id="cb97-19"><a href="#cb97-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-20"><a href="#cb97-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> unique_vals <span class="op">&gt;</span> <span class="dv">10</span> <span class="kw">and</span> <span class="kw">not</span> is_binary <span class="kw">and</span> <span class="kw">not</span> feature.endswith(<span class="st">'_te'</span>):</span>
<span id="cb97-21"><a href="#cb97-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> skew <span class="op">&gt;</span> <span class="dv">100</span>:</span>
<span id="cb97-22"><a href="#cb97-22" aria-hidden="true" tabindex="-1"></a>            ultra_skewed.append(feature)</span>
<span id="cb97-23"><a href="#cb97-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="dv">2</span><span class="op">&lt;</span> skew <span class="op">&lt;=</span> <span class="dv">100</span>:</span>
<span id="cb97-24"><a href="#cb97-24" aria-hidden="true" tabindex="-1"></a>            moderately_skewed.append(feature)</span>
<span id="cb97-25"><a href="#cb97-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-26"><a href="#cb97-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" </span><span class="sc">{</span><span class="bu">len</span>(ultra_skewed)<span class="sc">}</span><span class="ss"> ultra-skewed features to clip at 0.995."</span>)</span>
<span id="cb97-27"><a href="#cb97-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" </span><span class="sc">{</span><span class="bu">len</span>(moderately_skewed)<span class="sc">}</span><span class="ss"> moderately-skewed features to clip at 0.999."</span>)</span>
<span id="cb97-28"><a href="#cb97-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-29"><a href="#cb97-29" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 2: Compute quantile clipping bounds ===</span></span>
<span id="cb97-30"><a href="#cb97-30" aria-hidden="true" tabindex="-1"></a>clip_bounds <span class="op">=</span> {}</span>
<span id="cb97-31"><a href="#cb97-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-32"><a href="#cb97-32" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> ultra_skewed:</span>
<span id="cb97-33"><a href="#cb97-33" aria-hidden="true" tabindex="-1"></a>    clip_bounds[col] <span class="op">=</span> (</span>
<span id="cb97-34"><a href="#cb97-34" aria-hidden="true" tabindex="-1"></a>        train_merged[col].quantile(<span class="fl">0.005</span>),</span>
<span id="cb97-35"><a href="#cb97-35" aria-hidden="true" tabindex="-1"></a>        train_merged[col].quantile(<span class="fl">0.995</span>)</span>
<span id="cb97-36"><a href="#cb97-36" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb97-37"><a href="#cb97-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-38"><a href="#cb97-38" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> moderately_skewed:</span>
<span id="cb97-39"><a href="#cb97-39" aria-hidden="true" tabindex="-1"></a>    clip_bounds[col] <span class="op">=</span> (</span>
<span id="cb97-40"><a href="#cb97-40" aria-hidden="true" tabindex="-1"></a>        train_merged[col].quantile(<span class="fl">0.001</span>),</span>
<span id="cb97-41"><a href="#cb97-41" aria-hidden="true" tabindex="-1"></a>        train_merged[col].quantile(<span class="fl">0.999</span>)</span>
<span id="cb97-42"><a href="#cb97-42" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb97-43"><a href="#cb97-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-44"><a href="#cb97-44" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 3: Apply clipping to both train and test ===</span></span>
<span id="cb97-45"><a href="#cb97-45" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb97-46"><a href="#cb97-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> col, (lower, upper) <span class="kw">in</span> clip_bounds.items():</span>
<span id="cb97-47"><a href="#cb97-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb97-48"><a href="#cb97-48" aria-hidden="true" tabindex="-1"></a>            df[col] <span class="op">=</span> df[col].clip(lower, upper)</span>
<span id="cb97-49"><a href="#cb97-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-50"><a href="#cb97-50" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Adaptive clipping applied: 0.995 for ultra-skewed, 0.999 for moderately-skewed features."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="67ac91c6" class="cell" data-execution_count="98">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb98"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add_features(df):</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.copy()</span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Ratio features ===</span></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'area_ratio'</span>] <span class="op">=</span> df[<span class="st">'building_area_2019'</span>] <span class="op">/</span> (df[<span class="st">'land_area_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'porch_ratio'</span>] <span class="op">=</span> df[<span class="st">'porch_area_2019'</span>] <span class="op">/</span> (df[<span class="st">'building_area_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'floor_density'</span>] <span class="op">=</span> df[<span class="st">'floor_area_total_2019'</span>] <span class="op">/</span> (df[<span class="st">'land_area_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb98-8"><a href="#cb98-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb98-9"><a href="#cb98-9" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'value_ratio'</span>] <span class="op">=</span> df[<span class="st">'building_value_2018'</span>] <span class="op">/</span> (df[<span class="st">'land_value_2018'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb98-10"><a href="#cb98-10" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'value_per_sqft'</span>] <span class="op">=</span> df[<span class="st">'building_value_2018'</span>] <span class="op">/</span> (df[<span class="st">'building_area_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb98-11"><a href="#cb98-11" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'price_per_sqft'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">/</span> (df[<span class="st">'building_area_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb98-12"><a href="#cb98-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-13"><a href="#cb98-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Bathroom &amp; room structure ===</span></span>
<span id="cb98-14"><a href="#cb98-14" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'bathroom_score'</span>] <span class="op">=</span> df[<span class="st">'full_bath_2019'</span>] <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> df[<span class="st">'half_bath_2019'</span>]</span>
<span id="cb98-15"><a href="#cb98-15" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'bathroom_density'</span>] <span class="op">=</span> df[<span class="st">'bathroom_score'</span>] <span class="op">/</span> (df[<span class="st">'total_rooms_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb98-16"><a href="#cb98-16" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'bedroom_ratio'</span>] <span class="op">=</span> df[<span class="st">'bedrooms_2019'</span>] <span class="op">/</span> (df[<span class="st">'total_rooms_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb98-17"><a href="#cb98-17" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'rooms_per_floor'</span>] <span class="op">=</span> df[<span class="st">'total_rooms_2019'</span>] <span class="op">/</span> (df[<span class="st">'floors_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb98-18"><a href="#cb98-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-19"><a href="#cb98-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Core interactions ===</span></span>
<span id="cb98-20"><a href="#cb98-20" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'bedrooms_x_floors'</span>] <span class="op">=</span> df[<span class="st">'bedrooms_2019'</span>] <span class="op">*</span> df[<span class="st">'floors_2019'</span>]</span>
<span id="cb98-21"><a href="#cb98-21" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'rooms_x_quality'</span>] <span class="op">=</span> df[<span class="st">'total_rooms_2019'</span>] <span class="op">*</span> df[<span class="st">'quality_2019'</span>]</span>
<span id="cb98-22"><a href="#cb98-22" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'assess_x_age'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">*</span> df[<span class="st">'building_age'</span>]</span>
<span id="cb98-23"><a href="#cb98-23" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'grade_quality_index'</span>] <span class="op">=</span> df[<span class="st">'grade_2019'</span>] <span class="op">*</span> df[<span class="st">'quality_2019'</span>]</span>
<span id="cb98-24"><a href="#cb98-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-25"><a href="#cb98-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Selected high-signal interactions ===</span></span>
<span id="cb98-26"><a href="#cb98-26" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'area_x_quality'</span>] <span class="op">=</span> df[<span class="st">'building_area_2019'</span>] <span class="op">*</span> df[<span class="st">'quality_2019'</span>]</span>
<span id="cb98-27"><a href="#cb98-27" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'floor_area_x_grade'</span>] <span class="op">=</span> df[<span class="st">'floor_area_total_2019'</span>] <span class="op">*</span> df[<span class="st">'grade_2019'</span>]</span>
<span id="cb98-28"><a href="#cb98-28" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'value_to_neigh_median'</span>] <span class="op">=</span> df[<span class="st">'building_value_2018'</span>] <span class="op">/</span> (df[<span class="st">'neigh_assess_median'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb98-29"><a href="#cb98-29" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'assess_to_neigh_mean'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">/</span> (df[<span class="st">'neigh_assess_mean'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb98-30"><a href="#cb98-30" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'value_per_age'</span>] <span class="op">=</span> df[<span class="st">'building_value_2018'</span>] <span class="op">/</span> (df[<span class="st">'building_age'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb98-31"><a href="#cb98-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-32"><a href="#cb98-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Clean up ===</span></span>
<span id="cb98-33"><a href="#cb98-33" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.replace([np.inf, <span class="op">-</span>np.inf], np.nan)</span>
<span id="cb98-34"><a href="#cb98-34" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.fillna(<span class="dv">0</span>)</span>
<span id="cb98-35"><a href="#cb98-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb98-36"><a href="#cb98-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb98-37"><a href="#cb98-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-38"><a href="#cb98-38" aria-hidden="true" tabindex="-1"></a><span class="co"># === Apply to train and test sets ===</span></span>
<span id="cb98-39"><a href="#cb98-39" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> add_features(train_merged)</span>
<span id="cb98-40"><a href="#cb98-40" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> add_features(test_merged)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="a923d198" class="cell" data-execution_count="99">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb99"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Select numeric columns only</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>numeric_features <span class="op">=</span> train_merged.select_dtypes(include<span class="op">=</span>[<span class="st">'int64'</span>, <span class="st">'float64'</span>])</span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate skewness</span></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>skewness <span class="op">=</span> numeric_features.skew(numeric_only<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter and sort features with skewness &gt; 30</span></span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a>highly_skewed <span class="op">=</span> skewness[skewness <span class="op">&gt;</span> <span class="dv">5</span>].sort_values(ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb99-9"><a href="#cb99-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-10"><a href="#cb99-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"üìä Features with skewness &gt; 5:"</span>)</span>
<span id="cb99-11"><a href="#cb99-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(highly_skewed)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="95ede318" class="cell" data-execution_count="100">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb100"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 1: Drop dummy _missing columns ===</span></span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a>drop_cols <span class="op">=</span> [</span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_value_growth_missing'</span>,</span>
<span id="cb100-7"><a href="#cb100-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">'land_value_growth_missing'</span>,</span>
<span id="cb100-8"><a href="#cb100-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">'assessed_growth_missing'</span></span>
<span id="cb100-9"><a href="#cb100-9" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb100-10"><a href="#cb100-10" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> train_merged.drop(columns<span class="op">=</span>drop_cols, errors<span class="op">=</span><span class="st">'ignore'</span>)</span>
<span id="cb100-11"><a href="#cb100-11" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> test_merged.drop(columns<span class="op">=</span>drop_cols, errors<span class="op">=</span><span class="st">'ignore'</span>)</span>
<span id="cb100-12"><a href="#cb100-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"üóëÔ∏è Dropped dummy _missing columns from train and test."</span>)</span>
<span id="cb100-13"><a href="#cb100-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-14"><a href="#cb100-14" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 2: Compute skewness from train_merged only ===</span></span>
<span id="cb100-15"><a href="#cb100-15" aria-hidden="true" tabindex="-1"></a>numeric_cols <span class="op">=</span> train_merged.select_dtypes(include<span class="op">=</span>[np.number])</span>
<span id="cb100-16"><a href="#cb100-16" aria-hidden="true" tabindex="-1"></a>skew_series <span class="op">=</span> numeric_cols.skew()</span>
<span id="cb100-17"><a href="#cb100-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-18"><a href="#cb100-18" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 3: Categorize by skew level (excluding _te and _missing) ===</span></span>
<span id="cb100-19"><a href="#cb100-19" aria-hidden="true" tabindex="-1"></a>ultra_skewed <span class="op">=</span> []</span>
<span id="cb100-20"><a href="#cb100-20" aria-hidden="true" tabindex="-1"></a>moderately_skewed <span class="op">=</span> []</span>
<span id="cb100-21"><a href="#cb100-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-22"><a href="#cb100-22" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col, skew_val <span class="kw">in</span> skew_series.items():</span>
<span id="cb100-23"><a href="#cb100-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col.endswith(<span class="st">'_te'</span>) <span class="kw">or</span> col.endswith(<span class="st">'_missing'</span>):</span>
<span id="cb100-24"><a href="#cb100-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span></span>
<span id="cb100-25"><a href="#cb100-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> skew_val <span class="op">&gt;</span> <span class="dv">100</span>:</span>
<span id="cb100-26"><a href="#cb100-26" aria-hidden="true" tabindex="-1"></a>        ultra_skewed.append(col)</span>
<span id="cb100-27"><a href="#cb100-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> skew_val <span class="op">&gt;</span> <span class="dv">2</span>:</span>
<span id="cb100-28"><a href="#cb100-28" aria-hidden="true" tabindex="-1"></a>        moderately_skewed.append(col)</span>
<span id="cb100-29"><a href="#cb100-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-30"><a href="#cb100-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" </span><span class="sc">{</span><span class="bu">len</span>(ultra_skewed)<span class="sc">}</span><span class="ss"> ultra-skewed features (clip at 0.5%‚Äì99.5%)."</span>)</span>
<span id="cb100-31"><a href="#cb100-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" </span><span class="sc">{</span><span class="bu">len</span>(moderately_skewed)<span class="sc">}</span><span class="ss"> moderately-skewed features (clip at 0.1%‚Äì99.9%)."</span>)</span>
<span id="cb100-32"><a href="#cb100-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-33"><a href="#cb100-33" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 4: Compute clipping bounds ===</span></span>
<span id="cb100-34"><a href="#cb100-34" aria-hidden="true" tabindex="-1"></a>clip_bounds <span class="op">=</span> {}</span>
<span id="cb100-35"><a href="#cb100-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-36"><a href="#cb100-36" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> ultra_skewed:</span>
<span id="cb100-37"><a href="#cb100-37" aria-hidden="true" tabindex="-1"></a>    clip_bounds[col] <span class="op">=</span> (</span>
<span id="cb100-38"><a href="#cb100-38" aria-hidden="true" tabindex="-1"></a>        train_merged[col].quantile(<span class="fl">0.005</span>),</span>
<span id="cb100-39"><a href="#cb100-39" aria-hidden="true" tabindex="-1"></a>        train_merged[col].quantile(<span class="fl">0.995</span>)</span>
<span id="cb100-40"><a href="#cb100-40" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb100-41"><a href="#cb100-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-42"><a href="#cb100-42" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> moderately_skewed:</span>
<span id="cb100-43"><a href="#cb100-43" aria-hidden="true" tabindex="-1"></a>    clip_bounds[col] <span class="op">=</span> (</span>
<span id="cb100-44"><a href="#cb100-44" aria-hidden="true" tabindex="-1"></a>        train_merged[col].quantile(<span class="fl">0.001</span>),</span>
<span id="cb100-45"><a href="#cb100-45" aria-hidden="true" tabindex="-1"></a>        train_merged[col].quantile(<span class="fl">0.999</span>)</span>
<span id="cb100-46"><a href="#cb100-46" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb100-47"><a href="#cb100-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-48"><a href="#cb100-48" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 5: Apply clipping to both train and test sets ===</span></span>
<span id="cb100-49"><a href="#cb100-49" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df <span class="kw">in</span> [train_merged, test_merged]:</span>
<span id="cb100-50"><a href="#cb100-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> col, (lower, upper) <span class="kw">in</span> clip_bounds.items():</span>
<span id="cb100-51"><a href="#cb100-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb100-52"><a href="#cb100-52" aria-hidden="true" tabindex="-1"></a>            df[col] <span class="op">=</span> df[col].clip(lower, upper)</span>
<span id="cb100-53"><a href="#cb100-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-54"><a href="#cb100-54" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Adaptive clipping complete: 0.995 for ultra-skewed, 0.999 for moderately skewed."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="7e8df696" class="cell" data-execution_count="101">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb101"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define columns to drop</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>year_built_cols <span class="op">=</span> [<span class="ss">f'year_built_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)]</span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop if columns exist</span></span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>[col <span class="cf">for</span> col <span class="kw">in</span> year_built_cols <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>[col <span class="cf">for</span> col <span class="kw">in</span> year_built_cols <span class="cf">if</span> col <span class="kw">in</span> test_merged.columns], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-8"><a href="#cb101-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Dropped year_built_2015 to year_built_2019 from both train and test sets."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="885d2f41" class="cell" data-execution_count="102">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb102"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">"TARGET"</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>    train_merged.drop(<span class="st">"TARGET"</span>, axis<span class="op">=</span><span class="dv">1</span>,inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"TARGET not found in columns:"</span>, train_merged.columns.tolist())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="29edb82e" class="cell" data-execution_count="103">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb103"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop floor_area_total_final if it exists</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'floor_area_total_final'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a>        df.drop(columns<span class="op">=</span><span class="st">'floor_area_total_final'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Dropped 'floor_area_total_final' from </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"‚Ñπ 'floor_area_total_final' not found in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="af85b12e" class="cell" data-execution_count="104">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb104"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a>train_cols <span class="op">=</span> <span class="bu">set</span>(train_merged.columns)</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>test_cols <span class="op">=</span> <span class="bu">set</span>(test_merged.columns)</span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a>missing_in_test <span class="op">=</span> train_cols <span class="op">-</span> test_cols</span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a>missing_in_train <span class="op">=</span> test_cols <span class="op">-</span> train_cols</span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Columns in train but not in test:"</span>)</span>
<span id="cb104-8"><a href="#cb104-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">sorted</span>(missing_in_test))</span>
<span id="cb104-9"><a href="#cb104-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-10"><a href="#cb104-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> Columns in test but not in train:"</span>)</span>
<span id="cb104-11"><a href="#cb104-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">sorted</span>(missing_in_train))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="856ca0ae" class="cell" data-execution_count="105">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb105"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Check if column sets match</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">set</span>(train_merged.columns) <span class="op">==</span> <span class="bu">set</span>(test_merged.columns))  <span class="co"># Should be True</span></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Check if column order matches</span></span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">list</span>(train_merged.columns) <span class="op">==</span> <span class="bu">list</span>(test_merged.columns))  <span class="co"># Must also be True</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="b87fbf56" class="cell" data-execution_count="106">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb106"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> optuna</span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> lightgbm <span class="im">as</span> lgb</span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> shap</span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> KFold</span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> root_mean_squared_error</span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> optuna.integration <span class="im">import</span> LightGBMPruningCallback</span>
<span id="cb106-9"><a href="#cb106-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> optuna.pruners <span class="im">import</span> SuccessiveHalvingPruner</span>
<span id="cb106-10"><a href="#cb106-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> lightgbm <span class="im">import</span> log_evaluation, early_stopping</span>
<span id="cb106-11"><a href="#cb106-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-12"><a href="#cb106-12" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 0: Setup Data ===</span></span>
<span id="cb106-13"><a href="#cb106-13" aria-hidden="true" tabindex="-1"></a>X_full <span class="op">=</span> train_merged.copy()</span>
<span id="cb106-14"><a href="#cb106-14" aria-hidden="true" tabindex="-1"></a>y_full <span class="op">=</span> pd.Series(y_train)</span>
<span id="cb106-15"><a href="#cb106-15" aria-hidden="true" tabindex="-1"></a>X_test <span class="op">=</span> test_merged.copy()</span>
<span id="cb106-16"><a href="#cb106-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-17"><a href="#cb106-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Detect categorical columns</span></span>
<span id="cb106-18"><a href="#cb106-18" aria-hidden="true" tabindex="-1"></a>cat_cols <span class="op">=</span> X_full.select_dtypes(include<span class="op">=</span>[<span class="st">'category'</span>, <span class="st">'object'</span>]).columns.tolist()</span>
<span id="cb106-19"><a href="#cb106-19" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> cat_cols:</span>
<span id="cb106-20"><a href="#cb106-20" aria-hidden="true" tabindex="-1"></a>    X_full[col] <span class="op">=</span> X_full[col].astype(<span class="st">"category"</span>)</span>
<span id="cb106-21"><a href="#cb106-21" aria-hidden="true" tabindex="-1"></a>    X_test[col] <span class="op">=</span> X_test[col].astype(<span class="st">"category"</span>)</span>
<span id="cb106-22"><a href="#cb106-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-23"><a href="#cb106-23" aria-hidden="true" tabindex="-1"></a>global_oof_preds <span class="op">=</span> np.zeros(<span class="bu">len</span>(X_full))</span>
<span id="cb106-24"><a href="#cb106-24" aria-hidden="true" tabindex="-1"></a>best_score <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb106-25"><a href="#cb106-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-26"><a href="#cb106-26" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 1: Define Optuna Objective ===</span></span>
<span id="cb106-27"><a href="#cb106-27" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> objective(trial):</span>
<span id="cb106-28"><a href="#cb106-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">global</span> global_oof_preds, best_score</span>
<span id="cb106-29"><a href="#cb106-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-30"><a href="#cb106-30" aria-hidden="true" tabindex="-1"></a>    params <span class="op">=</span> {</span>
<span id="cb106-31"><a href="#cb106-31" aria-hidden="true" tabindex="-1"></a>        <span class="st">"objective"</span>: <span class="st">"regression"</span>,</span>
<span id="cb106-32"><a href="#cb106-32" aria-hidden="true" tabindex="-1"></a>        <span class="st">"metric"</span>: <span class="st">"rmse"</span>,</span>
<span id="cb106-33"><a href="#cb106-33" aria-hidden="true" tabindex="-1"></a>        <span class="st">"boosting_type"</span>: <span class="st">"gbdt"</span>,</span>
<span id="cb106-34"><a href="#cb106-34" aria-hidden="true" tabindex="-1"></a>        <span class="st">"learning_rate"</span>: trial.suggest_float(<span class="st">"learning_rate"</span>, <span class="fl">0.025</span>, <span class="fl">0.04</span>, log<span class="op">=</span><span class="va">True</span>),</span>
<span id="cb106-35"><a href="#cb106-35" aria-hidden="true" tabindex="-1"></a>        <span class="st">"num_leaves"</span>: trial.suggest_int(<span class="st">"num_leaves"</span>, <span class="dv">160</span>, <span class="dv">220</span>),</span>
<span id="cb106-36"><a href="#cb106-36" aria-hidden="true" tabindex="-1"></a>        <span class="st">"max_depth"</span>: trial.suggest_int(<span class="st">"max_depth"</span>, <span class="dv">7</span>, <span class="dv">11</span>),</span>
<span id="cb106-37"><a href="#cb106-37" aria-hidden="true" tabindex="-1"></a>        <span class="st">"min_child_samples"</span>: trial.suggest_int(<span class="st">"min_child_samples"</span>, <span class="dv">18</span>, <span class="dv">30</span>),</span>
<span id="cb106-38"><a href="#cb106-38" aria-hidden="true" tabindex="-1"></a>        <span class="st">"subsample"</span>: trial.suggest_float(<span class="st">"subsample"</span>, <span class="fl">0.65</span>, <span class="fl">0.88</span>),</span>
<span id="cb106-39"><a href="#cb106-39" aria-hidden="true" tabindex="-1"></a>        <span class="st">"colsample_bytree"</span>: trial.suggest_float(<span class="st">"colsample_bytree"</span>, <span class="fl">0.6</span>, <span class="fl">0.75</span>),</span>
<span id="cb106-40"><a href="#cb106-40" aria-hidden="true" tabindex="-1"></a>        <span class="st">"reg_alpha"</span>: trial.suggest_float(<span class="st">"reg_alpha"</span>, <span class="fl">1.0</span>, <span class="fl">5.0</span>, log<span class="op">=</span><span class="va">True</span>),</span>
<span id="cb106-41"><a href="#cb106-41" aria-hidden="true" tabindex="-1"></a>        <span class="st">"reg_lambda"</span>: trial.suggest_float(<span class="st">"reg_lambda"</span>, <span class="fl">1.0</span>, <span class="fl">4.0</span>, log<span class="op">=</span><span class="va">True</span>),</span>
<span id="cb106-42"><a href="#cb106-42" aria-hidden="true" tabindex="-1"></a>        <span class="st">"min_split_gain"</span>: trial.suggest_float(<span class="st">"min_split_gain"</span>, <span class="fl">0.15</span>, <span class="fl">0.25</span>),</span>
<span id="cb106-43"><a href="#cb106-43" aria-hidden="true" tabindex="-1"></a>        <span class="st">"verbose"</span>: <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb106-44"><a href="#cb106-44" aria-hidden="true" tabindex="-1"></a>        <span class="st">"n_jobs"</span>: <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb106-45"><a href="#cb106-45" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb106-46"><a href="#cb106-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-47"><a href="#cb106-47" aria-hidden="true" tabindex="-1"></a>    kf <span class="op">=</span> KFold(n_splits<span class="op">=</span><span class="dv">3</span>, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb106-48"><a href="#cb106-48" aria-hidden="true" tabindex="-1"></a>    val_rmse <span class="op">=</span> []</span>
<span id="cb106-49"><a href="#cb106-49" aria-hidden="true" tabindex="-1"></a>    oof_preds <span class="op">=</span> np.zeros(<span class="bu">len</span>(X_full))</span>
<span id="cb106-50"><a href="#cb106-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-51"><a href="#cb106-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> fold, (train_idx, val_idx) <span class="kw">in</span> <span class="bu">enumerate</span>(kf.split(X_full)):</span>
<span id="cb106-52"><a href="#cb106-52" aria-hidden="true" tabindex="-1"></a>        X_train, X_val <span class="op">=</span> X_full.iloc[train_idx], X_full.iloc[val_idx]</span>
<span id="cb106-53"><a href="#cb106-53" aria-hidden="true" tabindex="-1"></a>        y_train_fold, y_val <span class="op">=</span> y_full.iloc[train_idx], y_full.iloc[val_idx]</span>
<span id="cb106-54"><a href="#cb106-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-55"><a href="#cb106-55" aria-hidden="true" tabindex="-1"></a>        dtrain <span class="op">=</span> lgb.Dataset(X_train, label<span class="op">=</span>y_train_fold, categorical_feature<span class="op">=</span>cat_cols)</span>
<span id="cb106-56"><a href="#cb106-56" aria-hidden="true" tabindex="-1"></a>        dvalid <span class="op">=</span> lgb.Dataset(X_val, label<span class="op">=</span>y_val, categorical_feature<span class="op">=</span>cat_cols)</span>
<span id="cb106-57"><a href="#cb106-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-58"><a href="#cb106-58" aria-hidden="true" tabindex="-1"></a>        model <span class="op">=</span> lgb.train(</span>
<span id="cb106-59"><a href="#cb106-59" aria-hidden="true" tabindex="-1"></a>            params,</span>
<span id="cb106-60"><a href="#cb106-60" aria-hidden="true" tabindex="-1"></a>            dtrain,</span>
<span id="cb106-61"><a href="#cb106-61" aria-hidden="true" tabindex="-1"></a>            valid_sets<span class="op">=</span>[dvalid],</span>
<span id="cb106-62"><a href="#cb106-62" aria-hidden="true" tabindex="-1"></a>            num_boost_round<span class="op">=</span><span class="dv">1000</span>,</span>
<span id="cb106-63"><a href="#cb106-63" aria-hidden="true" tabindex="-1"></a>            callbacks<span class="op">=</span>[</span>
<span id="cb106-64"><a href="#cb106-64" aria-hidden="true" tabindex="-1"></a>                early_stopping(stopping_rounds<span class="op">=</span><span class="dv">100</span>),</span>
<span id="cb106-65"><a href="#cb106-65" aria-hidden="true" tabindex="-1"></a>                log_evaluation(period<span class="op">=</span><span class="dv">100</span>),</span>
<span id="cb106-66"><a href="#cb106-66" aria-hidden="true" tabindex="-1"></a>                LightGBMPruningCallback(trial, <span class="st">"rmse"</span>)</span>
<span id="cb106-67"><a href="#cb106-67" aria-hidden="true" tabindex="-1"></a>            ]</span>
<span id="cb106-68"><a href="#cb106-68" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb106-69"><a href="#cb106-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-70"><a href="#cb106-70" aria-hidden="true" tabindex="-1"></a>        val_pred <span class="op">=</span> model.predict(X_val, num_iteration<span class="op">=</span>model.best_iteration)</span>
<span id="cb106-71"><a href="#cb106-71" aria-hidden="true" tabindex="-1"></a>        oof_preds[val_idx] <span class="op">=</span> val_pred</span>
<span id="cb106-72"><a href="#cb106-72" aria-hidden="true" tabindex="-1"></a>        val_rmse.append(root_mean_squared_error(y_val, val_pred))</span>
<span id="cb106-73"><a href="#cb106-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-74"><a href="#cb106-74" aria-hidden="true" tabindex="-1"></a>    mean_rmse <span class="op">=</span> np.mean(val_rmse)</span>
<span id="cb106-75"><a href="#cb106-75" aria-hidden="true" tabindex="-1"></a>    trial.set_user_attr(<span class="st">"cv_rmse"</span>, mean_rmse)</span>
<span id="cb106-76"><a href="#cb106-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-77"><a href="#cb106-77" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> mean_rmse <span class="op">&lt;</span> best_score:</span>
<span id="cb106-78"><a href="#cb106-78" aria-hidden="true" tabindex="-1"></a>        best_score <span class="op">=</span> mean_rmse</span>
<span id="cb106-79"><a href="#cb106-79" aria-hidden="true" tabindex="-1"></a>        global_oof_preds[:] <span class="op">=</span> oof_preds</span>
<span id="cb106-80"><a href="#cb106-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-81"><a href="#cb106-81" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Trial </span><span class="sc">{</span>trial<span class="sc">.</span>number<span class="sc">}</span><span class="ss"> | CV RMSE: </span><span class="sc">{</span>mean_rmse<span class="sc">:,.2f}</span><span class="ss">"</span>)</span>
<span id="cb106-82"><a href="#cb106-82" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mean_rmse</span>
<span id="cb106-83"><a href="#cb106-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-84"><a href="#cb106-84" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 2: Run Optuna ===</span></span>
<span id="cb106-85"><a href="#cb106-85" aria-hidden="true" tabindex="-1"></a>study <span class="op">=</span> optuna.create_study(</span>
<span id="cb106-86"><a href="#cb106-86" aria-hidden="true" tabindex="-1"></a>    direction<span class="op">=</span><span class="st">'minimize'</span>,</span>
<span id="cb106-87"><a href="#cb106-87" aria-hidden="true" tabindex="-1"></a>    study_name<span class="op">=</span><span class="st">'lgbm_study_final_with_shap'</span>,</span>
<span id="cb106-88"><a href="#cb106-88" aria-hidden="true" tabindex="-1"></a>    storage<span class="op">=</span><span class="st">'sqlite:///lgbm_study_final_with_shap.db'</span>,</span>
<span id="cb106-89"><a href="#cb106-89" aria-hidden="true" tabindex="-1"></a>    load_if_exists<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb106-90"><a href="#cb106-90" aria-hidden="true" tabindex="-1"></a>    pruner<span class="op">=</span>SuccessiveHalvingPruner(min_resource<span class="op">=</span><span class="dv">100</span>, reduction_factor<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb106-91"><a href="#cb106-91" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb106-92"><a href="#cb106-92" aria-hidden="true" tabindex="-1"></a>study.optimize(objective, n_trials<span class="op">=</span><span class="dv">25</span>, show_progress_bar<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb106-93"><a href="#cb106-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-94"><a href="#cb106-94" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Best RMSE:"</span>, study.best_value)</span>
<span id="cb106-95"><a href="#cb106-95" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Best Parameters:"</span>, study.best_params)</span>
<span id="cb106-96"><a href="#cb106-96" aria-hidden="true" tabindex="-1"></a>np.save(<span class="st">"oof_preds_lgbm.npy"</span>, global_oof_preds)</span>
<span id="cb106-97"><a href="#cb106-97" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Saved: oof_preds_lgbm.npy"</span>)</span>
<span id="cb106-98"><a href="#cb106-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-99"><a href="#cb106-99" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 3: SHAP + GAIN Feature Selection ===</span></span>
<span id="cb106-100"><a href="#cb106-100" aria-hidden="true" tabindex="-1"></a>kf <span class="op">=</span> KFold(n_splits<span class="op">=</span><span class="dv">3</span>, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb106-101"><a href="#cb106-101" aria-hidden="true" tabindex="-1"></a>selected_feature_sets <span class="op">=</span> []</span>
<span id="cb106-102"><a href="#cb106-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-103"><a href="#cb106-103" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> fold, (train_idx, val_idx) <span class="kw">in</span> <span class="bu">enumerate</span>(kf.split(X_full)):</span>
<span id="cb106-104"><a href="#cb106-104" aria-hidden="true" tabindex="-1"></a>    X_train_raw, y_train_fold <span class="op">=</span> X_full.iloc[train_idx], y_full.iloc[train_idx]</span>
<span id="cb106-105"><a href="#cb106-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-106"><a href="#cb106-106" aria-hidden="true" tabindex="-1"></a>    train_dataset <span class="op">=</span> lgb.Dataset(X_train_raw, label<span class="op">=</span>y_train_fold, categorical_feature<span class="op">=</span>cat_cols)</span>
<span id="cb106-107"><a href="#cb106-107" aria-hidden="true" tabindex="-1"></a>    model_temp <span class="op">=</span> lgb.train(</span>
<span id="cb106-108"><a href="#cb106-108" aria-hidden="true" tabindex="-1"></a>        study.best_params,</span>
<span id="cb106-109"><a href="#cb106-109" aria-hidden="true" tabindex="-1"></a>        train_dataset,</span>
<span id="cb106-110"><a href="#cb106-110" aria-hidden="true" tabindex="-1"></a>        num_boost_round<span class="op">=</span><span class="dv">200</span>,</span>
<span id="cb106-111"><a href="#cb106-111" aria-hidden="true" tabindex="-1"></a>        valid_sets<span class="op">=</span>[train_dataset],</span>
<span id="cb106-112"><a href="#cb106-112" aria-hidden="true" tabindex="-1"></a>        callbacks<span class="op">=</span>[log_evaluation(period<span class="op">=</span><span class="dv">100</span>)] </span>
<span id="cb106-113"><a href="#cb106-113" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb106-114"><a href="#cb106-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-115"><a href="#cb106-115" aria-hidden="true" tabindex="-1"></a>    <span class="co"># SHAP importance</span></span>
<span id="cb106-116"><a href="#cb106-116" aria-hidden="true" tabindex="-1"></a>    explainer <span class="op">=</span> shap.TreeExplainer(model_temp)</span>
<span id="cb106-117"><a href="#cb106-117" aria-hidden="true" tabindex="-1"></a>    shap_values <span class="op">=</span> explainer.shap_values(X_train_raw)</span>
<span id="cb106-118"><a href="#cb106-118" aria-hidden="true" tabindex="-1"></a>    shap_df <span class="op">=</span> pd.DataFrame(np.<span class="bu">abs</span>(shap_values), columns<span class="op">=</span>X_train_raw.columns)</span>
<span id="cb106-119"><a href="#cb106-119" aria-hidden="true" tabindex="-1"></a>    shap_importance <span class="op">=</span> shap_df.mean().sort_values(ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb106-120"><a href="#cb106-120" aria-hidden="true" tabindex="-1"></a>    shap_cumsum <span class="op">=</span> shap_importance.cumsum() <span class="op">/</span> shap_importance.<span class="bu">sum</span>()</span>
<span id="cb106-121"><a href="#cb106-121" aria-hidden="true" tabindex="-1"></a>    top_shap <span class="op">=</span> shap_cumsum[shap_cumsum <span class="op">&lt;=</span> <span class="fl">0.95</span>].index.tolist()</span>
<span id="cb106-122"><a href="#cb106-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-123"><a href="#cb106-123" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Gain importance</span></span>
<span id="cb106-124"><a href="#cb106-124" aria-hidden="true" tabindex="-1"></a>    gain_importance <span class="op">=</span> pd.Series(model_temp.feature_importance(importance_type<span class="op">=</span><span class="st">'gain'</span>), index<span class="op">=</span>X_train_raw.columns)</span>
<span id="cb106-125"><a href="#cb106-125" aria-hidden="true" tabindex="-1"></a>    gain_sorted <span class="op">=</span> gain_importance.sort_values(ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb106-126"><a href="#cb106-126" aria-hidden="true" tabindex="-1"></a>    gain_cumsum <span class="op">=</span> gain_sorted.cumsum() <span class="op">/</span> gain_sorted.<span class="bu">sum</span>()</span>
<span id="cb106-127"><a href="#cb106-127" aria-hidden="true" tabindex="-1"></a>    top_gain <span class="op">=</span> gain_cumsum[gain_cumsum <span class="op">&lt;=</span> <span class="fl">0.95</span>].index.tolist()</span>
<span id="cb106-128"><a href="#cb106-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-129"><a href="#cb106-129" aria-hidden="true" tabindex="-1"></a>    selected_features <span class="op">=</span> <span class="bu">list</span>(<span class="bu">set</span>(top_shap).union(<span class="bu">set</span>(top_gain)))</span>
<span id="cb106-130"><a href="#cb106-130" aria-hidden="true" tabindex="-1"></a>    selected_feature_sets.append(selected_features)</span>
<span id="cb106-131"><a href="#cb106-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-132"><a href="#cb106-132" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 4: Final Feature Union ===</span></span>
<span id="cb106-133"><a href="#cb106-133" aria-hidden="true" tabindex="-1"></a>final_union_features <span class="op">=</span> <span class="bu">list</span>(<span class="bu">set</span>().union(<span class="op">*</span>selected_feature_sets))</span>
<span id="cb106-134"><a href="#cb106-134" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Final Union Feature Count:"</span>, <span class="bu">len</span>(final_union_features))</span>
<span id="cb106-135"><a href="#cb106-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-136"><a href="#cb106-136" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter only those categorical columns that are in final features</span></span>
<span id="cb106-137"><a href="#cb106-137" aria-hidden="true" tabindex="-1"></a>filtered_cat_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> cat_cols <span class="cf">if</span> col <span class="kw">in</span> final_union_features]</span>
<span id="cb106-138"><a href="#cb106-138" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-139"><a href="#cb106-139" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 5: Final Model on Selected Features ===</span></span>
<span id="cb106-140"><a href="#cb106-140" aria-hidden="true" tabindex="-1"></a>X_full_selected <span class="op">=</span> X_full[final_union_features]</span>
<span id="cb106-141"><a href="#cb106-141" aria-hidden="true" tabindex="-1"></a>X_test_selected <span class="op">=</span> X_test[final_union_features]</span>
<span id="cb106-142"><a href="#cb106-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-143"><a href="#cb106-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-144"><a href="#cb106-144" aria-hidden="true" tabindex="-1"></a>final_dataset <span class="op">=</span> lgb.Dataset(X_full_selected, label<span class="op">=</span>y_full, categorical_feature<span class="op">=</span>filtered_cat_cols)</span>
<span id="cb106-145"><a href="#cb106-145" aria-hidden="true" tabindex="-1"></a>final_model <span class="op">=</span> lgb.train(</span>
<span id="cb106-146"><a href="#cb106-146" aria-hidden="true" tabindex="-1"></a>    study.best_params,</span>
<span id="cb106-147"><a href="#cb106-147" aria-hidden="true" tabindex="-1"></a>    final_dataset,</span>
<span id="cb106-148"><a href="#cb106-148" aria-hidden="true" tabindex="-1"></a>    num_boost_round<span class="op">=</span><span class="dv">1000</span>,</span>
<span id="cb106-149"><a href="#cb106-149" aria-hidden="true" tabindex="-1"></a>    valid_sets<span class="op">=</span>[final_dataset],</span>
<span id="cb106-150"><a href="#cb106-150" aria-hidden="true" tabindex="-1"></a>    valid_names<span class="op">=</span>[<span class="st">"train"</span>],</span>
<span id="cb106-151"><a href="#cb106-151" aria-hidden="true" tabindex="-1"></a>    callbacks<span class="op">=</span>[log_evaluation(period<span class="op">=</span><span class="dv">100</span>)]</span>
<span id="cb106-152"><a href="#cb106-152" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb106-153"><a href="#cb106-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-154"><a href="#cb106-154" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 6: Predict on Test Set ===</span></span>
<span id="cb106-155"><a href="#cb106-155" aria-hidden="true" tabindex="-1"></a>test_preds <span class="op">=</span> final_model.predict(X_test_selected, num_iteration<span class="op">=</span>final_model.best_iteration)</span>
<span id="cb106-156"><a href="#cb106-156" aria-hidden="true" tabindex="-1"></a>np.save(<span class="st">"test_preds_lgbm_shap.npy"</span>, test_preds)</span>
<span id="cb106-157"><a href="#cb106-157" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Saved: test_preds_lgbm_shap.npy"</span>)</span>
<span id="cb106-158"><a href="#cb106-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-159"><a href="#cb106-159" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 7: Save Submission ===</span></span>
<span id="cb106-160"><a href="#cb106-160" aria-hidden="true" tabindex="-1"></a>submission <span class="op">=</span> pd.DataFrame({</span>
<span id="cb106-161"><a href="#cb106-161" aria-hidden="true" tabindex="-1"></a>    <span class="st">'ACCOUNT'</span>: acct_test.values.ravel(),  <span class="co"># Replace with your ID col</span></span>
<span id="cb106-162"><a href="#cb106-162" aria-hidden="true" tabindex="-1"></a>    <span class="st">'TARGET'</span>: test_preds</span>
<span id="cb106-163"><a href="#cb106-163" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb106-164"><a href="#cb106-164" aria-hidden="true" tabindex="-1"></a>submission.to_csv(<span class="st">"submission_lgbm_shap.csv"</span>, index<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb106-165"><a href="#cb106-165" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Submission saved: submission_lgbm_shap.csv"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="c4b1222b" class="cell" data-execution_count="107">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb107"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> optuna</span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> xgboost <span class="im">import</span> XGBRegressor</span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> KFold</span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> root_mean_squared_error</span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> optuna.integration <span class="im">import</span> XGBoostPruningCallback</span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> shap <span class="im">import</span> TreeExplainer</span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-10"><a href="#cb107-10" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 0: Prepare Data ===</span></span>
<span id="cb107-11"><a href="#cb107-11" aria-hidden="true" tabindex="-1"></a>X_full <span class="op">=</span> train_merged.copy()</span>
<span id="cb107-12"><a href="#cb107-12" aria-hidden="true" tabindex="-1"></a>y_full <span class="op">=</span> pd.Series(y_train)</span>
<span id="cb107-13"><a href="#cb107-13" aria-hidden="true" tabindex="-1"></a>X_test <span class="op">=</span> test_merged.copy()</span>
<span id="cb107-14"><a href="#cb107-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-15"><a href="#cb107-15" aria-hidden="true" tabindex="-1"></a>bin_cols <span class="op">=</span> [</span>
<span id="cb107-16"><a href="#cb107-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_value_growth_bin'</span>,</span>
<span id="cb107-17"><a href="#cb107-17" aria-hidden="true" tabindex="-1"></a>    <span class="st">'assessed_growth_bin'</span>,</span>
<span id="cb107-18"><a href="#cb107-18" aria-hidden="true" tabindex="-1"></a>    <span class="st">'land_value_growth_bin'</span>,<span class="st">'year_built_bin'</span></span>
<span id="cb107-19"><a href="#cb107-19" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb107-20"><a href="#cb107-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-21"><a href="#cb107-21" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> bin_cols:</span>
<span id="cb107-22"><a href="#cb107-22" aria-hidden="true" tabindex="-1"></a>    X_full[col] <span class="op">=</span> X_full[col].cat.codes</span>
<span id="cb107-23"><a href="#cb107-23" aria-hidden="true" tabindex="-1"></a>    X_test[col] <span class="op">=</span> X_test[col].cat.codes</span>
<span id="cb107-24"><a href="#cb107-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-25"><a href="#cb107-25" aria-hidden="true" tabindex="-1"></a>categorical_cols <span class="op">=</span> X_full.select_dtypes(include<span class="op">=</span><span class="st">'object'</span>).columns.tolist()</span>
<span id="cb107-26"><a href="#cb107-26" aria-hidden="true" tabindex="-1"></a>X_full[categorical_cols] <span class="op">=</span> X_full[categorical_cols].astype(<span class="st">'category'</span>)</span>
<span id="cb107-27"><a href="#cb107-27" aria-hidden="true" tabindex="-1"></a>X_test[categorical_cols] <span class="op">=</span> X_test[categorical_cols].astype(<span class="st">'category'</span>)</span>
<span id="cb107-28"><a href="#cb107-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-29"><a href="#cb107-29" aria-hidden="true" tabindex="-1"></a><span class="co"># === Global OOF Tracker ===</span></span>
<span id="cb107-30"><a href="#cb107-30" aria-hidden="true" tabindex="-1"></a>global_oof_preds <span class="op">=</span> np.zeros(<span class="bu">len</span>(X_full))</span>
<span id="cb107-31"><a href="#cb107-31" aria-hidden="true" tabindex="-1"></a>best_score <span class="op">=</span> <span class="bu">float</span>(<span class="st">"inf"</span>)</span>
<span id="cb107-32"><a href="#cb107-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-33"><a href="#cb107-33" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 1: Optuna Objective Function (No SHAP during tuning) ===</span></span>
<span id="cb107-34"><a href="#cb107-34" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> objective(trial):</span>
<span id="cb107-35"><a href="#cb107-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">global</span> global_oof_preds, best_score</span>
<span id="cb107-36"><a href="#cb107-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-37"><a href="#cb107-37" aria-hidden="true" tabindex="-1"></a>    params <span class="op">=</span> {</span>
<span id="cb107-38"><a href="#cb107-38" aria-hidden="true" tabindex="-1"></a>        <span class="st">"objective"</span>: <span class="st">"reg:squarederror"</span>,</span>
<span id="cb107-39"><a href="#cb107-39" aria-hidden="true" tabindex="-1"></a>        <span class="st">"eval_metric"</span>: <span class="st">"rmse"</span>,</span>
<span id="cb107-40"><a href="#cb107-40" aria-hidden="true" tabindex="-1"></a>        <span class="st">"tree_method"</span>: <span class="st">"hist"</span>,</span>
<span id="cb107-41"><a href="#cb107-41" aria-hidden="true" tabindex="-1"></a>        <span class="st">"learning_rate"</span>: trial.suggest_float(<span class="st">"learning_rate"</span>, <span class="fl">0.047</span>, <span class="fl">0.05</span>, log<span class="op">=</span><span class="va">True</span>),</span>
<span id="cb107-42"><a href="#cb107-42" aria-hidden="true" tabindex="-1"></a>        <span class="st">"max_depth"</span>: <span class="dv">6</span>,</span>
<span id="cb107-43"><a href="#cb107-43" aria-hidden="true" tabindex="-1"></a>        <span class="st">"min_child_weight"</span>: trial.suggest_int(<span class="st">"min_child_weight"</span>, <span class="dv">11</span>, <span class="dv">12</span>),</span>
<span id="cb107-44"><a href="#cb107-44" aria-hidden="true" tabindex="-1"></a>        <span class="st">"subsample"</span>: trial.suggest_float(<span class="st">"subsample"</span>, <span class="fl">0.87</span>, <span class="fl">0.89</span>),</span>
<span id="cb107-45"><a href="#cb107-45" aria-hidden="true" tabindex="-1"></a>        <span class="st">"colsample_bytree"</span>: trial.suggest_float(<span class="st">"colsample_bytree"</span>, <span class="fl">0.7</span>, <span class="fl">0.74</span>),</span>
<span id="cb107-46"><a href="#cb107-46" aria-hidden="true" tabindex="-1"></a>        <span class="st">"reg_alpha"</span>: trial.suggest_float(<span class="st">"reg_alpha"</span>, <span class="fl">0.30</span>, <span class="fl">0.56</span>, log<span class="op">=</span><span class="va">True</span>),</span>
<span id="cb107-47"><a href="#cb107-47" aria-hidden="true" tabindex="-1"></a>        <span class="st">"reg_lambda"</span>: trial.suggest_float(<span class="st">"reg_lambda"</span>, <span class="fl">0.05</span>, <span class="fl">0.11</span>, log<span class="op">=</span><span class="va">True</span>),</span>
<span id="cb107-48"><a href="#cb107-48" aria-hidden="true" tabindex="-1"></a>        <span class="st">"gamma"</span>: trial.suggest_float(<span class="st">"gamma"</span>, <span class="fl">1.1</span>, <span class="fl">4.3</span>),</span>
<span id="cb107-49"><a href="#cb107-49" aria-hidden="true" tabindex="-1"></a>        <span class="st">"n_estimators"</span>: <span class="dv">1000</span>,</span>
<span id="cb107-50"><a href="#cb107-50" aria-hidden="true" tabindex="-1"></a>        <span class="st">"n_jobs"</span>: <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb107-51"><a href="#cb107-51" aria-hidden="true" tabindex="-1"></a>        <span class="st">"enable_categorical"</span>: <span class="va">True</span>,</span>
<span id="cb107-52"><a href="#cb107-52" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb107-53"><a href="#cb107-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-54"><a href="#cb107-54" aria-hidden="true" tabindex="-1"></a>    kf <span class="op">=</span> KFold(n_splits<span class="op">=</span><span class="dv">3</span>, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb107-55"><a href="#cb107-55" aria-hidden="true" tabindex="-1"></a>    oof_preds <span class="op">=</span> np.zeros(<span class="bu">len</span>(X_full))</span>
<span id="cb107-56"><a href="#cb107-56" aria-hidden="true" tabindex="-1"></a>    fold_rmse <span class="op">=</span> []</span>
<span id="cb107-57"><a href="#cb107-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-58"><a href="#cb107-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> fold, (train_idx, val_idx) <span class="kw">in</span> <span class="bu">enumerate</span>(kf.split(X_full)):</span>
<span id="cb107-59"><a href="#cb107-59" aria-hidden="true" tabindex="-1"></a>        X_train, y_train_fold <span class="op">=</span> X_full.iloc[train_idx], y_full.iloc[train_idx]</span>
<span id="cb107-60"><a href="#cb107-60" aria-hidden="true" tabindex="-1"></a>        X_val, y_val <span class="op">=</span> X_full.iloc[val_idx], y_full.iloc[val_idx]</span>
<span id="cb107-61"><a href="#cb107-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-62"><a href="#cb107-62" aria-hidden="true" tabindex="-1"></a>        model <span class="op">=</span> XGBRegressor(</span>
<span id="cb107-63"><a href="#cb107-63" aria-hidden="true" tabindex="-1"></a>            <span class="op">**</span>params,</span>
<span id="cb107-64"><a href="#cb107-64" aria-hidden="true" tabindex="-1"></a>            early_stopping_rounds<span class="op">=</span><span class="dv">100</span>,</span>
<span id="cb107-65"><a href="#cb107-65" aria-hidden="true" tabindex="-1"></a>            callbacks<span class="op">=</span>[XGBoostPruningCallback(trial, <span class="st">"validation_0-rmse"</span>),</span>
<span id="cb107-66"><a href="#cb107-66" aria-hidden="true" tabindex="-1"></a>                       ]</span>
<span id="cb107-67"><a href="#cb107-67" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb107-68"><a href="#cb107-68" aria-hidden="true" tabindex="-1"></a>        model.fit(X_train, y_train_fold, eval_set<span class="op">=</span>[(X_val, y_val)], verbose<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb107-69"><a href="#cb107-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-70"><a href="#cb107-70" aria-hidden="true" tabindex="-1"></a>        val_pred <span class="op">=</span> model.predict(X_val)</span>
<span id="cb107-71"><a href="#cb107-71" aria-hidden="true" tabindex="-1"></a>        oof_preds[val_idx] <span class="op">=</span> val_pred</span>
<span id="cb107-72"><a href="#cb107-72" aria-hidden="true" tabindex="-1"></a>        fold_rmse.append(root_mean_squared_error(y_val, val_pred))</span>
<span id="cb107-73"><a href="#cb107-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-74"><a href="#cb107-74" aria-hidden="true" tabindex="-1"></a>    mean_rmse <span class="op">=</span> np.mean(fold_rmse)</span>
<span id="cb107-75"><a href="#cb107-75" aria-hidden="true" tabindex="-1"></a>    trial.set_user_attr(<span class="st">"cv_rmse"</span>, mean_rmse)</span>
<span id="cb107-76"><a href="#cb107-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-77"><a href="#cb107-77" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> mean_rmse <span class="op">&lt;</span> best_score:</span>
<span id="cb107-78"><a href="#cb107-78" aria-hidden="true" tabindex="-1"></a>        best_score <span class="op">=</span> mean_rmse</span>
<span id="cb107-79"><a href="#cb107-79" aria-hidden="true" tabindex="-1"></a>        global_oof_preds[:] <span class="op">=</span> oof_preds</span>
<span id="cb107-80"><a href="#cb107-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-81"><a href="#cb107-81" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Trial </span><span class="sc">{</span>trial<span class="sc">.</span>number<span class="sc">}</span><span class="ss"> | CV RMSE: </span><span class="sc">{</span>mean_rmse<span class="sc">:,.2f}</span><span class="ss">"</span>)</span>
<span id="cb107-82"><a href="#cb107-82" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mean_rmse</span>
<span id="cb107-83"><a href="#cb107-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-84"><a href="#cb107-84" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 2: Run Optuna ===</span></span>
<span id="cb107-85"><a href="#cb107-85" aria-hidden="true" tabindex="-1"></a>study <span class="op">=</span> optuna.create_study(</span>
<span id="cb107-86"><a href="#cb107-86" aria-hidden="true" tabindex="-1"></a>    direction<span class="op">=</span><span class="st">'minimize'</span>,</span>
<span id="cb107-87"><a href="#cb107-87" aria-hidden="true" tabindex="-1"></a>    study_name<span class="op">=</span><span class="st">'xgbreg_optuna_final_no_shap'</span>,</span>
<span id="cb107-88"><a href="#cb107-88" aria-hidden="true" tabindex="-1"></a>    pruner<span class="op">=</span>optuna.pruners.SuccessiveHalvingPruner(min_resource<span class="op">=</span><span class="dv">100</span>, reduction_factor<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb107-89"><a href="#cb107-89" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb107-90"><a href="#cb107-90" aria-hidden="true" tabindex="-1"></a>study.optimize(objective, n_trials<span class="op">=</span><span class="dv">25</span>, show_progress_bar<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb107-91"><a href="#cb107-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-92"><a href="#cb107-92" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Best RMSE:"</span>, study.best_value)</span>
<span id="cb107-93"><a href="#cb107-93" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Best Parameters:"</span>, study.best_params)</span>
<span id="cb107-94"><a href="#cb107-94" aria-hidden="true" tabindex="-1"></a>np.save(<span class="st">"oof_preds_xgbreg.npy"</span>, global_oof_preds)</span>
<span id="cb107-95"><a href="#cb107-95" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Saved: oof_preds_xgbreg.npy"</span>)</span>
<span id="cb107-96"><a href="#cb107-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-97"><a href="#cb107-97" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 3: Post-Optuna SHAP + Gain Feature Selection ===</span></span>
<span id="cb107-98"><a href="#cb107-98" aria-hidden="true" tabindex="-1"></a>kf <span class="op">=</span> KFold(n_splits<span class="op">=</span><span class="dv">3</span>, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb107-99"><a href="#cb107-99" aria-hidden="true" tabindex="-1"></a>selected_feature_sets <span class="op">=</span> []</span>
<span id="cb107-100"><a href="#cb107-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-101"><a href="#cb107-101" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> fold, (train_idx, val_idx) <span class="kw">in</span> <span class="bu">enumerate</span>(kf.split(X_full)):</span>
<span id="cb107-102"><a href="#cb107-102" aria-hidden="true" tabindex="-1"></a>    X_train_raw, y_train_fold <span class="op">=</span> X_full.iloc[train_idx], y_full.iloc[train_idx]</span>
<span id="cb107-103"><a href="#cb107-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-104"><a href="#cb107-104" aria-hidden="true" tabindex="-1"></a>    model_temp <span class="op">=</span> XGBRegressor(<span class="op">**</span>study.best_params, n_estimators<span class="op">=</span><span class="dv">200</span>)</span>
<span id="cb107-105"><a href="#cb107-105" aria-hidden="true" tabindex="-1"></a>    model_temp.fit(X_train_raw, y_train_fold)</span>
<span id="cb107-106"><a href="#cb107-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-107"><a href="#cb107-107" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === SHAP Importance ===</span></span>
<span id="cb107-108"><a href="#cb107-108" aria-hidden="true" tabindex="-1"></a>    explainer <span class="op">=</span> TreeExplainer(model_temp)</span>
<span id="cb107-109"><a href="#cb107-109" aria-hidden="true" tabindex="-1"></a>    shap_values <span class="op">=</span> explainer.shap_values(X_train_raw)</span>
<span id="cb107-110"><a href="#cb107-110" aria-hidden="true" tabindex="-1"></a>    shap_df <span class="op">=</span> pd.DataFrame(np.<span class="bu">abs</span>(shap_values), columns<span class="op">=</span>X_train_raw.columns)</span>
<span id="cb107-111"><a href="#cb107-111" aria-hidden="true" tabindex="-1"></a>    shap_importance <span class="op">=</span> shap_df.mean().sort_values(ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb107-112"><a href="#cb107-112" aria-hidden="true" tabindex="-1"></a>    shap_cumsum <span class="op">=</span> shap_importance.cumsum() <span class="op">/</span> shap_importance.<span class="bu">sum</span>()</span>
<span id="cb107-113"><a href="#cb107-113" aria-hidden="true" tabindex="-1"></a>    top_shap <span class="op">=</span> shap_cumsum[shap_cumsum <span class="op">&lt;=</span> <span class="fl">0.95</span>].index.tolist()</span>
<span id="cb107-114"><a href="#cb107-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-115"><a href="#cb107-115" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Gain Importance ===</span></span>
<span id="cb107-116"><a href="#cb107-116" aria-hidden="true" tabindex="-1"></a>    gain_importance <span class="op">=</span> pd.Series(model_temp.feature_importances_, index<span class="op">=</span>X_train_raw.columns)</span>
<span id="cb107-117"><a href="#cb107-117" aria-hidden="true" tabindex="-1"></a>    gain_sorted <span class="op">=</span> gain_importance.sort_values(ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb107-118"><a href="#cb107-118" aria-hidden="true" tabindex="-1"></a>    gain_cumsum <span class="op">=</span> gain_sorted.cumsum() <span class="op">/</span> gain_sorted.<span class="bu">sum</span>()</span>
<span id="cb107-119"><a href="#cb107-119" aria-hidden="true" tabindex="-1"></a>    top_gain <span class="op">=</span> gain_cumsum[gain_cumsum <span class="op">&lt;=</span> <span class="fl">0.95</span>].index.tolist()</span>
<span id="cb107-120"><a href="#cb107-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-121"><a href="#cb107-121" aria-hidden="true" tabindex="-1"></a>    selected_features <span class="op">=</span> <span class="bu">list</span>(<span class="bu">set</span>(top_shap).union(<span class="bu">set</span>(top_gain)))</span>
<span id="cb107-122"><a href="#cb107-122" aria-hidden="true" tabindex="-1"></a>    selected_feature_sets.append(selected_features)</span>
<span id="cb107-123"><a href="#cb107-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-124"><a href="#cb107-124" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 4: Final Feature Union ===</span></span>
<span id="cb107-125"><a href="#cb107-125" aria-hidden="true" tabindex="-1"></a>final_union_features <span class="op">=</span> <span class="bu">list</span>(<span class="bu">set</span>().union(<span class="op">*</span>selected_feature_sets))</span>
<span id="cb107-126"><a href="#cb107-126" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Final Union Feature Count:"</span>, <span class="bu">len</span>(final_union_features))</span>
<span id="cb107-127"><a href="#cb107-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-128"><a href="#cb107-128" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 5: Train Final Model with Early Stopping on Union Features ===</span></span>
<span id="cb107-129"><a href="#cb107-129" aria-hidden="true" tabindex="-1"></a>X_full_selected <span class="op">=</span> X_full[final_union_features]</span>
<span id="cb107-130"><a href="#cb107-130" aria-hidden="true" tabindex="-1"></a>X_test_selected <span class="op">=</span> X_test[final_union_features]</span>
<span id="cb107-131"><a href="#cb107-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-132"><a href="#cb107-132" aria-hidden="true" tabindex="-1"></a>final_model <span class="op">=</span> XGBRegressor(<span class="op">**</span>study.best_params)</span>
<span id="cb107-133"><a href="#cb107-133" aria-hidden="true" tabindex="-1"></a>final_model.set_params(n_estimators<span class="op">=</span><span class="dv">1000</span>, verbosity<span class="op">=</span><span class="dv">1</span>, early_stopping_rounds<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb107-134"><a href="#cb107-134" aria-hidden="true" tabindex="-1"></a>final_model.fit(X_full_selected, y_full, eval_set<span class="op">=</span>[(X_full_selected, y_full)], verbose<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb107-135"><a href="#cb107-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-136"><a href="#cb107-136" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 6: Predict on Test Set ===</span></span>
<span id="cb107-137"><a href="#cb107-137" aria-hidden="true" tabindex="-1"></a>test_preds <span class="op">=</span> final_model.predict(X_test_selected)</span>
<span id="cb107-138"><a href="#cb107-138" aria-hidden="true" tabindex="-1"></a>np.save(<span class="st">"test_preds_xgbreg.npy"</span>, test_preds)</span>
<span id="cb107-139"><a href="#cb107-139" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Saved: test_preds_xgbreg.npy"</span>)</span>
<span id="cb107-140"><a href="#cb107-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-141"><a href="#cb107-141" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 7: Create Submission File ===</span></span>
<span id="cb107-142"><a href="#cb107-142" aria-hidden="true" tabindex="-1"></a>account_ids <span class="op">=</span> acct_test.values.ravel()  <span class="co"># Replace with actual ID column</span></span>
<span id="cb107-143"><a href="#cb107-143" aria-hidden="true" tabindex="-1"></a>submission <span class="op">=</span> pd.DataFrame({</span>
<span id="cb107-144"><a href="#cb107-144" aria-hidden="true" tabindex="-1"></a>    <span class="st">'ACCOUNT'</span>: account_ids,</span>
<span id="cb107-145"><a href="#cb107-145" aria-hidden="true" tabindex="-1"></a>    <span class="st">'TARGET'</span>: test_preds</span>
<span id="cb107-146"><a href="#cb107-146" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb107-147"><a href="#cb107-147" aria-hidden="true" tabindex="-1"></a>submission.to_csv(<span class="st">"submission_xgbreg.csv"</span>, index<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb107-148"><a href="#cb107-148" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Submission saved: submission_xgbreg.csv"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="5f969a01" class="cell" data-execution_count="108">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb108"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a><span class="co"># === Compute Residuals ===</span></span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a>residuals <span class="op">=</span> y_full <span class="op">-</span> global_oof_preds</span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a>res_df <span class="op">=</span> X_full.copy()</span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a>res_df[<span class="st">"actual"</span>] <span class="op">=</span> y_full</span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true" tabindex="-1"></a>res_df[<span class="st">"predicted"</span>] <span class="op">=</span> global_oof_preds</span>
<span id="cb108-11"><a href="#cb108-11" aria-hidden="true" tabindex="-1"></a>res_df[<span class="st">"residual"</span>] <span class="op">=</span> residuals</span>
<span id="cb108-12"><a href="#cb108-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-13"><a href="#cb108-13" aria-hidden="true" tabindex="-1"></a><span class="co"># === Protest Count (2015‚Äì2018) ===</span></span>
<span id="cb108-14"><a href="#cb108-14" aria-hidden="true" tabindex="-1"></a>protest_cols <span class="op">=</span> [<span class="ss">f"protested_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2019</span>)]</span>
<span id="cb108-15"><a href="#cb108-15" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">all</span>(col <span class="kw">in</span> res_df.columns <span class="cf">for</span> col <span class="kw">in</span> protest_cols):</span>
<span id="cb108-16"><a href="#cb108-16" aria-hidden="true" tabindex="-1"></a>    res_df[<span class="st">"protest_count"</span>] <span class="op">=</span> res_df[protest_cols].<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb108-17"><a href="#cb108-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-18"><a href="#cb108-18" aria-hidden="true" tabindex="-1"></a><span class="co"># === Plot 1: Residuals vs Actual Value ===</span></span>
<span id="cb108-19"><a href="#cb108-19" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb108-20"><a href="#cb108-20" aria-hidden="true" tabindex="-1"></a>sns.scatterplot(data<span class="op">=</span>res_df, x<span class="op">=</span><span class="st">"actual"</span>, y<span class="op">=</span><span class="st">"residual"</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb108-21"><a href="#cb108-21" aria-hidden="true" tabindex="-1"></a>plt.axhline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">"red"</span>, linestyle<span class="op">=</span><span class="st">"--"</span>)</span>
<span id="cb108-22"><a href="#cb108-22" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Residuals vs. Actual Value"</span>)</span>
<span id="cb108-23"><a href="#cb108-23" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Actual Value"</span>)</span>
<span id="cb108-24"><a href="#cb108-24" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Residual (Actual - Predicted)"</span>)</span>
<span id="cb108-25"><a href="#cb108-25" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb108-26"><a href="#cb108-26" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">"residuals_vs_actual_value.png"</span>, dpi<span class="op">=</span><span class="dv">300</span>)</span>
<span id="cb108-27"><a href="#cb108-27" aria-hidden="true" tabindex="-1"></a>plt.close()</span>
<span id="cb108-28"><a href="#cb108-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-29"><a href="#cb108-29" aria-hidden="true" tabindex="-1"></a><span class="co"># === Plot 2: Residuals by Protest Count ===</span></span>
<span id="cb108-30"><a href="#cb108-30" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">"protest_count"</span> <span class="kw">in</span> res_df.columns:</span>
<span id="cb108-31"><a href="#cb108-31" aria-hidden="true" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb108-32"><a href="#cb108-32" aria-hidden="true" tabindex="-1"></a>    sns.boxplot(x<span class="op">=</span><span class="st">"protest_count"</span>, y<span class="op">=</span><span class="st">"residual"</span>, data<span class="op">=</span>res_df)</span>
<span id="cb108-33"><a href="#cb108-33" aria-hidden="true" tabindex="-1"></a>    plt.axhline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">"red"</span>, linestyle<span class="op">=</span><span class="st">"--"</span>)</span>
<span id="cb108-34"><a href="#cb108-34" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="st">"Residuals by Protest Count (2015‚Äì2018)"</span>)</span>
<span id="cb108-35"><a href="#cb108-35" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">"Number of Years Protested"</span>)</span>
<span id="cb108-36"><a href="#cb108-36" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">"Residual"</span>)</span>
<span id="cb108-37"><a href="#cb108-37" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb108-38"><a href="#cb108-38" aria-hidden="true" tabindex="-1"></a>    plt.savefig(<span class="st">"residuals_by_protest_count.png"</span>, dpi<span class="op">=</span><span class="dv">300</span>)</span>
<span id="cb108-39"><a href="#cb108-39" aria-hidden="true" tabindex="-1"></a>    plt.close()</span>
<span id="cb108-40"><a href="#cb108-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-41"><a href="#cb108-41" aria-hidden="true" tabindex="-1"></a><span class="co"># === Plot 3: Residuals vs. Neighborhood Frequency ===</span></span>
<span id="cb108-42"><a href="#cb108-42" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">"neighborhood_freq"</span> <span class="kw">in</span> res_df.columns:</span>
<span id="cb108-43"><a href="#cb108-43" aria-hidden="true" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb108-44"><a href="#cb108-44" aria-hidden="true" tabindex="-1"></a>    sns.scatterplot(x<span class="op">=</span><span class="st">"neighborhood_freq"</span>, y<span class="op">=</span><span class="st">"residual"</span>, data<span class="op">=</span>res_df, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb108-45"><a href="#cb108-45" aria-hidden="true" tabindex="-1"></a>    plt.axhline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">"red"</span>, linestyle<span class="op">=</span><span class="st">"--"</span>)</span>
<span id="cb108-46"><a href="#cb108-46" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="st">"Residuals vs. Neighborhood Frequency"</span>)</span>
<span id="cb108-47"><a href="#cb108-47" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">"Neighborhood Frequency"</span>)</span>
<span id="cb108-48"><a href="#cb108-48" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">"Residual"</span>)</span>
<span id="cb108-49"><a href="#cb108-49" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb108-50"><a href="#cb108-50" aria-hidden="true" tabindex="-1"></a>    plt.savefig(<span class="st">"residuals_vs_neighborhood_freq.png"</span>, dpi<span class="op">=</span><span class="dv">300</span>)</span>
<span id="cb108-51"><a href="#cb108-51" aria-hidden="true" tabindex="-1"></a>    plt.close()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="cf5791e7" class="cell" data-execution_count="109">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb109"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> shap</span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a><span class="co"># === SHAP Setup ===</span></span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a>explainer <span class="op">=</span> shap.TreeExplainer(final_model)</span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a>shap_values <span class="op">=</span> explainer.shap_values(X_full_selected)</span>
<span id="cb109-9"><a href="#cb109-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-10"><a href="#cb109-10" aria-hidden="true" tabindex="-1"></a><span class="co"># === SHAP DataFrame ===</span></span>
<span id="cb109-11"><a href="#cb109-11" aria-hidden="true" tabindex="-1"></a>shap_df <span class="op">=</span> pd.DataFrame(np.<span class="bu">abs</span>(shap_values), columns<span class="op">=</span>X_full_selected.columns)</span>
<span id="cb109-12"><a href="#cb109-12" aria-hidden="true" tabindex="-1"></a>shap_means <span class="op">=</span> shap_df.mean().sort_values(ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb109-13"><a href="#cb109-13" aria-hidden="true" tabindex="-1"></a>shap_importance_df <span class="op">=</span> shap_means.reset_index()</span>
<span id="cb109-14"><a href="#cb109-14" aria-hidden="true" tabindex="-1"></a>shap_importance_df.columns <span class="op">=</span> [<span class="st">"feature"</span>, <span class="st">"mean_shap"</span>]</span>
<span id="cb109-15"><a href="#cb109-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-16"><a href="#cb109-16" aria-hidden="true" tabindex="-1"></a><span class="co"># === SHAP Summary Plot: Top 30 ===</span></span>
<span id="cb109-17"><a href="#cb109-17" aria-hidden="true" tabindex="-1"></a>plt.figure()</span>
<span id="cb109-18"><a href="#cb109-18" aria-hidden="true" tabindex="-1"></a>shap.summary_plot(shap_values, X_full_selected, max_display<span class="op">=</span><span class="dv">30</span>, show<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb109-19"><a href="#cb109-19" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb109-20"><a href="#cb109-20" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">"shap_summary_top30_union.png"</span>, dpi<span class="op">=</span><span class="dv">300</span>)</span>
<span id="cb109-21"><a href="#cb109-21" aria-hidden="true" tabindex="-1"></a>plt.close()</span>
<span id="cb109-22"><a href="#cb109-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-23"><a href="#cb109-23" aria-hidden="true" tabindex="-1"></a><span class="co"># === SHAP Summary Plot: Bottom 30 ===</span></span>
<span id="cb109-24"><a href="#cb109-24" aria-hidden="true" tabindex="-1"></a>bottom_features <span class="op">=</span> shap_importance_df.tail(<span class="dv">30</span>)[<span class="st">"feature"</span>].tolist()</span>
<span id="cb109-25"><a href="#cb109-25" aria-hidden="true" tabindex="-1"></a>shap.summary_plot(</span>
<span id="cb109-26"><a href="#cb109-26" aria-hidden="true" tabindex="-1"></a>    shap_values[:, [X_full_selected.columns.get_loc(f) <span class="cf">for</span> f <span class="kw">in</span> bottom_features]],</span>
<span id="cb109-27"><a href="#cb109-27" aria-hidden="true" tabindex="-1"></a>    X_full_selected[bottom_features],</span>
<span id="cb109-28"><a href="#cb109-28" aria-hidden="true" tabindex="-1"></a>    show<span class="op">=</span><span class="va">False</span></span>
<span id="cb109-29"><a href="#cb109-29" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb109-30"><a href="#cb109-30" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb109-31"><a href="#cb109-31" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">"shap_summary_bottom30_union.png"</span>, dpi<span class="op">=</span><span class="dv">300</span>)</span>
<span id="cb109-32"><a href="#cb109-32" aria-hidden="true" tabindex="-1"></a>plt.close()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="rmse-optimization" class="level1">
<h1>RMSE Optimization</h1>
<div id="207ba135" class="cell" data-execution_count="110">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb110"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a><span class="co"># ===== Load Data =====</span></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a>folder_path <span class="op">=</span> <span class="st">'/Users/Srijith97/Downloads/STA 9890 Housing Data/'</span></span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a>building_years <span class="op">=</span> []</span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>):</span>
<span id="cb110-8"><a href="#cb110-8" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.read_csv(folder_path <span class="op">+</span> <span class="ss">f'building_details_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">.csv'</span>)</span>
<span id="cb110-9"><a href="#cb110-9" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'year'</span>] <span class="op">=</span> year</span>
<span id="cb110-10"><a href="#cb110-10" aria-hidden="true" tabindex="-1"></a>    building_years.append(df)</span>
<span id="cb110-11"><a href="#cb110-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-12"><a href="#cb110-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-13"><a href="#cb110-13" aria-hidden="true" tabindex="-1"></a>building_all <span class="op">=</span> pd.concat(building_years, ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb110-14"><a href="#cb110-14" aria-hidden="true" tabindex="-1"></a>building_all <span class="op">=</span> building_all.drop_duplicates(subset<span class="op">=</span>[<span class="st">'acct'</span>, <span class="st">'year'</span>], keep<span class="op">=</span><span class="st">'first'</span>)</span>
<span id="cb110-15"><a href="#cb110-15" aria-hidden="true" tabindex="-1"></a>pivoted <span class="op">=</span> building_all.pivot(index<span class="op">=</span><span class="st">'acct'</span>, columns<span class="op">=</span><span class="st">'year'</span>)</span>
<span id="cb110-16"><a href="#cb110-16" aria-hidden="true" tabindex="-1"></a>pivoted.columns <span class="op">=</span> [<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> col, year <span class="kw">in</span> pivoted.columns]</span>
<span id="cb110-17"><a href="#cb110-17" aria-hidden="true" tabindex="-1"></a>pivoted <span class="op">=</span> pivoted.reset_index()</span>
<span id="cb110-18"><a href="#cb110-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-19"><a href="#cb110-19" aria-hidden="true" tabindex="-1"></a>train <span class="op">=</span> pd.read_csv(folder_path <span class="op">+</span> <span class="st">'assessment_history_train.csv'</span>)</span>
<span id="cb110-20"><a href="#cb110-20" aria-hidden="true" tabindex="-1"></a>test <span class="op">=</span> pd.read_csv(folder_path <span class="op">+</span> <span class="st">'assessment_history_test.csv'</span>)</span>
<span id="cb110-21"><a href="#cb110-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-22"><a href="#cb110-22" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> train.merge(pivoted, on<span class="op">=</span><span class="st">'acct'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb110-23"><a href="#cb110-23" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> test.merge(pivoted, on<span class="op">=</span><span class="st">'acct'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="ec9023e6" class="cell" data-execution_count="111">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb111"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a>acct_test <span class="op">=</span> test_merged[[<span class="st">'acct'</span>]].copy() <span class="cf">if</span> <span class="st">'acct'</span> <span class="kw">in</span> test_merged.columns <span class="cf">else</span> <span class="va">None</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="a2f01acc" class="cell" data-execution_count="112">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb112"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> optuna</span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> logging</span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> root_mean_squared_error</span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true" tabindex="-1"></a><span class="co"># === Setup Logging ===</span></span>
<span id="cb112-9"><a href="#cb112-9" aria-hidden="true" tabindex="-1"></a>logging.basicConfig(level<span class="op">=</span>logging.INFO, <span class="bu">format</span><span class="op">=</span><span class="st">"</span><span class="sc">%(asctime)s</span><span class="st"> [</span><span class="sc">%(levelname)s</span><span class="st">] </span><span class="sc">%(message)s</span><span class="st">"</span>)</span>
<span id="cb112-10"><a href="#cb112-10" aria-hidden="true" tabindex="-1"></a>logger <span class="op">=</span> logging.getLogger(<span class="st">"OptunaBlender"</span>)</span>
<span id="cb112-11"><a href="#cb112-11" aria-hidden="true" tabindex="-1"></a>optuna.logging.set_verbosity(optuna.logging.INFO)</span>
<span id="cb112-12"><a href="#cb112-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-13"><a href="#cb112-13" aria-hidden="true" tabindex="-1"></a><span class="co"># === Load base model predictions ===</span></span>
<span id="cb112-14"><a href="#cb112-14" aria-hidden="true" tabindex="-1"></a>oof_xgb <span class="op">=</span> np.load(<span class="st">"oof_preds_xgbreg.npy"</span>)</span>
<span id="cb112-15"><a href="#cb112-15" aria-hidden="true" tabindex="-1"></a>ridge_oof <span class="op">=</span> np.load(<span class="st">"ridgecv_oof_preds.npy"</span>)</span>
<span id="cb112-16"><a href="#cb112-16" aria-hidden="true" tabindex="-1"></a>oof_lgb<span class="op">=</span>np.load(<span class="st">"oof_preds_lgbm.npy"</span>)</span>
<span id="cb112-17"><a href="#cb112-17" aria-hidden="true" tabindex="-1"></a>test_xgb <span class="op">=</span> np.load(<span class="st">"test_preds_xgbreg.npy"</span>)</span>
<span id="cb112-18"><a href="#cb112-18" aria-hidden="true" tabindex="-1"></a>ridge_test_preds <span class="op">=</span> np.load(<span class="st">"ridgecv_test_preds.npy"</span>)</span>
<span id="cb112-19"><a href="#cb112-19" aria-hidden="true" tabindex="-1"></a>test_lgb<span class="op">=</span>np.load(<span class="st">"test_preds_lgbm_shap.npy"</span>)</span>
<span id="cb112-20"><a href="#cb112-20" aria-hidden="true" tabindex="-1"></a><span class="co"># === Targets and prediction stack ===</span></span>
<span id="cb112-21"><a href="#cb112-21" aria-hidden="true" tabindex="-1"></a>y_meta <span class="op">=</span> train[<span class="st">'TARGET'</span>].values</span>
<span id="cb112-22"><a href="#cb112-22" aria-hidden="true" tabindex="-1"></a>X_base <span class="op">=</span> np.vstack([oof_xgb, ridge_oof,oof_lgb]).T</span>
<span id="cb112-23"><a href="#cb112-23" aria-hidden="true" tabindex="-1"></a>X_test_base <span class="op">=</span> np.vstack([test_xgb, ridge_test_preds,test_lgb]).T</span>
<span id="cb112-24"><a href="#cb112-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-25"><a href="#cb112-25" aria-hidden="true" tabindex="-1"></a><span class="co"># === Holdout split ===</span></span>
<span id="cb112-26"><a href="#cb112-26" aria-hidden="true" tabindex="-1"></a>X_train, X_holdout, y_train, y_holdout <span class="op">=</span> train_test_split(X_base, y_meta, test_size<span class="op">=</span><span class="fl">0.2</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb112-27"><a href="#cb112-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-28"><a href="#cb112-28" aria-hidden="true" tabindex="-1"></a><span class="co"># === Objective Function ===</span></span>
<span id="cb112-29"><a href="#cb112-29" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> objective(trial):</span>
<span id="cb112-30"><a href="#cb112-30" aria-hidden="true" tabindex="-1"></a>    weights <span class="op">=</span> [trial.suggest_float(<span class="ss">f"w</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">"</span>, <span class="dv">0</span>, <span class="dv">1</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(X_train.shape[<span class="dv">1</span>])]</span>
<span id="cb112-31"><a href="#cb112-31" aria-hidden="true" tabindex="-1"></a>    weights <span class="op">=</span> np.array(weights)</span>
<span id="cb112-32"><a href="#cb112-32" aria-hidden="true" tabindex="-1"></a>    weights <span class="op">/=</span> weights.<span class="bu">sum</span>()  <span class="co"># normalize</span></span>
<span id="cb112-33"><a href="#cb112-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-34"><a href="#cb112-34" aria-hidden="true" tabindex="-1"></a>    preds <span class="op">=</span> X_holdout <span class="op">@</span> weights</span>
<span id="cb112-35"><a href="#cb112-35" aria-hidden="true" tabindex="-1"></a>    rmse <span class="op">=</span> root_mean_squared_error(y_holdout, preds)</span>
<span id="cb112-36"><a href="#cb112-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-37"><a href="#cb112-37" aria-hidden="true" tabindex="-1"></a>    logger.info(<span class="ss">f"Trial </span><span class="sc">{</span>trial<span class="sc">.</span>number<span class="sc">}</span><span class="ss"> | Weights: </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">round</span>(weights, <span class="dv">3</span>)<span class="sc">.</span>tolist()<span class="sc">}</span><span class="ss"> | RMSE: </span><span class="sc">{</span>rmse<span class="sc">:,.4f}</span><span class="ss">"</span>)</span>
<span id="cb112-38"><a href="#cb112-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> rmse</span>
<span id="cb112-39"><a href="#cb112-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-40"><a href="#cb112-40" aria-hidden="true" tabindex="-1"></a><span class="co"># === Run Study ===</span></span>
<span id="cb112-41"><a href="#cb112-41" aria-hidden="true" tabindex="-1"></a>logger.info(<span class="st">" Starting Optuna optimization for weighted blending..."</span>)</span>
<span id="cb112-42"><a href="#cb112-42" aria-hidden="true" tabindex="-1"></a>study <span class="op">=</span> optuna.create_study(direction<span class="op">=</span><span class="st">"minimize"</span>)</span>
<span id="cb112-43"><a href="#cb112-43" aria-hidden="true" tabindex="-1"></a>study.optimize(objective, n_trials<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb112-44"><a href="#cb112-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-45"><a href="#cb112-45" aria-hidden="true" tabindex="-1"></a><span class="co"># === Best weights ===</span></span>
<span id="cb112-46"><a href="#cb112-46" aria-hidden="true" tabindex="-1"></a>best_weights <span class="op">=</span> np.array([study.best_trial.params[<span class="ss">f"w</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">"</span>] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(X_base.shape[<span class="dv">1</span>])])</span>
<span id="cb112-47"><a href="#cb112-47" aria-hidden="true" tabindex="-1"></a>best_weights <span class="op">/=</span> best_weights.<span class="bu">sum</span>()</span>
<span id="cb112-48"><a href="#cb112-48" aria-hidden="true" tabindex="-1"></a>logger.info(<span class="ss">f" Best weights: </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">round</span>(best_weights, <span class="dv">4</span>)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb112-49"><a href="#cb112-49" aria-hidden="true" tabindex="-1"></a>logger.info(<span class="ss">f" Best RMSE: </span><span class="sc">{</span>study<span class="sc">.</span>best_value<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb112-50"><a href="#cb112-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-51"><a href="#cb112-51" aria-hidden="true" tabindex="-1"></a><span class="co"># === Final test prediction ===</span></span>
<span id="cb112-52"><a href="#cb112-52" aria-hidden="true" tabindex="-1"></a>meta_preds <span class="op">=</span> X_test_base <span class="op">@</span> best_weights</span>
<span id="cb112-53"><a href="#cb112-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-54"><a href="#cb112-54" aria-hidden="true" tabindex="-1"></a><span class="co"># === Save predictions ===</span></span>
<span id="cb112-55"><a href="#cb112-55" aria-hidden="true" tabindex="-1"></a>np.save(<span class="st">"test_preds_optuna_blended.npy"</span>, meta_preds)</span>
<span id="cb112-56"><a href="#cb112-56" aria-hidden="true" tabindex="-1"></a>account_ids <span class="op">=</span> acct_test.values.ravel()</span>
<span id="cb112-57"><a href="#cb112-57" aria-hidden="true" tabindex="-1"></a>submission <span class="op">=</span> pd.DataFrame({</span>
<span id="cb112-58"><a href="#cb112-58" aria-hidden="true" tabindex="-1"></a>    <span class="st">"ACCOUNT"</span>: account_ids,</span>
<span id="cb112-59"><a href="#cb112-59" aria-hidden="true" tabindex="-1"></a>    <span class="st">"TARGET"</span>: meta_preds</span>
<span id="cb112-60"><a href="#cb112-60" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb112-61"><a href="#cb112-61" aria-hidden="true" tabindex="-1"></a>submission.to_csv(<span class="st">"submission_optuna_blended.csv"</span>, index<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb112-62"><a href="#cb112-62" aria-hidden="true" tabindex="-1"></a>logger.info(<span class="st">" Saved: test_preds_optuna_blended.npy and submission_optuna_blended.csv"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="d1791605" class="cell" data-execution_count="113">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb113"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> ElasticNetCV</span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.pipeline <span class="im">import</span> make_pipeline</span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> root_mean_squared_error</span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a><span class="co"># === Load OOF + Test Predictions ===</span></span>
<span id="cb113-9"><a href="#cb113-9" aria-hidden="true" tabindex="-1"></a>oof_xgb <span class="op">=</span> np.load(<span class="st">"oof_preds_xgbreg.npy"</span>)</span>
<span id="cb113-10"><a href="#cb113-10" aria-hidden="true" tabindex="-1"></a>test_xgb <span class="op">=</span> np.load(<span class="st">"test_preds_xgbreg.npy"</span>)</span>
<span id="cb113-11"><a href="#cb113-11" aria-hidden="true" tabindex="-1"></a>ridge_oof<span class="op">=</span>np.load(<span class="st">"ridgecv_oof_preds.npy"</span>)</span>
<span id="cb113-12"><a href="#cb113-12" aria-hidden="true" tabindex="-1"></a>ridge_test_preds<span class="op">=</span>np.load(<span class="st">"ridgecv_test_preds.npy"</span>)</span>
<span id="cb113-13"><a href="#cb113-13" aria-hidden="true" tabindex="-1"></a>oof_lgb<span class="op">=</span>np.load(<span class="st">"oof_preds_lgbm.npy"</span>)</span>
<span id="cb113-14"><a href="#cb113-14" aria-hidden="true" tabindex="-1"></a>test_lgb<span class="op">=</span>np.load(<span class="st">"test_preds_lgbm_shap.npy"</span>)</span>
<span id="cb113-15"><a href="#cb113-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-16"><a href="#cb113-16" aria-hidden="true" tabindex="-1"></a><span class="co"># === 3. Combine full meta-input feature set ===</span></span>
<span id="cb113-17"><a href="#cb113-17" aria-hidden="true" tabindex="-1"></a>X_meta <span class="op">=</span> np.hstack([</span>
<span id="cb113-18"><a href="#cb113-18" aria-hidden="true" tabindex="-1"></a>    oof_xgb.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>),</span>
<span id="cb113-19"><a href="#cb113-19" aria-hidden="true" tabindex="-1"></a>    ridge_oof.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>),</span>
<span id="cb113-20"><a href="#cb113-20" aria-hidden="true" tabindex="-1"></a>    oof_lgb.reshape(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>)</span>
<span id="cb113-21"><a href="#cb113-21" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb113-22"><a href="#cb113-22" aria-hidden="true" tabindex="-1"></a>y_meta <span class="op">=</span> train[<span class="st">'TARGET'</span>].values</span>
<span id="cb113-23"><a href="#cb113-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-24"><a href="#cb113-24" aria-hidden="true" tabindex="-1"></a>X_meta_test <span class="op">=</span> np.hstack([</span>
<span id="cb113-25"><a href="#cb113-25" aria-hidden="true" tabindex="-1"></a>    test_xgb.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>),</span>
<span id="cb113-26"><a href="#cb113-26" aria-hidden="true" tabindex="-1"></a>    ridge_test_preds.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>),</span>
<span id="cb113-27"><a href="#cb113-27" aria-hidden="true" tabindex="-1"></a>    test_lgb.reshape(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>)</span>
<span id="cb113-28"><a href="#cb113-28" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb113-29"><a href="#cb113-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-30"><a href="#cb113-30" aria-hidden="true" tabindex="-1"></a><span class="co"># === 4. Train ElasticNetCV meta-learner ===</span></span>
<span id="cb113-31"><a href="#cb113-31" aria-hidden="true" tabindex="-1"></a>meta_model <span class="op">=</span> make_pipeline(</span>
<span id="cb113-32"><a href="#cb113-32" aria-hidden="true" tabindex="-1"></a>    StandardScaler(),</span>
<span id="cb113-33"><a href="#cb113-33" aria-hidden="true" tabindex="-1"></a>    ElasticNetCV(</span>
<span id="cb113-34"><a href="#cb113-34" aria-hidden="true" tabindex="-1"></a>        l1_ratio<span class="op">=</span>[<span class="fl">0.1</span>, <span class="fl">0.5</span>, <span class="fl">0.9</span>, <span class="dv">1</span>],</span>
<span id="cb113-35"><a href="#cb113-35" aria-hidden="true" tabindex="-1"></a>        alphas<span class="op">=</span>np.logspace(<span class="op">-</span><span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">100</span>),</span>
<span id="cb113-36"><a href="#cb113-36" aria-hidden="true" tabindex="-1"></a>        cv<span class="op">=</span><span class="dv">3</span>,</span>
<span id="cb113-37"><a href="#cb113-37" aria-hidden="true" tabindex="-1"></a>        max_iter<span class="op">=</span><span class="dv">5000</span>,</span>
<span id="cb113-38"><a href="#cb113-38" aria-hidden="true" tabindex="-1"></a>        n_jobs<span class="op">=-</span><span class="dv">1</span></span>
<span id="cb113-39"><a href="#cb113-39" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb113-40"><a href="#cb113-40" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb113-41"><a href="#cb113-41" aria-hidden="true" tabindex="-1"></a>meta_model.fit(X_meta, y_meta)</span>
<span id="cb113-42"><a href="#cb113-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-43"><a href="#cb113-43" aria-hidden="true" tabindex="-1"></a><span class="co"># === 5. Predict and evaluate (optional holdout split) ===</span></span>
<span id="cb113-44"><a href="#cb113-44" aria-hidden="true" tabindex="-1"></a><span class="co"># You can skip this section if you're blending on full train</span></span>
<span id="cb113-45"><a href="#cb113-45" aria-hidden="true" tabindex="-1"></a>X_train, X_holdout, y_train, y_holdout <span class="op">=</span> train_test_split(X_meta, y_meta, test_size<span class="op">=</span><span class="fl">0.2</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb113-46"><a href="#cb113-46" aria-hidden="true" tabindex="-1"></a>meta_model.fit(X_train, y_train)</span>
<span id="cb113-47"><a href="#cb113-47" aria-hidden="true" tabindex="-1"></a>holdout_preds <span class="op">=</span> meta_model.predict(X_holdout)</span>
<span id="cb113-48"><a href="#cb113-48" aria-hidden="true" tabindex="-1"></a>rmse <span class="op">=</span> root_mean_squared_error(y_holdout, holdout_preds)</span>
<span id="cb113-49"><a href="#cb113-49" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"ElasticNetCV Blended Meta Holdout RMSE: </span><span class="sc">{</span>rmse<span class="sc">:,.2f}</span><span class="ss">"</span>)</span>
<span id="cb113-50"><a href="#cb113-50" aria-hidden="true" tabindex="-1"></a>best_alpha <span class="op">=</span> meta_model.named_steps[<span class="st">'elasticnetcv'</span>].alpha_</span>
<span id="cb113-51"><a href="#cb113-51" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" Best alpha selected: </span><span class="sc">{</span>best_alpha<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb113-52"><a href="#cb113-52" aria-hidden="true" tabindex="-1"></a><span class="co"># === 6. Final predictions for test set ===</span></span>
<span id="cb113-53"><a href="#cb113-53" aria-hidden="true" tabindex="-1"></a>meta_preds <span class="op">=</span> meta_model.predict(X_meta_test)</span>
<span id="cb113-54"><a href="#cb113-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-55"><a href="#cb113-55" aria-hidden="true" tabindex="-1"></a><span class="co"># === 7. Save blended test predictions ===</span></span>
<span id="cb113-56"><a href="#cb113-56" aria-hidden="true" tabindex="-1"></a>np.save(<span class="st">"test_preds_elasticnet_blended.npy"</span>, meta_preds)</span>
<span id="cb113-57"><a href="#cb113-57" aria-hidden="true" tabindex="-1"></a>account_ids <span class="op">=</span> acct_test.values.ravel() </span>
<span id="cb113-58"><a href="#cb113-58" aria-hidden="true" tabindex="-1"></a>submission <span class="op">=</span> pd.DataFrame({</span>
<span id="cb113-59"><a href="#cb113-59" aria-hidden="true" tabindex="-1"></a>    <span class="st">"ACCOUNT"</span>: account_ids,  <span class="co"># Replace with your actual ID column</span></span>
<span id="cb113-60"><a href="#cb113-60" aria-hidden="true" tabindex="-1"></a>    <span class="st">"TARGET"</span>: meta_preds</span>
<span id="cb113-61"><a href="#cb113-61" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb113-62"><a href="#cb113-62" aria-hidden="true" tabindex="-1"></a>submission.to_csv(<span class="st">"submission_elasticnet_blended.csv"</span>, index<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb113-63"><a href="#cb113-63" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" ElasticNetCV blended stacking submission saved."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb114" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "STA 9890 Project: Property Valuation"</span></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span><span class="co"> </span></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a><span class="co">  html:</span></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a><span class="co">    code-fold: true  # collapses code blocks by default</span></span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a><span class="co">    code-tools: true # adds copy/download buttons</span></span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a><span class="an">execute:</span></span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a><span class="co">  echo: true         # show code</span></span>
<span id="cb114-9"><a href="#cb114-9" aria-hidden="true" tabindex="-1"></a><span class="co">  output: true       # show output</span></span>
<span id="cb114-10"><a href="#cb114-10" aria-hidden="true" tabindex="-1"></a><span class="co">  eval: false       </span></span>
<span id="cb114-11"><a href="#cb114-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-12"><a href="#cb114-12" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb114-13"><a href="#cb114-13" aria-hidden="true" tabindex="-1"></a><span class="fu">## üìÑ Full Report</span></span>
<span id="cb114-14"><a href="#cb114-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-15"><a href="#cb114-15" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">Download the full PDF report</span><span class="co">](files/9890_Final_Report.pdf)</span></span>
<span id="cb114-16"><a href="#cb114-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-17"><a href="#cb114-17" aria-hidden="true" tabindex="-1"></a><span class="fu">## üîç Summary</span></span>
<span id="cb114-18"><a href="#cb114-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-19"><a href="#cb114-19" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Task**: Predict 2019 assessed property value using structured property records from 2015‚Äì2019</span>
<span id="cb114-20"><a href="#cb114-20" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Models**: RidgeCV, XGBoost, LightGBM</span>
<span id="cb114-21"><a href="#cb114-21" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Feature Selection**: SHAP + Gain union</span>
<span id="cb114-22"><a href="#cb114-22" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Ensembling**: Optuna weights + ElasticNet stacked</span>
<span id="cb114-23"><a href="#cb114-23" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Top RMSE**: 36,021 on private leaderboard (ElasticNet ensemble)</span>
<span id="cb114-24"><a href="#cb114-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-25"><a href="#cb114-25" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb114-26"><a href="#cb114-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-27"><a href="#cb114-27" aria-hidden="true" tabindex="-1"></a><span class="fu">## üöÄ Full Modeling Pipeline</span></span>
<span id="cb114-28"><a href="#cb114-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-29"><a href="#cb114-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-30"><a href="#cb114-30" aria-hidden="true" tabindex="-1"></a><span class="fu"># Ridge Regression Pipeline</span></span>
<span id="cb114-31"><a href="#cb114-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-34"><a href="#cb114-34" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-35"><a href="#cb114-35" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb114-36"><a href="#cb114-36" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb114-37"><a href="#cb114-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-38"><a href="#cb114-38" aria-hidden="true" tabindex="-1"></a><span class="co"># ===== Load Data =====</span></span>
<span id="cb114-39"><a href="#cb114-39" aria-hidden="true" tabindex="-1"></a>folder_path <span class="op">=</span> <span class="st">'/Users/Srijith97/Downloads/STA 9890 Housing Data/'</span></span>
<span id="cb114-40"><a href="#cb114-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-41"><a href="#cb114-41" aria-hidden="true" tabindex="-1"></a>building_years <span class="op">=</span> []</span>
<span id="cb114-42"><a href="#cb114-42" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>):</span>
<span id="cb114-43"><a href="#cb114-43" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.read_csv(folder_path <span class="op">+</span> <span class="ss">f'building_details_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">.csv'</span>)</span>
<span id="cb114-44"><a href="#cb114-44" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'year'</span>] <span class="op">=</span> year</span>
<span id="cb114-45"><a href="#cb114-45" aria-hidden="true" tabindex="-1"></a>    building_years.append(df)</span>
<span id="cb114-46"><a href="#cb114-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-47"><a href="#cb114-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-48"><a href="#cb114-48" aria-hidden="true" tabindex="-1"></a>building_all <span class="op">=</span> pd.concat(building_years, ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-49"><a href="#cb114-49" aria-hidden="true" tabindex="-1"></a>building_all <span class="op">=</span> building_all.drop_duplicates(subset<span class="op">=</span>[<span class="st">'acct'</span>, <span class="st">'year'</span>], keep<span class="op">=</span><span class="st">'first'</span>)</span>
<span id="cb114-50"><a href="#cb114-50" aria-hidden="true" tabindex="-1"></a>pivoted <span class="op">=</span> building_all.pivot(index<span class="op">=</span><span class="st">'acct'</span>, columns<span class="op">=</span><span class="st">'year'</span>)</span>
<span id="cb114-51"><a href="#cb114-51" aria-hidden="true" tabindex="-1"></a>pivoted.columns <span class="op">=</span> [<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> col, year <span class="kw">in</span> pivoted.columns]</span>
<span id="cb114-52"><a href="#cb114-52" aria-hidden="true" tabindex="-1"></a>pivoted <span class="op">=</span> pivoted.reset_index()</span>
<span id="cb114-53"><a href="#cb114-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-54"><a href="#cb114-54" aria-hidden="true" tabindex="-1"></a>train <span class="op">=</span> pd.read_csv(folder_path <span class="op">+</span> <span class="st">'assessment_history_train.csv'</span>)</span>
<span id="cb114-55"><a href="#cb114-55" aria-hidden="true" tabindex="-1"></a>test <span class="op">=</span> pd.read_csv(folder_path <span class="op">+</span> <span class="st">'assessment_history_test.csv'</span>)</span>
<span id="cb114-56"><a href="#cb114-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-57"><a href="#cb114-57" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> train.merge(pivoted, on<span class="op">=</span><span class="st">'acct'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb114-58"><a href="#cb114-58" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> test.merge(pivoted, on<span class="op">=</span><span class="st">'acct'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb114-59"><a href="#cb114-59" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-60"><a href="#cb114-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-63"><a href="#cb114-63" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-64"><a href="#cb114-64" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1: Identify all '2019' columns in train</span></span>
<span id="cb114-65"><a href="#cb114-65" aria-hidden="true" tabindex="-1"></a>train_2019_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> <span class="st">'2019'</span> <span class="kw">in</span> col]</span>
<span id="cb114-66"><a href="#cb114-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-67"><a href="#cb114-67" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 2: Find which 2019 columns are missing in test</span></span>
<span id="cb114-68"><a href="#cb114-68" aria-hidden="true" tabindex="-1"></a>train_only_2019_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_2019_cols <span class="cf">if</span> col <span class="kw">not</span> <span class="kw">in</span> test_merged.columns]</span>
<span id="cb114-69"><a href="#cb114-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-70"><a href="#cb114-70" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 3: Always drop 'protested_2019' due to leakage risk</span></span>
<span id="cb114-71"><a href="#cb114-71" aria-hidden="true" tabindex="-1"></a>train_only_2019_cols.append(<span class="st">'protested_2019'</span>)</span>
<span id="cb114-72"><a href="#cb114-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-73"><a href="#cb114-73" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 4: Drop the identified columns from train</span></span>
<span id="cb114-74"><a href="#cb114-74" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> train_merged.drop(columns<span class="op">=</span>train_only_2019_cols, errors<span class="op">=</span><span class="st">'ignore'</span>)</span>
<span id="cb114-75"><a href="#cb114-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-76"><a href="#cb114-76" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 5: Optional logging</span></span>
<span id="cb114-77"><a href="#cb114-77" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Dropped </span><span class="sc">{</span><span class="bu">len</span>(train_only_2019_cols)<span class="sc">}</span><span class="ss"> columns from train (including protested_2019 if present):"</span>)</span>
<span id="cb114-78"><a href="#cb114-78" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(train_only_2019_cols)</span>
<span id="cb114-79"><a href="#cb114-79" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-80"><a href="#cb114-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-83"><a href="#cb114-83" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-84"><a href="#cb114-84" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb114-85"><a href="#cb114-85" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'protested_2019'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb114-86"><a href="#cb114-86" aria-hidden="true" tabindex="-1"></a>        df.drop(columns<span class="op">=</span><span class="st">'protested_2019'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-87"><a href="#cb114-87" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Dropped 'protested_2019' from </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-88"><a href="#cb114-88" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb114-89"><a href="#cb114-89" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"'protested_2019' not found in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-90"><a href="#cb114-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-91"><a href="#cb114-91" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-92"><a href="#cb114-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-95"><a href="#cb114-95" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-96"><a href="#cb114-96" aria-hidden="true" tabindex="-1"></a><span class="co">## Get all '2019' columns in train and test</span></span>
<span id="cb114-97"><a href="#cb114-97" aria-hidden="true" tabindex="-1"></a>train_2019_cols <span class="op">=</span> <span class="bu">sorted</span>([col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> <span class="st">'2019'</span> <span class="kw">in</span> col])</span>
<span id="cb114-98"><a href="#cb114-98" aria-hidden="true" tabindex="-1"></a>test_2019_cols <span class="op">=</span> <span class="bu">sorted</span>([col <span class="cf">for</span> col <span class="kw">in</span> test_merged.columns <span class="cf">if</span> <span class="st">'2019'</span> <span class="kw">in</span> col])</span>
<span id="cb114-99"><a href="#cb114-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-100"><a href="#cb114-100" aria-hidden="true" tabindex="-1"></a><span class="co"># Print train columns</span></span>
<span id="cb114-101"><a href="#cb114-101" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"2019 Columns in train_merged:"</span>)</span>
<span id="cb114-102"><a href="#cb114-102" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> train_2019_cols:</span>
<span id="cb114-103"><a href="#cb114-103" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" - </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-104"><a href="#cb114-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-105"><a href="#cb114-105" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> 2019 Columns in test_merged:"</span>)</span>
<span id="cb114-106"><a href="#cb114-106" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> test_2019_cols:</span>
<span id="cb114-107"><a href="#cb114-107" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" - </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-108"><a href="#cb114-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-109"><a href="#cb114-109" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-110"><a href="#cb114-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-113"><a href="#cb114-113" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-114"><a href="#cb114-114" aria-hidden="true" tabindex="-1"></a><span class="co"># Compare sets</span></span>
<span id="cb114-115"><a href="#cb114-115" aria-hidden="true" tabindex="-1"></a>train_only_2019 <span class="op">=</span> <span class="bu">sorted</span>(<span class="bu">list</span>(<span class="bu">set</span>(train_2019_cols) <span class="op">-</span> <span class="bu">set</span>(test_2019_cols)))</span>
<span id="cb114-116"><a href="#cb114-116" aria-hidden="true" tabindex="-1"></a>test_only_2019 <span class="op">=</span> <span class="bu">sorted</span>(<span class="bu">list</span>(<span class="bu">set</span>(test_2019_cols) <span class="op">-</span> <span class="bu">set</span>(train_2019_cols)))</span>
<span id="cb114-117"><a href="#cb114-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-118"><a href="#cb114-118" aria-hidden="true" tabindex="-1"></a><span class="co"># Print comparison result</span></span>
<span id="cb114-119"><a href="#cb114-119" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> train_only_2019 <span class="kw">and</span> <span class="kw">not</span> test_only_2019:</span>
<span id="cb114-120"><a href="#cb114-120" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> All 2019 columns match between train_merged and test_merged."</span>)</span>
<span id="cb114-121"><a href="#cb114-121" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb114-122"><a href="#cb114-122" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> Mismatched 2019 columns found:"</span>)</span>
<span id="cb114-123"><a href="#cb114-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-124"><a href="#cb114-124" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> train_only_2019:</span>
<span id="cb114-125"><a href="#cb114-125" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">" In train_merged but not in test_merged:"</span>)</span>
<span id="cb114-126"><a href="#cb114-126" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> col <span class="kw">in</span> train_only_2019:</span>
<span id="cb114-127"><a href="#cb114-127" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"   - </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-128"><a href="#cb114-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-129"><a href="#cb114-129" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> test_only_2019:</span>
<span id="cb114-130"><a href="#cb114-130" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">" In test_merged but not in train_merged:"</span>)</span>
<span id="cb114-131"><a href="#cb114-131" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> col <span class="kw">in</span> test_only_2019:</span>
<span id="cb114-132"><a href="#cb114-132" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"   - </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-133"><a href="#cb114-133" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-134"><a href="#cb114-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-137"><a href="#cb114-137" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-138"><a href="#cb114-138" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1: Store target separately</span></span>
<span id="cb114-139"><a href="#cb114-139" aria-hidden="true" tabindex="-1"></a>y_train <span class="op">=</span> train_merged[<span class="st">"TARGET"</span>].values</span>
<span id="cb114-140"><a href="#cb114-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-141"><a href="#cb114-141" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 4: Confirm sizes</span></span>
<span id="cb114-142"><a href="#cb114-142" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Train shape: </span><span class="sc">{</span>train<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-143"><a href="#cb114-143" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Test shape: </span><span class="sc">{</span>test<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-144"><a href="#cb114-144" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-145"><a href="#cb114-145" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-146"><a href="#cb114-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-149"><a href="#cb114-149" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-150"><a href="#cb114-150" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate % of missing values in each column of TRAIN only</span></span>
<span id="cb114-151"><a href="#cb114-151" aria-hidden="true" tabindex="-1"></a>train_na <span class="op">=</span> (train_merged.isnull().<span class="bu">sum</span>() <span class="op">/</span> train_merged.shape[<span class="dv">0</span>]) <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb114-152"><a href="#cb114-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-153"><a href="#cb114-153" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop columns with no missing values, sort the rest</span></span>
<span id="cb114-154"><a href="#cb114-154" aria-hidden="true" tabindex="-1"></a>train_na <span class="op">=</span> train_na[train_na <span class="op">&gt;</span> <span class="dv">0</span>].sort_values(ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb114-155"><a href="#cb114-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-156"><a href="#cb114-156" aria-hidden="true" tabindex="-1"></a><span class="co"># Optional: Show top 200 missing features</span></span>
<span id="cb114-157"><a href="#cb114-157" aria-hidden="true" tabindex="-1"></a>missing_data <span class="op">=</span> pd.DataFrame({<span class="st">'Missing Ratio (%)'</span>: train_na})</span>
<span id="cb114-158"><a href="#cb114-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-159"><a href="#cb114-159" aria-hidden="true" tabindex="-1"></a><span class="co"># Display</span></span>
<span id="cb114-160"><a href="#cb114-160" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Top columns with missing data (based on training set only):"</span>)</span>
<span id="cb114-161"><a href="#cb114-161" aria-hidden="true" tabindex="-1"></a>missing_data.head(<span class="dv">20</span>)</span>
<span id="cb114-162"><a href="#cb114-162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-163"><a href="#cb114-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-164"><a href="#cb114-164" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-165"><a href="#cb114-165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-168"><a href="#cb114-168" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-169"><a href="#cb114-169" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_floor_area_totals(df, years):</span>
<span id="cb114-170"><a href="#cb114-170" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> y <span class="kw">in</span> years:</span>
<span id="cb114-171"><a href="#cb114-171" aria-hidden="true" tabindex="-1"></a>        primary_col <span class="op">=</span> <span class="ss">f'floor_area_primary_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">'</span></span>
<span id="cb114-172"><a href="#cb114-172" aria-hidden="true" tabindex="-1"></a>        upper_col   <span class="op">=</span> <span class="ss">f'floor_area_upper_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">'</span></span>
<span id="cb114-173"><a href="#cb114-173" aria-hidden="true" tabindex="-1"></a>        lower_col   <span class="op">=</span> <span class="ss">f'floor_area_lower_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">'</span></span>
<span id="cb114-174"><a href="#cb114-174" aria-hidden="true" tabindex="-1"></a>        total_col   <span class="op">=</span> <span class="ss">f'floor_area_total_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">'</span></span>
<span id="cb114-175"><a href="#cb114-175" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-176"><a href="#cb114-176" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">all</span>(col <span class="kw">in</span> df.columns <span class="cf">for</span> col <span class="kw">in</span> [primary_col, upper_col, lower_col]):</span>
<span id="cb114-177"><a href="#cb114-177" aria-hidden="true" tabindex="-1"></a>            df[total_col] <span class="op">=</span> (</span>
<span id="cb114-178"><a href="#cb114-178" aria-hidden="true" tabindex="-1"></a>                df[primary_col].fillna(<span class="dv">0</span>) <span class="op">+</span></span>
<span id="cb114-179"><a href="#cb114-179" aria-hidden="true" tabindex="-1"></a>                df[upper_col].fillna(<span class="dv">0</span>) <span class="op">+</span></span>
<span id="cb114-180"><a href="#cb114-180" aria-hidden="true" tabindex="-1"></a>                df[lower_col].fillna(<span class="dv">0</span>)</span>
<span id="cb114-181"><a href="#cb114-181" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb114-182"><a href="#cb114-182" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Created: </span><span class="sc">{</span>total_col<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-183"><a href="#cb114-183" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb114-184"><a href="#cb114-184" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipping </span><span class="sc">{</span>total_col<span class="sc">}</span><span class="ss"> ‚Äî one or more components missing."</span>)</span>
<span id="cb114-185"><a href="#cb114-185" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb114-186"><a href="#cb114-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-187"><a href="#cb114-187" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply for years 2015‚Äì2019</span></span>
<span id="cb114-188"><a href="#cb114-188" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2015'</span>, <span class="st">'2016'</span>, <span class="st">'2017'</span>, <span class="st">'2018'</span>, <span class="st">'2019'</span>]</span>
<span id="cb114-189"><a href="#cb114-189" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> create_floor_area_totals(train_merged, years)</span>
<span id="cb114-190"><a href="#cb114-190" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> create_floor_area_totals(test_merged, years)</span>
<span id="cb114-191"><a href="#cb114-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-192"><a href="#cb114-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-193"><a href="#cb114-193" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-194"><a href="#cb114-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-197"><a href="#cb114-197" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-198"><a href="#cb114-198" aria-hidden="true" tabindex="-1"></a>zero_pct <span class="op">=</span> (train_merged[<span class="st">'mobile_home_area_2015'</span>] <span class="op">==</span> <span class="dv">0</span>).mean() <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb114-199"><a href="#cb114-199" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" mobile_home_area_2015 is 0 in </span><span class="sc">{</span>zero_pct<span class="sc">:.2f}</span><span class="ss">% of training rows"</span>)</span>
<span id="cb114-200"><a href="#cb114-200" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-201"><a href="#cb114-201" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-202"><a href="#cb114-202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-205"><a href="#cb114-205" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-206"><a href="#cb114-206" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> col.startswith(<span class="st">"mobile_home_area"</span>)]</span>
<span id="cb114-207"><a href="#cb114-207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-208"><a href="#cb114-208" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop from both sets</span></span>
<span id="cb114-209"><a href="#cb114-209" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-210"><a href="#cb114-210" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-211"><a href="#cb114-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-212"><a href="#cb114-212" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" Dropped columns from train/test: </span><span class="sc">{</span>cols_to_drop<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-213"><a href="#cb114-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-214"><a href="#cb114-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-215"><a href="#cb114-215" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-216"><a href="#cb114-216" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-219"><a href="#cb114-219" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-220"><a href="#cb114-220" aria-hidden="true" tabindex="-1"></a>zero_pct <span class="op">=</span> (train_merged[<span class="st">'deck_area_2015'</span>] <span class="op">==</span> <span class="dv">0</span>).mean() <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb114-221"><a href="#cb114-221" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" deck_area_2015 is 0 in </span><span class="sc">{</span>zero_pct<span class="sc">:.2f}</span><span class="ss">% of training rows"</span>)</span>
<span id="cb114-222"><a href="#cb114-222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-223"><a href="#cb114-223" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-224"><a href="#cb114-224" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-225"><a href="#cb114-225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-228"><a href="#cb114-228" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-229"><a href="#cb114-229" aria-hidden="true" tabindex="-1"></a><span class="co"># Use training columns to identify which deck_area columns exist</span></span>
<span id="cb114-230"><a href="#cb114-230" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> col.startswith(<span class="st">"deck_area"</span>)]</span>
<span id="cb114-231"><a href="#cb114-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-232"><a href="#cb114-232" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop those columns from both datasets</span></span>
<span id="cb114-233"><a href="#cb114-233" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-234"><a href="#cb114-234" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-235"><a href="#cb114-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-236"><a href="#cb114-236" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" Dropped columns from train/test: </span><span class="sc">{</span>cols_to_drop<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-237"><a href="#cb114-237" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-238"><a href="#cb114-238" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-239"><a href="#cb114-239" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-240"><a href="#cb114-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-243"><a href="#cb114-243" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-244"><a href="#cb114-244" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_yearly_features(df, base_features, years):</span>
<span id="cb114-245"><a href="#cb114-245" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> feature <span class="kw">in</span> base_features:</span>
<span id="cb114-246"><a href="#cb114-246" aria-hidden="true" tabindex="-1"></a>        cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb114-247"><a href="#cb114-247" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb114-248"><a href="#cb114-248" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Backfill all relevant year columns in-place</span></span>
<span id="cb114-249"><a href="#cb114-249" aria-hidden="true" tabindex="-1"></a>            df[cols] <span class="op">=</span> df[cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-250"><a href="#cb114-250" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Backfilled: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> across </span><span class="sc">{</span>cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-251"><a href="#cb114-251" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb114-252"><a href="#cb114-252" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipping </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> ‚Äî not enough year columns found."</span>)</span>
<span id="cb114-253"><a href="#cb114-253" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb114-254"><a href="#cb114-254" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-255"><a href="#cb114-255" aria-hidden="true" tabindex="-1"></a><span class="co"># Years in reverse so that bfill works from most recent (2019) to oldest (2015)</span></span>
<span id="cb114-256"><a href="#cb114-256" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb114-257"><a href="#cb114-257" aria-hidden="true" tabindex="-1"></a>features <span class="op">=</span> [<span class="st">'garage_area'</span>, <span class="st">'porch_area'</span>]</span>
<span id="cb114-258"><a href="#cb114-258" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-259"><a href="#cb114-259" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to both train and test</span></span>
<span id="cb114-260"><a href="#cb114-260" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_yearly_features(train_merged, features, years)</span>
<span id="cb114-261"><a href="#cb114-261" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_yearly_features(test_merged, features, years)</span>
<span id="cb114-262"><a href="#cb114-262" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-263"><a href="#cb114-263" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-264"><a href="#cb114-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-267"><a href="#cb114-267" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-268"><a href="#cb114-268" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_yearly_features(df, features, years):</span>
<span id="cb114-269"><a href="#cb114-269" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> feature <span class="kw">in</span> features:</span>
<span id="cb114-270"><a href="#cb114-270" aria-hidden="true" tabindex="-1"></a>        year_cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb114-271"><a href="#cb114-271" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(year_cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb114-272"><a href="#cb114-272" aria-hidden="true" tabindex="-1"></a>            df[year_cols] <span class="op">=</span> df[year_cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-273"><a href="#cb114-273" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Backfilled: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> across </span><span class="sc">{</span>year_cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-274"><a href="#cb114-274" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb114-275"><a href="#cb114-275" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipped: Not enough year columns for '</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">'"</span>)</span>
<span id="cb114-276"><a href="#cb114-276" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb114-277"><a href="#cb114-277" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-278"><a href="#cb114-278" aria-hidden="true" tabindex="-1"></a><span class="co"># Use years in reverse for proper backfill (newest to oldest)</span></span>
<span id="cb114-279"><a href="#cb114-279" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb114-280"><a href="#cb114-280" aria-hidden="true" tabindex="-1"></a>features <span class="op">=</span> [<span class="st">'floors'</span>, <span class="st">'half_bath'</span>, <span class="st">'full_bath'</span>, <span class="st">'total_rooms'</span>, <span class="st">'bedrooms'</span>]</span>
<span id="cb114-281"><a href="#cb114-281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-282"><a href="#cb114-282" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to both train and test</span></span>
<span id="cb114-283"><a href="#cb114-283" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_yearly_features(train_merged, features, years)</span>
<span id="cb114-284"><a href="#cb114-284" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_yearly_features(test_merged, features, years)</span>
<span id="cb114-285"><a href="#cb114-285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-286"><a href="#cb114-286" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-287"><a href="#cb114-287" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-288"><a href="#cb114-288" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-289"><a href="#cb114-289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-292"><a href="#cb114-292" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-293"><a href="#cb114-293" aria-hidden="true" tabindex="-1"></a><span class="co"># Identify elevator-related columns from training set</span></span>
<span id="cb114-294"><a href="#cb114-294" aria-hidden="true" tabindex="-1"></a>elevator_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> col.startswith(<span class="st">"elevator"</span>)]</span>
<span id="cb114-295"><a href="#cb114-295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-296"><a href="#cb114-296" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop from both train and test</span></span>
<span id="cb114-297"><a href="#cb114-297" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>elevator_cols, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-298"><a href="#cb114-298" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>elevator_cols, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-299"><a href="#cb114-299" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-300"><a href="#cb114-300" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"üóëÔ∏è Dropped elevator-related columns from train/test: </span><span class="sc">{</span>elevator_cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-301"><a href="#cb114-301" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-302"><a href="#cb114-302" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-303"><a href="#cb114-303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-306"><a href="#cb114-306" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-307"><a href="#cb114-307" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_year_features(df, features, years):</span>
<span id="cb114-308"><a href="#cb114-308" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> feature <span class="kw">in</span> features:</span>
<span id="cb114-309"><a href="#cb114-309" aria-hidden="true" tabindex="-1"></a>        cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb114-310"><a href="#cb114-310" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb114-311"><a href="#cb114-311" aria-hidden="true" tabindex="-1"></a>            df[cols] <span class="op">=</span> df[cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-312"><a href="#cb114-312" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Backfilled: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> across </span><span class="sc">{</span>cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-313"><a href="#cb114-313" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb114-314"><a href="#cb114-314" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipped </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> ‚Äî not enough year-based columns found."</span>)</span>
<span id="cb114-315"><a href="#cb114-315" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb114-316"><a href="#cb114-316" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-317"><a href="#cb114-317" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_year_built_final(df):</span>
<span id="cb114-318"><a href="#cb114-318" aria-hidden="true" tabindex="-1"></a>    year_cols <span class="op">=</span> [<span class="ss">f"year_built_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>] <span class="cf">if</span> <span class="ss">f"year_built_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb114-319"><a href="#cb114-319" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> year_cols:</span>
<span id="cb114-320"><a href="#cb114-320" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'year_built_final'</span>] <span class="op">=</span> df[year_cols].bfill(axis<span class="op">=</span><span class="dv">1</span>).iloc[:, <span class="dv">0</span>]</span>
<span id="cb114-321"><a href="#cb114-321" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Created year_built_final from: </span><span class="sc">{</span>year_cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-322"><a href="#cb114-322" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb114-323"><a href="#cb114-323" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">" Skipped: no year_built_* columns found."</span>)</span>
<span id="cb114-324"><a href="#cb114-324" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb114-325"><a href="#cb114-325" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-326"><a href="#cb114-326" aria-hidden="true" tabindex="-1"></a><span class="co"># Define reverse years for backfill (latest ‚Üí oldest)</span></span>
<span id="cb114-327"><a href="#cb114-327" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb114-328"><a href="#cb114-328" aria-hidden="true" tabindex="-1"></a>features_to_backfill <span class="op">=</span> [<span class="st">'fireplaces'</span>, <span class="st">'quality'</span>, <span class="st">'quality_description'</span>]</span>
<span id="cb114-329"><a href="#cb114-329" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-330"><a href="#cb114-330" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to both train and test</span></span>
<span id="cb114-331"><a href="#cb114-331" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_year_features(train_merged, features_to_backfill, years)</span>
<span id="cb114-332"><a href="#cb114-332" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> create_year_built_final(train_merged)</span>
<span id="cb114-333"><a href="#cb114-333" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-334"><a href="#cb114-334" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_year_features(test_merged, features_to_backfill, years)</span>
<span id="cb114-335"><a href="#cb114-335" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> create_year_built_final(test_merged)</span>
<span id="cb114-336"><a href="#cb114-336" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-337"><a href="#cb114-337" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-338"><a href="#cb114-338" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-341"><a href="#cb114-341" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-342"><a href="#cb114-342" aria-hidden="true" tabindex="-1"></a><span class="co">## Identify columns to drop from training data</span></span>
<span id="cb114-343"><a href="#cb114-343" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> col.startswith(<span class="st">"year_remodeled"</span>)]</span>
<span id="cb114-344"><a href="#cb114-344" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-345"><a href="#cb114-345" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop from both train and test</span></span>
<span id="cb114-346"><a href="#cb114-346" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-347"><a href="#cb114-347" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-348"><a href="#cb114-348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-349"><a href="#cb114-349" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"üóëÔ∏è Dropped year_remodeled-related columns from train/test: </span><span class="sc">{</span>cols_to_drop<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-350"><a href="#cb114-350" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-351"><a href="#cb114-351" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-352"><a href="#cb114-352" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-353"><a href="#cb114-353" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-356"><a href="#cb114-356" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-357"><a href="#cb114-357" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_categorical_year_features(df, features, years):</span>
<span id="cb114-358"><a href="#cb114-358" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> feature <span class="kw">in</span> features:</span>
<span id="cb114-359"><a href="#cb114-359" aria-hidden="true" tabindex="-1"></a>        year_cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb114-360"><a href="#cb114-360" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(year_cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb114-361"><a href="#cb114-361" aria-hidden="true" tabindex="-1"></a>            df[year_cols] <span class="op">=</span> df[year_cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-362"><a href="#cb114-362" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Backfilled: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> across </span><span class="sc">{</span>year_cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-363"><a href="#cb114-363" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb114-364"><a href="#cb114-364" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipped: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> ‚Äî not enough year-based columns."</span>)</span>
<span id="cb114-365"><a href="#cb114-365" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb114-366"><a href="#cb114-366" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-367"><a href="#cb114-367" aria-hidden="true" tabindex="-1"></a><span class="co"># Backfill from most recent year to oldest</span></span>
<span id="cb114-368"><a href="#cb114-368" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb114-369"><a href="#cb114-369" aria-hidden="true" tabindex="-1"></a>features <span class="op">=</span> [<span class="st">'building_condition'</span>, <span class="st">'foundation_type'</span>, <span class="st">'grade'</span>, <span class="st">'has_cooling'</span>, </span>
<span id="cb114-370"><a href="#cb114-370" aria-hidden="true" tabindex="-1"></a>            <span class="st">'has_heat'</span>, <span class="st">'physical_condition'</span>, <span class="st">'exterior_walls'</span>]</span>
<span id="cb114-371"><a href="#cb114-371" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-372"><a href="#cb114-372" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to train and test</span></span>
<span id="cb114-373"><a href="#cb114-373" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_categorical_year_features(train_merged, features, years)</span>
<span id="cb114-374"><a href="#cb114-374" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_categorical_year_features(test_merged, features, years)</span>
<span id="cb114-375"><a href="#cb114-375" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-376"><a href="#cb114-376" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-377"><a href="#cb114-377" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-378"><a href="#cb114-378" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-381"><a href="#cb114-381" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-382"><a href="#cb114-382" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_year_columns(df, features, years):</span>
<span id="cb114-383"><a href="#cb114-383" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> feature <span class="kw">in</span> features:</span>
<span id="cb114-384"><a href="#cb114-384" aria-hidden="true" tabindex="-1"></a>        cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb114-385"><a href="#cb114-385" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb114-386"><a href="#cb114-386" aria-hidden="true" tabindex="-1"></a>            df[cols] <span class="op">=</span> df[cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-387"><a href="#cb114-387" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Backfilled: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> across </span><span class="sc">{</span>cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-388"><a href="#cb114-388" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb114-389"><a href="#cb114-389" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipped: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> ‚Äî not enough year-based columns found."</span>)</span>
<span id="cb114-390"><a href="#cb114-390" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb114-391"><a href="#cb114-391" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-392"><a href="#cb114-392" aria-hidden="true" tabindex="-1"></a><span class="co"># Define year ranges</span></span>
<span id="cb114-393"><a href="#cb114-393" aria-hidden="true" tabindex="-1"></a>area_years <span class="op">=</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb114-394"><a href="#cb114-394" aria-hidden="true" tabindex="-1"></a>value_years <span class="op">=</span> [<span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb114-395"><a href="#cb114-395" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-396"><a href="#cb114-396" aria-hidden="true" tabindex="-1"></a><span class="co"># Define feature groups</span></span>
<span id="cb114-397"><a href="#cb114-397" aria-hidden="true" tabindex="-1"></a>area_features <span class="op">=</span> [<span class="st">'building_area'</span>, <span class="st">'land_area'</span>]</span>
<span id="cb114-398"><a href="#cb114-398" aria-hidden="true" tabindex="-1"></a>value_features <span class="op">=</span> [<span class="st">'building_value'</span>, <span class="st">'land_value'</span>, <span class="st">'assessed'</span>]</span>
<span id="cb114-399"><a href="#cb114-399" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-400"><a href="#cb114-400" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to train and test</span></span>
<span id="cb114-401"><a href="#cb114-401" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_year_columns(train_merged, area_features, area_years)</span>
<span id="cb114-402"><a href="#cb114-402" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_year_columns(train_merged, value_features, value_years)</span>
<span id="cb114-403"><a href="#cb114-403" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-404"><a href="#cb114-404" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_year_columns(test_merged, area_features, area_years)</span>
<span id="cb114-405"><a href="#cb114-405" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_year_columns(test_merged, value_features, value_years)</span>
<span id="cb114-406"><a href="#cb114-406" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-407"><a href="#cb114-407" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-408"><a href="#cb114-408" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-411"><a href="#cb114-411" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-412"><a href="#cb114-412" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_protested_columns(df, years):</span>
<span id="cb114-413"><a href="#cb114-413" aria-hidden="true" tabindex="-1"></a>    cols <span class="op">=</span> [<span class="ss">f"protested_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"protested_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb114-414"><a href="#cb114-414" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb114-415"><a href="#cb114-415" aria-hidden="true" tabindex="-1"></a>        df[cols] <span class="op">=</span> df[cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-416"><a href="#cb114-416" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Backfilled: protested across </span><span class="sc">{</span>cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-417"><a href="#cb114-417" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb114-418"><a href="#cb114-418" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">" Skipped protested ‚Äî not enough year-based columns found."</span>)</span>
<span id="cb114-419"><a href="#cb114-419" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb114-420"><a href="#cb114-420" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-421"><a href="#cb114-421" aria-hidden="true" tabindex="-1"></a><span class="co"># Only use pre-2019 years to avoid leakage</span></span>
<span id="cb114-422"><a href="#cb114-422" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb114-423"><a href="#cb114-423" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-424"><a href="#cb114-424" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to both datasets</span></span>
<span id="cb114-425"><a href="#cb114-425" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_protested_columns(train_merged, years)</span>
<span id="cb114-426"><a href="#cb114-426" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_protested_columns(test_merged, years)</span>
<span id="cb114-427"><a href="#cb114-427" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-428"><a href="#cb114-428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-429"><a href="#cb114-429" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-430"><a href="#cb114-430" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-433"><a href="#cb114-433" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-434"><a href="#cb114-434" aria-hidden="true" tabindex="-1"></a><span class="co"># Save 'acct' from test_merged only</span></span>
<span id="cb114-435"><a href="#cb114-435" aria-hidden="true" tabindex="-1"></a>acct_test <span class="op">=</span> test_merged[[<span class="st">'acct'</span>]].copy() <span class="cf">if</span> <span class="st">'acct'</span> <span class="kw">in</span> test_merged.columns <span class="cf">else</span> <span class="va">None</span></span>
<span id="cb114-436"><a href="#cb114-436" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-437"><a href="#cb114-437" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop 'acct' from both train and test</span></span>
<span id="cb114-438"><a href="#cb114-438" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb114-439"><a href="#cb114-439" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'acct'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb114-440"><a href="#cb114-440" aria-hidden="true" tabindex="-1"></a>        df.drop(columns<span class="op">=</span><span class="st">'acct'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-441"><a href="#cb114-441" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"üóëÔ∏è Dropped 'acct' from </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-442"><a href="#cb114-442" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-443"><a href="#cb114-443" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-444"><a href="#cb114-444" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-445"><a href="#cb114-445" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-446"><a href="#cb114-446" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-449"><a href="#cb114-449" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-450"><a href="#cb114-450" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> [<span class="st">'zone'</span>, <span class="st">'subneighborhood'</span>, <span class="st">'neighborhood'</span>, <span class="st">'region'</span>]:</span>
<span id="cb114-451"><a href="#cb114-451" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-452"><a href="#cb114-452" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>train_merged[col]<span class="sc">.</span>nunique()<span class="sc">}</span><span class="ss"> unique values in training set"</span>)</span>
<span id="cb114-453"><a href="#cb114-453" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb114-454"><a href="#cb114-454" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"‚ö†Ô∏è </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> not found in training set"</span>)</span>
<span id="cb114-455"><a href="#cb114-455" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-456"><a href="#cb114-456" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-457"><a href="#cb114-457" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-460"><a href="#cb114-460" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-461"><a href="#cb114-461" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> [<span class="st">'neighborhood'</span>, <span class="st">'region'</span>,<span class="st">'zone'</span>,<span class="st">'subneighborhood'</span>]:</span>
<span id="cb114-462"><a href="#cb114-462" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-463"><a href="#cb114-463" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 1: Compute frequency from training data</span></span>
<span id="cb114-464"><a href="#cb114-464" aria-hidden="true" tabindex="-1"></a>        freq_map <span class="op">=</span> train_merged[col].value_counts(normalize<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-465"><a href="#cb114-465" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-466"><a href="#cb114-466" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 2: Apply to both datasets</span></span>
<span id="cb114-467"><a href="#cb114-467" aria-hidden="true" tabindex="-1"></a>        train_merged[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_freq'</span>] <span class="op">=</span> train_merged[col].<span class="bu">map</span>(freq_map)</span>
<span id="cb114-468"><a href="#cb114-468" aria-hidden="true" tabindex="-1"></a>        test_merged[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_freq'</span>] <span class="op">=</span> test_merged[col].<span class="bu">map</span>(freq_map)</span>
<span id="cb114-469"><a href="#cb114-469" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-470"><a href="#cb114-470" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Frequency encoded: </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> ‚Üí </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_freq (based on training set)"</span>)</span>
<span id="cb114-471"><a href="#cb114-471" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb114-472"><a href="#cb114-472" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Column '</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">' not found in training set"</span>)</span>
<span id="cb114-473"><a href="#cb114-473" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-474"><a href="#cb114-474" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-475"><a href="#cb114-475" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-478"><a href="#cb114-478" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-479"><a href="#cb114-479" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">all</span>(col <span class="kw">in</span> train_merged.columns <span class="cf">for</span> col <span class="kw">in</span> [<span class="st">'land_area_2019'</span>, <span class="st">'land_area_2015'</span>]):</span>
<span id="cb114-480"><a href="#cb114-480" aria-hidden="true" tabindex="-1"></a>    growth <span class="op">=</span> train_merged[<span class="st">'land_area_2019'</span>] <span class="op">-</span> train_merged[<span class="st">'land_area_2015'</span>]</span>
<span id="cb114-481"><a href="#cb114-481" aria-hidden="true" tabindex="-1"></a>    changed_pct <span class="op">=</span> (growth <span class="op">!=</span> <span class="dv">0</span>).mean() <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb114-482"><a href="#cb114-482" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Percentage of homes with land area change (2015‚Üí2019): </span><span class="sc">{</span>changed_pct<span class="sc">:.2f}</span><span class="ss">%"</span>)</span>
<span id="cb114-483"><a href="#cb114-483" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb114-484"><a href="#cb114-484" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">" One or both columns ('land_area_2015', 'land_area_2019') not found in training set"</span>)</span>
<span id="cb114-485"><a href="#cb114-485" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-486"><a href="#cb114-486" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-487"><a href="#cb114-487" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-488"><a href="#cb114-488" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-491"><a href="#cb114-491" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-492"><a href="#cb114-492" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb114-493"><a href="#cb114-493" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb114-494"><a href="#cb114-494" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'year_built_final'</span>] <span class="op">=</span> df[<span class="st">'year_built_final'</span>].astype(<span class="bu">str</span>)</span>
<span id="cb114-495"><a href="#cb114-495" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Converted 'year_built_final' to string in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-496"><a href="#cb114-496" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb114-497"><a href="#cb114-497" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" 'year_built_final' not found in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-498"><a href="#cb114-498" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-499"><a href="#cb114-499" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-500"><a href="#cb114-500" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-503"><a href="#cb114-503" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-504"><a href="#cb114-504" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb114-505"><a href="#cb114-505" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'floor_area_total_final'</span> <span class="kw">in</span> df.columns <span class="kw">and</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb114-506"><a href="#cb114-506" aria-hidden="true" tabindex="-1"></a>        df.loc[df[<span class="st">'floor_area_total_final'</span>] <span class="op">==</span> <span class="dv">0</span>, <span class="st">'year_built_final'</span>] <span class="op">=</span> <span class="st">'None'</span></span>
<span id="cb114-507"><a href="#cb114-507" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Set 'year_built_final' to 'None' where 'floor_area_total_final' == 0 in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-508"><a href="#cb114-508" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb114-509"><a href="#cb114-509" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Required columns missing in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-510"><a href="#cb114-510" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-511"><a href="#cb114-511" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-512"><a href="#cb114-512" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-515"><a href="#cb114-515" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-516"><a href="#cb114-516" aria-hidden="true" tabindex="-1"></a><span class="co"># Define year ranges per feature type</span></span>
<span id="cb114-517"><a href="#cb114-517" aria-hidden="true" tabindex="-1"></a>value_years <span class="op">=</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2019</span>)   <span class="co"># 2015‚Äì2018 for value columns</span></span>
<span id="cb114-518"><a href="#cb114-518" aria-hidden="true" tabindex="-1"></a>area_years  <span class="op">=</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)   <span class="co"># 2015‚Äì2019 for area columns</span></span>
<span id="cb114-519"><a href="#cb114-519" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-520"><a href="#cb114-520" aria-hidden="true" tabindex="-1"></a><span class="co"># Define base columns</span></span>
<span id="cb114-521"><a href="#cb114-521" aria-hidden="true" tabindex="-1"></a>base_cols_year_map <span class="op">=</span> {</span>
<span id="cb114-522"><a href="#cb114-522" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_value'</span>: value_years,</span>
<span id="cb114-523"><a href="#cb114-523" aria-hidden="true" tabindex="-1"></a>    <span class="st">'land_value'</span>: value_years,</span>
<span id="cb114-524"><a href="#cb114-524" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_area'</span>: area_years,</span>
<span id="cb114-525"><a href="#cb114-525" aria-hidden="true" tabindex="-1"></a>    <span class="st">'land_area'</span>: area_years,</span>
<span id="cb114-526"><a href="#cb114-526" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb114-527"><a href="#cb114-527" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-528"><a href="#cb114-528" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate full list of columns to impute</span></span>
<span id="cb114-529"><a href="#cb114-529" aria-hidden="true" tabindex="-1"></a>cols_to_impute <span class="op">=</span> []</span>
<span id="cb114-530"><a href="#cb114-530" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> base, years <span class="kw">in</span> base_cols_year_map.items():</span>
<span id="cb114-531"><a href="#cb114-531" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> year <span class="kw">in</span> years:</span>
<span id="cb114-532"><a href="#cb114-532" aria-hidden="true" tabindex="-1"></a>        cols_to_impute.append(<span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-533"><a href="#cb114-533" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-534"><a href="#cb114-534" aria-hidden="true" tabindex="-1"></a><span class="co"># Impute using neighborhood ‚Üí region strategy</span></span>
<span id="cb114-535"><a href="#cb114-535" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> cols_to_impute:</span>
<span id="cb114-536"><a href="#cb114-536" aria-hidden="true" tabindex="-1"></a>    <span class="co"># First, fill by neighborhood (train only)</span></span>
<span id="cb114-537"><a href="#cb114-537" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'neighborhood'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-538"><a href="#cb114-538" aria-hidden="true" tabindex="-1"></a>        medians_by_neigh <span class="op">=</span> train_merged.groupby(<span class="st">'neighborhood'</span>)[col].median()</span>
<span id="cb114-539"><a href="#cb114-539" aria-hidden="true" tabindex="-1"></a>        train_merged[col] <span class="op">=</span> train_merged.<span class="bu">apply</span>(</span>
<span id="cb114-540"><a href="#cb114-540" aria-hidden="true" tabindex="-1"></a>            <span class="kw">lambda</span> row: medians_by_neigh[row[<span class="st">'neighborhood'</span>]] <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-541"><a href="#cb114-541" aria-hidden="true" tabindex="-1"></a>        test_merged[col] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb114-542"><a href="#cb114-542" aria-hidden="true" tabindex="-1"></a>            <span class="kw">lambda</span> row: medians_by_neigh.get(row[<span class="st">'neighborhood'</span>], np.nan) <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-543"><a href="#cb114-543" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-544"><a href="#cb114-544" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Then, fill remaining by region (train only)</span></span>
<span id="cb114-545"><a href="#cb114-545" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'region'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-546"><a href="#cb114-546" aria-hidden="true" tabindex="-1"></a>        medians_by_region <span class="op">=</span> train_merged.groupby(<span class="st">'region'</span>)[col].median()</span>
<span id="cb114-547"><a href="#cb114-547" aria-hidden="true" tabindex="-1"></a>        train_merged[col] <span class="op">=</span> train_merged.<span class="bu">apply</span>(</span>
<span id="cb114-548"><a href="#cb114-548" aria-hidden="true" tabindex="-1"></a>            <span class="kw">lambda</span> row: medians_by_region[row[<span class="st">'region'</span>]] <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-549"><a href="#cb114-549" aria-hidden="true" tabindex="-1"></a>        test_merged[col] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb114-550"><a href="#cb114-550" aria-hidden="true" tabindex="-1"></a>            <span class="kw">lambda</span> row: medians_by_region.get(row[<span class="st">'region'</span>], np.nan) <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-551"><a href="#cb114-551" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-552"><a href="#cb114-552" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Imputed '</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">' using group medians (neighborhood ‚Üí region) from training data"</span>)</span>
<span id="cb114-553"><a href="#cb114-553" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-554"><a href="#cb114-554" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-555"><a href="#cb114-555" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-556"><a href="#cb114-556" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-559"><a href="#cb114-559" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-560"><a href="#cb114-560" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pandas.api.types <span class="im">import</span> is_numeric_dtype</span>
<span id="cb114-561"><a href="#cb114-561" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-562"><a href="#cb114-562" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1: Coerce non-numeric to NaN in both sets</span></span>
<span id="cb114-563"><a href="#cb114-563" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb114-564"><a href="#cb114-564" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb114-565"><a href="#cb114-565" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'year_built_final'</span>] <span class="op">=</span> pd.to_numeric(df[<span class="st">'year_built_final'</span>], errors<span class="op">=</span><span class="st">'coerce'</span>)</span>
<span id="cb114-566"><a href="#cb114-566" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Coerced 'year_built_final' to numeric in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-567"><a href="#cb114-567" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-568"><a href="#cb114-568" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 2: Group-based imputation (use training data only)</span></span>
<span id="cb114-569"><a href="#cb114-569" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> train_merged.columns <span class="kw">and</span> <span class="st">'neighborhood'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-570"><a href="#cb114-570" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Neighborhood-based median from train</span></span>
<span id="cb114-571"><a href="#cb114-571" aria-hidden="true" tabindex="-1"></a>    neigh_medians <span class="op">=</span> train_merged.groupby(<span class="st">'neighborhood'</span>)[<span class="st">'year_built_final'</span>].median()</span>
<span id="cb114-572"><a href="#cb114-572" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-573"><a href="#cb114-573" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Apply to train</span></span>
<span id="cb114-574"><a href="#cb114-574" aria-hidden="true" tabindex="-1"></a>    train_merged[<span class="st">'year_built_final'</span>] <span class="op">=</span> train_merged.<span class="bu">apply</span>(</span>
<span id="cb114-575"><a href="#cb114-575" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: neigh_medians[row[<span class="st">'neighborhood'</span>]] <span class="cf">if</span> pd.isna(row[<span class="st">'year_built_final'</span>]) <span class="cf">else</span> row[<span class="st">'year_built_final'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-576"><a href="#cb114-576" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-577"><a href="#cb114-577" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Apply to test</span></span>
<span id="cb114-578"><a href="#cb114-578" aria-hidden="true" tabindex="-1"></a>    test_merged[<span class="st">'year_built_final'</span>] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb114-579"><a href="#cb114-579" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: neigh_medians.get(row[<span class="st">'neighborhood'</span>], np.nan) <span class="cf">if</span> pd.isna(row[<span class="st">'year_built_final'</span>]) <span class="cf">else</span> row[<span class="st">'year_built_final'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-580"><a href="#cb114-580" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-581"><a href="#cb114-581" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'region'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-582"><a href="#cb114-582" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Region-based fallback median from train</span></span>
<span id="cb114-583"><a href="#cb114-583" aria-hidden="true" tabindex="-1"></a>    region_medians <span class="op">=</span> train_merged.groupby(<span class="st">'region'</span>)[<span class="st">'year_built_final'</span>].median()</span>
<span id="cb114-584"><a href="#cb114-584" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-585"><a href="#cb114-585" aria-hidden="true" tabindex="-1"></a>    train_merged[<span class="st">'year_built_final'</span>] <span class="op">=</span> train_merged.<span class="bu">apply</span>(</span>
<span id="cb114-586"><a href="#cb114-586" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: region_medians[row[<span class="st">'region'</span>]] <span class="cf">if</span> pd.isna(row[<span class="st">'year_built_final'</span>]) <span class="cf">else</span> row[<span class="st">'year_built_final'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-587"><a href="#cb114-587" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-588"><a href="#cb114-588" aria-hidden="true" tabindex="-1"></a>    test_merged[<span class="st">'year_built_final'</span>] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb114-589"><a href="#cb114-589" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: region_medians.get(row[<span class="st">'region'</span>], np.nan) <span class="cf">if</span> pd.isna(row[<span class="st">'year_built_final'</span>]) <span class="cf">else</span> row[<span class="st">'year_built_final'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-590"><a href="#cb114-590" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-591"><a href="#cb114-591" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Imputed 'year_built_final' using neighborhood ‚Üí region medians from training set"</span>)</span>
<span id="cb114-592"><a href="#cb114-592" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-593"><a href="#cb114-593" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-594"><a href="#cb114-594" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-597"><a href="#cb114-597" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-598"><a href="#cb114-598" aria-hidden="true" tabindex="-1"></a><span class="co"># List of all assessed columns to impute</span></span>
<span id="cb114-599"><a href="#cb114-599" aria-hidden="true" tabindex="-1"></a>assessed_cols <span class="op">=</span> [<span class="st">'assessed_2015'</span>, <span class="st">'assessed_2016'</span>, <span class="st">'assessed_2017'</span>, <span class="st">'assessed_2018'</span>]</span>
<span id="cb114-600"><a href="#cb114-600" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-601"><a href="#cb114-601" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> assessed_cols:</span>
<span id="cb114-602"><a href="#cb114-602" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">not</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-603"><a href="#cb114-603" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span></span>
<span id="cb114-604"><a href="#cb114-604" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-605"><a href="#cb114-605" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: Compute medians from training data only</span></span>
<span id="cb114-606"><a href="#cb114-606" aria-hidden="true" tabindex="-1"></a>    neigh_medians <span class="op">=</span> train_merged.groupby(<span class="st">'neighborhood'</span>)[col].median()</span>
<span id="cb114-607"><a href="#cb114-607" aria-hidden="true" tabindex="-1"></a>    region_medians <span class="op">=</span> train_merged.groupby(<span class="st">'region'</span>)[col].median()</span>
<span id="cb114-608"><a href="#cb114-608" aria-hidden="true" tabindex="-1"></a>    global_median <span class="op">=</span> train_merged[col].median()</span>
<span id="cb114-609"><a href="#cb114-609" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-610"><a href="#cb114-610" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 2: Train set imputation</span></span>
<span id="cb114-611"><a href="#cb114-611" aria-hidden="true" tabindex="-1"></a>    train_merged[col] <span class="op">=</span> train_merged.<span class="bu">apply</span>(</span>
<span id="cb114-612"><a href="#cb114-612" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: neigh_medians[row[<span class="st">'neighborhood'</span>]]</span>
<span id="cb114-613"><a href="#cb114-613" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pd.isna(row[col]) <span class="kw">and</span> row[<span class="st">'neighborhood'</span>] <span class="kw">in</span> neigh_medians <span class="cf">else</span></span>
<span id="cb114-614"><a href="#cb114-614" aria-hidden="true" tabindex="-1"></a>        region_medians[row[<span class="st">'region'</span>]]</span>
<span id="cb114-615"><a href="#cb114-615" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pd.isna(row[col]) <span class="kw">and</span> row[<span class="st">'region'</span>] <span class="kw">in</span> region_medians <span class="cf">else</span></span>
<span id="cb114-616"><a href="#cb114-616" aria-hidden="true" tabindex="-1"></a>        global_median</span>
<span id="cb114-617"><a href="#cb114-617" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span></span>
<span id="cb114-618"><a href="#cb114-618" aria-hidden="true" tabindex="-1"></a>        row[col],</span>
<span id="cb114-619"><a href="#cb114-619" aria-hidden="true" tabindex="-1"></a>        axis<span class="op">=</span><span class="dv">1</span></span>
<span id="cb114-620"><a href="#cb114-620" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb114-621"><a href="#cb114-621" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-622"><a href="#cb114-622" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 3: Test set imputation (using train medians only)</span></span>
<span id="cb114-623"><a href="#cb114-623" aria-hidden="true" tabindex="-1"></a>    test_merged[col] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb114-624"><a href="#cb114-624" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: neigh_medians.get(row[<span class="st">'neighborhood'</span>], np.nan)</span>
<span id="cb114-625"><a href="#cb114-625" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col],</span>
<span id="cb114-626"><a href="#cb114-626" aria-hidden="true" tabindex="-1"></a>        axis<span class="op">=</span><span class="dv">1</span></span>
<span id="cb114-627"><a href="#cb114-627" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb114-628"><a href="#cb114-628" aria-hidden="true" tabindex="-1"></a>    test_merged[col] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb114-629"><a href="#cb114-629" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: region_medians.get(row[<span class="st">'region'</span>], np.nan)</span>
<span id="cb114-630"><a href="#cb114-630" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col],</span>
<span id="cb114-631"><a href="#cb114-631" aria-hidden="true" tabindex="-1"></a>        axis<span class="op">=</span><span class="dv">1</span></span>
<span id="cb114-632"><a href="#cb114-632" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb114-633"><a href="#cb114-633" aria-hidden="true" tabindex="-1"></a>    test_merged[col].fillna(global_median, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-634"><a href="#cb114-634" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-635"><a href="#cb114-635" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Imputed '</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">' using neighborhood ‚Üí region ‚Üí global medians (from training data)"</span>)</span>
<span id="cb114-636"><a href="#cb114-636" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-637"><a href="#cb114-637" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-638"><a href="#cb114-638" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-639"><a href="#cb114-639" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-642"><a href="#cb114-642" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-643"><a href="#cb114-643" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 1: Compute neighborhood-level stats ===</span></span>
<span id="cb114-644"><a href="#cb114-644" aria-hidden="true" tabindex="-1"></a>neigh_stats <span class="op">=</span> train_merged.groupby(<span class="st">'neighborhood'</span>)[<span class="st">'assessed_2018'</span>].agg([</span>
<span id="cb114-645"><a href="#cb114-645" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'neigh_assess_mean'</span>, <span class="st">'mean'</span>),</span>
<span id="cb114-646"><a href="#cb114-646" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'neigh_assess_median'</span>, <span class="st">'median'</span>),</span>
<span id="cb114-647"><a href="#cb114-647" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'neigh_assess_std'</span>, <span class="st">'std'</span>),</span>
<span id="cb114-648"><a href="#cb114-648" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'neigh_assess_q1'</span>, <span class="kw">lambda</span> x: x.quantile(<span class="fl">0.25</span>)),</span>
<span id="cb114-649"><a href="#cb114-649" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'neigh_assess_q3'</span>, <span class="kw">lambda</span> x: x.quantile(<span class="fl">0.75</span>)),</span>
<span id="cb114-650"><a href="#cb114-650" aria-hidden="true" tabindex="-1"></a>]).reset_index()</span>
<span id="cb114-651"><a href="#cb114-651" aria-hidden="true" tabindex="-1"></a>neigh_stats[<span class="st">'neigh_assess_iqr'</span>] <span class="op">=</span> neigh_stats[<span class="st">'neigh_assess_q3'</span>] <span class="op">-</span> neigh_stats[<span class="st">'neigh_assess_q1'</span>]</span>
<span id="cb114-652"><a href="#cb114-652" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-653"><a href="#cb114-653" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 2: Compute region-level stats ===</span></span>
<span id="cb114-654"><a href="#cb114-654" aria-hidden="true" tabindex="-1"></a>region_stats <span class="op">=</span> train_merged.groupby(<span class="st">'region'</span>)[<span class="st">'assessed_2018'</span>].agg([</span>
<span id="cb114-655"><a href="#cb114-655" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'region_assess_mean'</span>, <span class="st">'mean'</span>),</span>
<span id="cb114-656"><a href="#cb114-656" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'region_assess_median'</span>, <span class="st">'median'</span>),</span>
<span id="cb114-657"><a href="#cb114-657" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'region_assess_std'</span>, <span class="st">'std'</span>),</span>
<span id="cb114-658"><a href="#cb114-658" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'region_assess_q1'</span>, <span class="kw">lambda</span> x: x.quantile(<span class="fl">0.25</span>)),</span>
<span id="cb114-659"><a href="#cb114-659" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'region_assess_q3'</span>, <span class="kw">lambda</span> x: x.quantile(<span class="fl">0.75</span>)),</span>
<span id="cb114-660"><a href="#cb114-660" aria-hidden="true" tabindex="-1"></a>]).reset_index()</span>
<span id="cb114-661"><a href="#cb114-661" aria-hidden="true" tabindex="-1"></a>region_stats[<span class="st">'region_assess_iqr'</span>] <span class="op">=</span> region_stats[<span class="st">'region_assess_q3'</span>] <span class="op">-</span> region_stats[<span class="st">'region_assess_q1'</span>]</span>
<span id="cb114-662"><a href="#cb114-662" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-663"><a href="#cb114-663" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 3: Fallback std maps from training data ===</span></span>
<span id="cb114-664"><a href="#cb114-664" aria-hidden="true" tabindex="-1"></a><span class="co"># For neighborhood fallback, group region medians of neighborhood std</span></span>
<span id="cb114-665"><a href="#cb114-665" aria-hidden="true" tabindex="-1"></a>neigh_std_by_region <span class="op">=</span> neigh_stats.merge(train_merged[[<span class="st">'neighborhood'</span>, <span class="st">'region'</span>]], on<span class="op">=</span><span class="st">'neighborhood'</span>, how<span class="op">=</span><span class="st">'left'</span>) <span class="op">\</span></span>
<span id="cb114-666"><a href="#cb114-666" aria-hidden="true" tabindex="-1"></a>                                  .groupby(<span class="st">'region'</span>)[<span class="st">'neigh_assess_std'</span>].median()</span>
<span id="cb114-667"><a href="#cb114-667" aria-hidden="true" tabindex="-1"></a>global_neigh_std <span class="op">=</span> neigh_stats[<span class="st">'neigh_assess_std'</span>].median()</span>
<span id="cb114-668"><a href="#cb114-668" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-669"><a href="#cb114-669" aria-hidden="true" tabindex="-1"></a>region_std_by_neigh <span class="op">=</span> region_stats.merge(train_merged[[<span class="st">'neighborhood'</span>, <span class="st">'region'</span>]], on<span class="op">=</span><span class="st">'region'</span>, how<span class="op">=</span><span class="st">'left'</span>) <span class="op">\</span></span>
<span id="cb114-670"><a href="#cb114-670" aria-hidden="true" tabindex="-1"></a>                                   .groupby(<span class="st">'neighborhood'</span>)[<span class="st">'region_assess_std'</span>].median()</span>
<span id="cb114-671"><a href="#cb114-671" aria-hidden="true" tabindex="-1"></a>global_region_std <span class="op">=</span> region_stats[<span class="st">'region_assess_std'</span>].median()</span>
<span id="cb114-672"><a href="#cb114-672" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-673"><a href="#cb114-673" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 4: Merge into train/test and compute features ===</span></span>
<span id="cb114-674"><a href="#cb114-674" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb114-675"><a href="#cb114-675" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.merge(neigh_stats, on<span class="op">=</span><span class="st">'neighborhood'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb114-676"><a href="#cb114-676" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.merge(region_stats, on<span class="op">=</span><span class="st">'region'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb114-677"><a href="#cb114-677" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-678"><a href="#cb114-678" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill missing std values via fallback</span></span>
<span id="cb114-679"><a href="#cb114-679" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'neigh_assess_std'</span>] <span class="op">=</span> df[<span class="st">'neigh_assess_std'</span>].fillna(</span>
<span id="cb114-680"><a href="#cb114-680" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'region'</span>].<span class="bu">map</span>(neigh_std_by_region)</span>
<span id="cb114-681"><a href="#cb114-681" aria-hidden="true" tabindex="-1"></a>    ).fillna(global_neigh_std)</span>
<span id="cb114-682"><a href="#cb114-682" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-683"><a href="#cb114-683" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'region_assess_std'</span>] <span class="op">=</span> df[<span class="st">'region_assess_std'</span>].fillna(</span>
<span id="cb114-684"><a href="#cb114-684" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'neighborhood'</span>].<span class="bu">map</span>(region_std_by_neigh)</span>
<span id="cb114-685"><a href="#cb114-685" aria-hidden="true" tabindex="-1"></a>    ).fillna(global_region_std)</span>
<span id="cb114-686"><a href="#cb114-686" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-687"><a href="#cb114-687" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute derived features</span></span>
<span id="cb114-688"><a href="#cb114-688" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'assess_minus_neigh_mean'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">-</span> df[<span class="st">'neigh_assess_mean'</span>]</span>
<span id="cb114-689"><a href="#cb114-689" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'assess_ratio_neigh_mean'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">/</span> (df[<span class="st">'neigh_assess_mean'</span>] <span class="op">+</span> <span class="fl">1e-6</span>)</span>
<span id="cb114-690"><a href="#cb114-690" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'z_score_assess_neigh'</span>] <span class="op">=</span> df[<span class="st">'assess_minus_neigh_mean'</span>] <span class="op">/</span> (df[<span class="st">'neigh_assess_std'</span>] <span class="op">+</span> <span class="fl">1e-6</span>)</span>
<span id="cb114-691"><a href="#cb114-691" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-692"><a href="#cb114-692" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'assess_minus_region_mean'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">-</span> df[<span class="st">'region_assess_mean'</span>]</span>
<span id="cb114-693"><a href="#cb114-693" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'assess_ratio_region_mean'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">/</span> (df[<span class="st">'region_assess_mean'</span>] <span class="op">+</span> <span class="fl">1e-6</span>)</span>
<span id="cb114-694"><a href="#cb114-694" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'z_score_assess_region'</span>] <span class="op">=</span> df[<span class="st">'assess_minus_region_mean'</span>] <span class="op">/</span> (df[<span class="st">'region_assess_std'</span>] <span class="op">+</span> <span class="fl">1e-6</span>)</span>
<span id="cb114-695"><a href="#cb114-695" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-696"><a href="#cb114-696" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Save back</span></span>
<span id="cb114-697"><a href="#cb114-697" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> df_name <span class="op">==</span> <span class="st">'train_merged'</span>:</span>
<span id="cb114-698"><a href="#cb114-698" aria-hidden="true" tabindex="-1"></a>        train_merged <span class="op">=</span> df</span>
<span id="cb114-699"><a href="#cb114-699" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb114-700"><a href="#cb114-700" aria-hidden="true" tabindex="-1"></a>        test_merged <span class="op">=</span> df</span>
<span id="cb114-701"><a href="#cb114-701" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-702"><a href="#cb114-702" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Completed: Stats merge + std fallback + z-score computation."</span>)</span>
<span id="cb114-703"><a href="#cb114-703" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-704"><a href="#cb114-704" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-705"><a href="#cb114-705" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-708"><a href="#cb114-708" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-709"><a href="#cb114-709" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> [<span class="st">'neighborhood'</span>, <span class="st">'region'</span>,<span class="st">'zone'</span>,<span class="st">'subneighborhood'</span>]</span>
<span id="cb114-710"><a href="#cb114-710" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-711"><a href="#cb114-711" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb114-712"><a href="#cb114-712" aria-hidden="true" tabindex="-1"></a>    drop_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> cols_to_drop <span class="cf">if</span> col <span class="kw">in</span> df.columns]</span>
<span id="cb114-713"><a href="#cb114-713" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> drop_cols:</span>
<span id="cb114-714"><a href="#cb114-714" aria-hidden="true" tabindex="-1"></a>        df.drop(columns<span class="op">=</span>drop_cols, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-715"><a href="#cb114-715" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"üóëÔ∏è Dropped columns from </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>drop_cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-716"><a href="#cb114-716" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-717"><a href="#cb114-717" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-718"><a href="#cb114-718" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-721"><a href="#cb114-721" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-722"><a href="#cb114-722" aria-hidden="true" tabindex="-1"></a>growth_pairs <span class="op">=</span> {</span>
<span id="cb114-723"><a href="#cb114-723" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_value_growth'</span>: (<span class="st">'building_value_2018'</span>, <span class="st">'building_value_2015'</span>),</span>
<span id="cb114-724"><a href="#cb114-724" aria-hidden="true" tabindex="-1"></a>    <span class="st">'land_value_growth'</span>:     (<span class="st">'land_value_2018'</span>, <span class="st">'land_value_2015'</span>),</span>
<span id="cb114-725"><a href="#cb114-725" aria-hidden="true" tabindex="-1"></a>    <span class="st">'assessed_growth'</span>:       (<span class="st">'assessed_2018'</span>, <span class="st">'assessed_2015'</span>)</span>
<span id="cb114-726"><a href="#cb114-726" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb114-727"><a href="#cb114-727" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-728"><a href="#cb114-728" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb114-729"><a href="#cb114-729" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> new_col, (final_col, base_col) <span class="kw">in</span> growth_pairs.items():</span>
<span id="cb114-730"><a href="#cb114-730" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> final_col <span class="kw">in</span> df.columns <span class="kw">and</span> base_col <span class="kw">in</span> df.columns:</span>
<span id="cb114-731"><a href="#cb114-731" aria-hidden="true" tabindex="-1"></a>            df[new_col] <span class="op">=</span> df[final_col] <span class="op">-</span> df[base_col]</span>
<span id="cb114-732"><a href="#cb114-732" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Created </span><span class="sc">{</span>new_col<span class="sc">}</span><span class="ss"> in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-733"><a href="#cb114-733" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb114-734"><a href="#cb114-734" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipped </span><span class="sc">{</span>new_col<span class="sc">}</span><span class="ss"> in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">: missing </span><span class="sc">{</span>final_col<span class="sc">}</span><span class="ss"> or </span><span class="sc">{</span>base_col<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-735"><a href="#cb114-735" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-736"><a href="#cb114-736" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Building Age ===</span></span>
<span id="cb114-737"><a href="#cb114-737" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb114-738"><a href="#cb114-738" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'year_built_final'</span>] <span class="op">=</span> pd.to_numeric(df[<span class="st">'year_built_final'</span>], errors<span class="op">=</span><span class="st">'coerce'</span>)  <span class="co"># handle 'Vacant', etc.</span></span>
<span id="cb114-739"><a href="#cb114-739" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'building_age'</span>] <span class="op">=</span> <span class="dv">2018</span> <span class="op">-</span> df[<span class="st">'year_built_final'</span>]</span>
<span id="cb114-740"><a href="#cb114-740" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Created building_age in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-741"><a href="#cb114-741" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb114-742"><a href="#cb114-742" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Skipped building_age in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">: missing year_built_final"</span>)</span>
<span id="cb114-743"><a href="#cb114-743" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-744"><a href="#cb114-744" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-745"><a href="#cb114-745" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-748"><a href="#cb114-748" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-749"><a href="#cb114-749" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'school_dist'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-750"><a href="#cb114-750" aria-hidden="true" tabindex="-1"></a>    missing_pct <span class="op">=</span> train_merged[<span class="st">'school_dist'</span>].isna().mean() <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb114-751"><a href="#cb114-751" aria-hidden="true" tabindex="-1"></a>    missing_count <span class="op">=</span> train_merged[<span class="st">'school_dist'</span>].isna().<span class="bu">sum</span>()</span>
<span id="cb114-752"><a href="#cb114-752" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-753"><a href="#cb114-753" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" 'school_dist' has </span><span class="sc">{</span>missing_count<span class="sc">}</span><span class="ss"> missing values (</span><span class="sc">{</span>missing_pct<span class="sc">:.2f}</span><span class="ss">%) in training set"</span>)</span>
<span id="cb114-754"><a href="#cb114-754" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb114-755"><a href="#cb114-755" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">" 'school_dist' not found in training set"</span>)</span>
<span id="cb114-756"><a href="#cb114-756" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-757"><a href="#cb114-757" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-758"><a href="#cb114-758" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-761"><a href="#cb114-761" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-762"><a href="#cb114-762" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'school_dist'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-763"><a href="#cb114-763" aria-hidden="true" tabindex="-1"></a>    school_dist_median <span class="op">=</span> train_merged[<span class="st">'school_dist'</span>].median()</span>
<span id="cb114-764"><a href="#cb114-764" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-765"><a href="#cb114-765" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb114-766"><a href="#cb114-766" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="st">'school_dist'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb114-767"><a href="#cb114-767" aria-hidden="true" tabindex="-1"></a>            df[<span class="st">'school_dist'</span>] <span class="op">=</span> df[<span class="st">'school_dist'</span>].fillna(school_dist_median)</span>
<span id="cb114-768"><a href="#cb114-768" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Filled missing 'school_dist' in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss"> using train median (</span><span class="sc">{</span>school_dist_median<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb114-769"><a href="#cb114-769" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb114-770"><a href="#cb114-770" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">" 'school_dist' not found in train_merged"</span>)</span>
<span id="cb114-771"><a href="#cb114-771" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-772"><a href="#cb114-772" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-773"><a href="#cb114-773" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-776"><a href="#cb114-776" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-777"><a href="#cb114-777" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-778"><a href="#cb114-778" aria-hidden="true" tabindex="-1"></a>    missing_pct <span class="op">=</span> train_merged[<span class="st">'year_built_final'</span>].isna().mean() <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb114-779"><a href="#cb114-779" aria-hidden="true" tabindex="-1"></a>    missing_count <span class="op">=</span> train_merged[<span class="st">'year_built_final'</span>].isna().<span class="bu">sum</span>()</span>
<span id="cb114-780"><a href="#cb114-780" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-781"><a href="#cb114-781" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" 'year_built_final' has </span><span class="sc">{</span>missing_count<span class="sc">}</span><span class="ss"> missing values (</span><span class="sc">{</span>missing_pct<span class="sc">:.2f}</span><span class="ss">%) in training set"</span>)</span>
<span id="cb114-782"><a href="#cb114-782" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb114-783"><a href="#cb114-783" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">" 'year_built_final' not found in training set"</span>)</span>
<span id="cb114-784"><a href="#cb114-784" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-785"><a href="#cb114-785" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-786"><a href="#cb114-786" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-789"><a href="#cb114-789" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-790"><a href="#cb114-790" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 0: Define base feature names ===</span></span>
<span id="cb114-791"><a href="#cb114-791" aria-hidden="true" tabindex="-1"></a>numeric_bases <span class="op">=</span> [</span>
<span id="cb114-792"><a href="#cb114-792" aria-hidden="true" tabindex="-1"></a>    <span class="st">'garage_area'</span>, <span class="st">'porch_area'</span>, <span class="st">'floors'</span>, <span class="st">'half_bath'</span>, <span class="st">'full_bath'</span>,</span>
<span id="cb114-793"><a href="#cb114-793" aria-hidden="true" tabindex="-1"></a>    <span class="st">'total_rooms'</span>, <span class="st">'bedrooms'</span>, <span class="st">'fireplaces'</span>, <span class="st">'building_area'</span>, <span class="st">'building_value'</span></span>
<span id="cb114-794"><a href="#cb114-794" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb114-795"><a href="#cb114-795" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-796"><a href="#cb114-796" aria-hidden="true" tabindex="-1"></a>categorical_fill_map <span class="op">=</span> {</span>
<span id="cb114-797"><a href="#cb114-797" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality'</span>: <span class="st">'None'</span>,</span>
<span id="cb114-798"><a href="#cb114-798" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality_description'</span>: <span class="st">'None'</span>,</span>
<span id="cb114-799"><a href="#cb114-799" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_condition'</span>: <span class="st">'None'</span>,</span>
<span id="cb114-800"><a href="#cb114-800" aria-hidden="true" tabindex="-1"></a>    <span class="st">'foundation_type'</span>: <span class="st">'None'</span>,</span>
<span id="cb114-801"><a href="#cb114-801" aria-hidden="true" tabindex="-1"></a>    <span class="st">'grade'</span>: <span class="st">'None'</span>,</span>
<span id="cb114-802"><a href="#cb114-802" aria-hidden="true" tabindex="-1"></a>    <span class="st">'has_cooling'</span>: <span class="va">False</span>,</span>
<span id="cb114-803"><a href="#cb114-803" aria-hidden="true" tabindex="-1"></a>    <span class="st">'has_heat'</span>: <span class="va">False</span>,</span>
<span id="cb114-804"><a href="#cb114-804" aria-hidden="true" tabindex="-1"></a>    <span class="st">'physical_condition'</span>: <span class="st">'None'</span>,</span>
<span id="cb114-805"><a href="#cb114-805" aria-hidden="true" tabindex="-1"></a>    <span class="st">'exterior_walls'</span>: <span class="st">'None'</span>,</span>
<span id="cb114-806"><a href="#cb114-806" aria-hidden="true" tabindex="-1"></a>    <span class="st">'protested'</span>: <span class="va">False</span></span>
<span id="cb114-807"><a href="#cb114-807" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb114-808"><a href="#cb114-808" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-809"><a href="#cb114-809" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate full list of columns (2015‚Äì2019 only, no final columns)</span></span>
<span id="cb114-810"><a href="#cb114-810" aria-hidden="true" tabindex="-1"></a>numeric_cols_to_zero <span class="op">=</span> [</span>
<span id="cb114-811"><a href="#cb114-811" aria-hidden="true" tabindex="-1"></a>    <span class="ss">f'</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> base <span class="kw">in</span> numeric_bases <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)</span>
<span id="cb114-812"><a href="#cb114-812" aria-hidden="true" tabindex="-1"></a>] <span class="op">+</span> [<span class="st">'building_value_growth'</span>]</span>
<span id="cb114-813"><a href="#cb114-813" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-814"><a href="#cb114-814" aria-hidden="true" tabindex="-1"></a>categorical_cols_to_fill <span class="op">=</span> {</span>
<span id="cb114-815"><a href="#cb114-815" aria-hidden="true" tabindex="-1"></a>    <span class="ss">f'</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">'</span>: val</span>
<span id="cb114-816"><a href="#cb114-816" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> base, val <span class="kw">in</span> categorical_fill_map.items()</span>
<span id="cb114-817"><a href="#cb114-817" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)</span>
<span id="cb114-818"><a href="#cb114-818" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb114-819"><a href="#cb114-819" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-820"><a href="#cb114-820" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 1: Apply imputation if floor_area_total_2019 == 0 ===</span></span>
<span id="cb114-821"><a href="#cb114-821" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb114-822"><a href="#cb114-822" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'floor_area_total_2019'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb114-823"><a href="#cb114-823" aria-hidden="true" tabindex="-1"></a>        zero_floor_mask <span class="op">=</span> df[<span class="st">'floor_area_total_2019'</span>] <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb114-824"><a href="#cb114-824" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-825"><a href="#cb114-825" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Fill numeric columns with 0</span></span>
<span id="cb114-826"><a href="#cb114-826" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> col <span class="kw">in</span> numeric_cols_to_zero:</span>
<span id="cb114-827"><a href="#cb114-827" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb114-828"><a href="#cb114-828" aria-hidden="true" tabindex="-1"></a>                df.loc[zero_floor_mask, col] <span class="op">=</span> df.loc[zero_floor_mask, col].fillna(<span class="dv">0</span>)</span>
<span id="cb114-829"><a href="#cb114-829" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-830"><a href="#cb114-830" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Fill categorical/boolean columns</span></span>
<span id="cb114-831"><a href="#cb114-831" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> col, fill_val <span class="kw">in</span> categorical_cols_to_fill.items():</span>
<span id="cb114-832"><a href="#cb114-832" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb114-833"><a href="#cb114-833" aria-hidden="true" tabindex="-1"></a>                df.loc[zero_floor_mask, col] <span class="op">=</span> df.loc[zero_floor_mask, col].fillna(fill_val)</span>
<span id="cb114-834"><a href="#cb114-834" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-835"><a href="#cb114-835" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Filled structure-dependent missing values in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss"> for </span><span class="sc">{</span>zero_floor_mask<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ss"> rows"</span>)</span>
<span id="cb114-836"><a href="#cb114-836" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb114-837"><a href="#cb114-837" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" 'floor_area_total_2019' not found in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-838"><a href="#cb114-838" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-839"><a href="#cb114-839" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-840"><a href="#cb114-840" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-841"><a href="#cb114-841" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-844"><a href="#cb114-844" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-845"><a href="#cb114-845" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb114-846"><a href="#cb114-846" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb114-847"><a href="#cb114-847" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> OrdinalEncoder</span>
<span id="cb114-848"><a href="#cb114-848" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> KFold</span>
<span id="cb114-849"><a href="#cb114-849" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-850"><a href="#cb114-850" aria-hidden="true" tabindex="-1"></a><span class="co"># Clear specific variables</span></span>
<span id="cb114-851"><a href="#cb114-851" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> var <span class="kw">in</span> [<span class="st">'ordinal_cols_all'</span>, <span class="st">'bool_cols_all'</span>]:</span>
<span id="cb114-852"><a href="#cb114-852" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> var <span class="kw">in</span> <span class="bu">locals</span>():</span>
<span id="cb114-853"><a href="#cb114-853" aria-hidden="true" tabindex="-1"></a>        <span class="kw">del</span> <span class="bu">globals</span>()[var]</span>
<span id="cb114-854"><a href="#cb114-854" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-855"><a href="#cb114-855" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 1: Boolean Encoding (2015‚Äì2019 only) ===</span></span>
<span id="cb114-856"><a href="#cb114-856" aria-hidden="true" tabindex="-1"></a>bool_bases <span class="op">=</span> [<span class="st">'has_cooling'</span>, <span class="st">'has_heat'</span>, <span class="st">'protested'</span>]</span>
<span id="cb114-857"><a href="#cb114-857" aria-hidden="true" tabindex="-1"></a>bool_cols_all <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> base <span class="kw">in</span> bool_bases <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)]</span>
<span id="cb114-858"><a href="#cb114-858" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-859"><a href="#cb114-859" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> bool_cols_all:</span>
<span id="cb114-860"><a href="#cb114-860" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-861"><a href="#cb114-861" aria-hidden="true" tabindex="-1"></a>        mode_val <span class="op">=</span> train_merged[col].mode(dropna<span class="op">=</span><span class="va">True</span>)[<span class="dv">0</span>]</span>
<span id="cb114-862"><a href="#cb114-862" aria-hidden="true" tabindex="-1"></a>        train_merged[col] <span class="op">=</span> train_merged[col].fillna(mode_val).astype(<span class="bu">int</span>)</span>
<span id="cb114-863"><a href="#cb114-863" aria-hidden="true" tabindex="-1"></a>        test_merged[col] <span class="op">=</span> test_merged[col].fillna(mode_val).astype(<span class="bu">int</span>)</span>
<span id="cb114-864"><a href="#cb114-864" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-865"><a href="#cb114-865" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 2: Ordinal Cleaning and Encoding (2015‚Äì2019 only) ===</span></span>
<span id="cb114-866"><a href="#cb114-866" aria-hidden="true" tabindex="-1"></a>ordinal_bases <span class="op">=</span> [</span>
<span id="cb114-867"><a href="#cb114-867" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality'</span>, <span class="st">'quality_description'</span>, <span class="st">'grade'</span>,</span>
<span id="cb114-868"><a href="#cb114-868" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_condition'</span>, <span class="st">'physical_condition'</span></span>
<span id="cb114-869"><a href="#cb114-869" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb114-870"><a href="#cb114-870" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-871"><a href="#cb114-871" aria-hidden="true" tabindex="-1"></a>ordinal_cols_all <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> base <span class="kw">in</span> ordinal_bases <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)]</span>
<span id="cb114-872"><a href="#cb114-872" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-873"><a href="#cb114-873" aria-hidden="true" tabindex="-1"></a><span class="co"># Column-specific replacements</span></span>
<span id="cb114-874"><a href="#cb114-874" aria-hidden="true" tabindex="-1"></a>replacement_maps <span class="op">=</span> {</span>
<span id="cb114-875"><a href="#cb114-875" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality'</span>: {<span class="st">'E'</span>: <span class="st">'D'</span>, <span class="st">'F'</span>: <span class="st">'D'</span>, <span class="st">'X'</span>: np.nan, <span class="st">'None'</span>: np.nan},</span>
<span id="cb114-876"><a href="#cb114-876" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality_description'</span>: {<span class="st">'Poor'</span>: <span class="st">'Very Low'</span>, <span class="st">'None'</span>: np.nan},</span>
<span id="cb114-877"><a href="#cb114-877" aria-hidden="true" tabindex="-1"></a>    <span class="st">'grade'</span>: {<span class="st">'X'</span>: <span class="st">'F'</span>, <span class="st">'X-'</span>: <span class="st">'F'</span>, <span class="st">'X+'</span>: <span class="st">'F'</span>, <span class="st">'E'</span>: <span class="st">'D'</span>, <span class="st">'E-'</span>: <span class="st">'D-'</span>, <span class="st">'E+'</span>: <span class="st">'D+'</span>, <span class="st">'None'</span>: np.nan},</span>
<span id="cb114-878"><a href="#cb114-878" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_condition'</span>: {<span class="st">'Very Poor'</span>: <span class="st">'Poor'</span>, <span class="st">'Unsound'</span>: <span class="st">'Poor'</span>, <span class="st">'None'</span>: np.nan},</span>
<span id="cb114-879"><a href="#cb114-879" aria-hidden="true" tabindex="-1"></a>    <span class="st">'physical_condition'</span>: {<span class="st">'Very Poor'</span>: <span class="st">'Poor'</span>, <span class="st">'Unsound'</span>: <span class="st">'Poor'</span>, <span class="st">'None'</span>: np.nan}</span>
<span id="cb114-880"><a href="#cb114-880" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb114-881"><a href="#cb114-881" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-882"><a href="#cb114-882" aria-hidden="true" tabindex="-1"></a><span class="co"># Ordinal category order</span></span>
<span id="cb114-883"><a href="#cb114-883" aria-hidden="true" tabindex="-1"></a>ord_categories <span class="op">=</span> {</span>
<span id="cb114-884"><a href="#cb114-884" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality'</span>: [<span class="st">'D'</span>, <span class="st">'C'</span>, <span class="st">'B'</span>, <span class="st">'A'</span>],</span>
<span id="cb114-885"><a href="#cb114-885" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality_description'</span>: [<span class="st">'Very Low'</span>, <span class="st">'Low'</span>, <span class="st">'Average'</span>, <span class="st">'Good'</span>, <span class="st">'Excellent'</span>, <span class="st">'Superior'</span>],</span>
<span id="cb114-886"><a href="#cb114-886" aria-hidden="true" tabindex="-1"></a>    <span class="st">'grade'</span>: [<span class="st">'F'</span>, <span class="st">'D-'</span>, <span class="st">'D'</span>, <span class="st">'D+'</span>, <span class="st">'C-'</span>, <span class="st">'C'</span>, <span class="st">'C+'</span>, <span class="st">'B-'</span>, <span class="st">'B'</span>, <span class="st">'B+'</span>, <span class="st">'A-'</span>, <span class="st">'A'</span>, <span class="st">'A+'</span>],</span>
<span id="cb114-887"><a href="#cb114-887" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_condition'</span>: [<span class="st">'Poor'</span>, <span class="st">'Fair'</span>, <span class="st">'Average'</span>, <span class="st">'Good'</span>, <span class="st">'Very Good'</span>, <span class="st">'Excellent'</span>],</span>
<span id="cb114-888"><a href="#cb114-888" aria-hidden="true" tabindex="-1"></a>    <span class="st">'physical_condition'</span>: [<span class="st">'Poor'</span>, <span class="st">'Fair'</span>, <span class="st">'Average'</span>, <span class="st">'Good'</span>, <span class="st">'Very Good'</span>, <span class="st">'Excellent'</span>]</span>
<span id="cb114-889"><a href="#cb114-889" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb114-890"><a href="#cb114-890" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-891"><a href="#cb114-891" aria-hidden="true" tabindex="-1"></a><span class="co"># Clean and encode</span></span>
<span id="cb114-892"><a href="#cb114-892" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> base <span class="kw">in</span> ordinal_bases:</span>
<span id="cb114-893"><a href="#cb114-893" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>):</span>
<span id="cb114-894"><a href="#cb114-894" aria-hidden="true" tabindex="-1"></a>        col <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb114-895"><a href="#cb114-895" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-896"><a href="#cb114-896" aria-hidden="true" tabindex="-1"></a>            replacements <span class="op">=</span> replacement_maps.get(base, {})</span>
<span id="cb114-897"><a href="#cb114-897" aria-hidden="true" tabindex="-1"></a>            train_merged[col] <span class="op">=</span> train_merged[col].replace(replacements)</span>
<span id="cb114-898"><a href="#cb114-898" aria-hidden="true" tabindex="-1"></a>            test_merged[col] <span class="op">=</span> test_merged[col].replace(replacements)</span>
<span id="cb114-899"><a href="#cb114-899" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-900"><a href="#cb114-900" aria-hidden="true" tabindex="-1"></a>            mode_val <span class="op">=</span> train_merged[col].mode(dropna<span class="op">=</span><span class="va">True</span>)[<span class="dv">0</span>]</span>
<span id="cb114-901"><a href="#cb114-901" aria-hidden="true" tabindex="-1"></a>            train_merged[col] <span class="op">=</span> train_merged[col].fillna(mode_val)</span>
<span id="cb114-902"><a href="#cb114-902" aria-hidden="true" tabindex="-1"></a>            test_merged[col] <span class="op">=</span> test_merged[col].fillna(mode_val)</span>
<span id="cb114-903"><a href="#cb114-903" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-904"><a href="#cb114-904" aria-hidden="true" tabindex="-1"></a>            encoder <span class="op">=</span> OrdinalEncoder(categories<span class="op">=</span>[ord_categories[base]], handle_unknown<span class="op">=</span><span class="st">'use_encoded_value'</span>, unknown_value<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb114-905"><a href="#cb114-905" aria-hidden="true" tabindex="-1"></a>            train_merged[[col]] <span class="op">=</span> encoder.fit_transform(train_merged[[col]])</span>
<span id="cb114-906"><a href="#cb114-906" aria-hidden="true" tabindex="-1"></a>            test_merged[[col]] <span class="op">=</span> encoder.transform(test_merged[[col]])</span>
<span id="cb114-907"><a href="#cb114-907" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-908"><a href="#cb114-908" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-909"><a href="#cb114-909" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-910"><a href="#cb114-910" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-913"><a href="#cb114-913" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-914"><a href="#cb114-914" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 3: Target Encoding (2015‚Äì2019 only) ===</span></span>
<span id="cb114-915"><a href="#cb114-915" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> group_and_target_encode_cv(train_df, test_df, target_name, column, rare_threshold<span class="op">=</span><span class="fl">0.001</span>, smoothing<span class="op">=</span><span class="dv">10</span>, n_splits<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb114-916"><a href="#cb114-916" aria-hidden="true" tabindex="-1"></a>    freq <span class="op">=</span> train_df[column].value_counts(normalize<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-917"><a href="#cb114-917" aria-hidden="true" tabindex="-1"></a>    rare_cats <span class="op">=</span> freq[freq <span class="op">&lt;</span> rare_threshold].index</span>
<span id="cb114-918"><a href="#cb114-918" aria-hidden="true" tabindex="-1"></a>    train_df[column] <span class="op">=</span> train_df[column].replace(rare_cats, <span class="st">'Other'</span>)</span>
<span id="cb114-919"><a href="#cb114-919" aria-hidden="true" tabindex="-1"></a>    test_df[column] <span class="op">=</span> test_df[column].replace(rare_cats, <span class="st">'Other'</span>)</span>
<span id="cb114-920"><a href="#cb114-920" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-921"><a href="#cb114-921" aria-hidden="true" tabindex="-1"></a>    global_mean <span class="op">=</span> train_df[target_name].mean()</span>
<span id="cb114-922"><a href="#cb114-922" aria-hidden="true" tabindex="-1"></a>    oof_encoded <span class="op">=</span> pd.Series(index<span class="op">=</span>train_df.index, dtype<span class="op">=</span><span class="st">'float64'</span>)</span>
<span id="cb114-923"><a href="#cb114-923" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-924"><a href="#cb114-924" aria-hidden="true" tabindex="-1"></a>    kf <span class="op">=</span> KFold(n_splits<span class="op">=</span>n_splits, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb114-925"><a href="#cb114-925" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> train_idx, val_idx <span class="kw">in</span> kf.split(train_df):</span>
<span id="cb114-926"><a href="#cb114-926" aria-hidden="true" tabindex="-1"></a>        X_tr, X_val <span class="op">=</span> train_df.iloc[train_idx], train_df.iloc[val_idx]</span>
<span id="cb114-927"><a href="#cb114-927" aria-hidden="true" tabindex="-1"></a>        stats <span class="op">=</span> X_tr.groupby(column)[target_name].agg([<span class="st">'mean'</span>, <span class="st">'count'</span>])</span>
<span id="cb114-928"><a href="#cb114-928" aria-hidden="true" tabindex="-1"></a>        smooth <span class="op">=</span> (stats[<span class="st">'mean'</span>] <span class="op">*</span> stats[<span class="st">'count'</span>] <span class="op">+</span> global_mean <span class="op">*</span> smoothing) <span class="op">/</span> (stats[<span class="st">'count'</span>] <span class="op">+</span> smoothing)</span>
<span id="cb114-929"><a href="#cb114-929" aria-hidden="true" tabindex="-1"></a>        oof_encoded.iloc[val_idx] <span class="op">=</span> X_val[column].<span class="bu">map</span>(smooth).fillna(global_mean)</span>
<span id="cb114-930"><a href="#cb114-930" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-931"><a href="#cb114-931" aria-hidden="true" tabindex="-1"></a>    final_stats <span class="op">=</span> train_df.groupby(column)[target_name].agg([<span class="st">'mean'</span>, <span class="st">'count'</span>])</span>
<span id="cb114-932"><a href="#cb114-932" aria-hidden="true" tabindex="-1"></a>    final_smooth <span class="op">=</span> (final_stats[<span class="st">'mean'</span>] <span class="op">*</span> final_stats[<span class="st">'count'</span>] <span class="op">+</span> global_mean <span class="op">*</span> smoothing) <span class="op">/</span> (final_stats[<span class="st">'count'</span>] <span class="op">+</span> smoothing)</span>
<span id="cb114-933"><a href="#cb114-933" aria-hidden="true" tabindex="-1"></a>    test_encoded <span class="op">=</span> test_df[column].<span class="bu">map</span>(final_smooth).fillna(global_mean)</span>
<span id="cb114-934"><a href="#cb114-934" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-935"><a href="#cb114-935" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> oof_encoded, test_encoded</span>
<span id="cb114-936"><a href="#cb114-936" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-937"><a href="#cb114-937" aria-hidden="true" tabindex="-1"></a><span class="co"># Target-encodable nominal columns</span></span>
<span id="cb114-938"><a href="#cb114-938" aria-hidden="true" tabindex="-1"></a>target_encodable_bases <span class="op">=</span> [<span class="st">'foundation_type'</span>, <span class="st">'exterior_walls'</span>]</span>
<span id="cb114-939"><a href="#cb114-939" aria-hidden="true" tabindex="-1"></a>target_encodable_cols_all <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> base <span class="kw">in</span> target_encodable_bases <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)]</span>
<span id="cb114-940"><a href="#cb114-940" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-941"><a href="#cb114-941" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply target encoding</span></span>
<span id="cb114-942"><a href="#cb114-942" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> target_encodable_cols_all:</span>
<span id="cb114-943"><a href="#cb114-943" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-944"><a href="#cb114-944" aria-hidden="true" tabindex="-1"></a>        mode_val <span class="op">=</span> train_merged[col].mode(dropna<span class="op">=</span><span class="va">True</span>)[<span class="dv">0</span>]</span>
<span id="cb114-945"><a href="#cb114-945" aria-hidden="true" tabindex="-1"></a>        train_merged[col] <span class="op">=</span> train_merged[col].fillna(mode_val)</span>
<span id="cb114-946"><a href="#cb114-946" aria-hidden="true" tabindex="-1"></a>        test_merged[col] <span class="op">=</span> test_merged[col].fillna(mode_val)</span>
<span id="cb114-947"><a href="#cb114-947" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-948"><a href="#cb114-948" aria-hidden="true" tabindex="-1"></a>        train_merged[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_te'</span>], test_merged[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_te'</span>] <span class="op">=</span> group_and_target_encode_cv(</span>
<span id="cb114-949"><a href="#cb114-949" aria-hidden="true" tabindex="-1"></a>            train_merged, test_merged, target_name<span class="op">=</span><span class="st">'assessed_2018'</span>, column<span class="op">=</span>col,</span>
<span id="cb114-950"><a href="#cb114-950" aria-hidden="true" tabindex="-1"></a>            rare_threshold<span class="op">=</span><span class="fl">0.001</span>, smoothing<span class="op">=</span><span class="dv">10</span>, n_splits<span class="op">=</span><span class="dv">5</span></span>
<span id="cb114-951"><a href="#cb114-951" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb114-952"><a href="#cb114-952" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-953"><a href="#cb114-953" aria-hidden="true" tabindex="-1"></a>        train_merged.drop(columns<span class="op">=</span>[col], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-954"><a href="#cb114-954" aria-hidden="true" tabindex="-1"></a>        test_merged.drop(columns<span class="op">=</span>[col], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-955"><a href="#cb114-955" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-956"><a href="#cb114-956" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Done: Boolean, Ordinal, and Target Encoding for 2015‚Äì2019 features only."</span>)</span>
<span id="cb114-957"><a href="#cb114-957" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-958"><a href="#cb114-958" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-961"><a href="#cb114-961" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-962"><a href="#cb114-962" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1: Get growth columns from training set</span></span>
<span id="cb114-963"><a href="#cb114-963" aria-hidden="true" tabindex="-1"></a>growth_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> <span class="st">'_growth'</span> <span class="kw">in</span> col]</span>
<span id="cb114-964"><a href="#cb114-964" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-965"><a href="#cb114-965" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 2: Compute medians from train_merged only</span></span>
<span id="cb114-966"><a href="#cb114-966" aria-hidden="true" tabindex="-1"></a>growth_medians <span class="op">=</span> {col: train_merged[col].median() <span class="cf">for</span> col <span class="kw">in</span> growth_cols}</span>
<span id="cb114-967"><a href="#cb114-967" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-968"><a href="#cb114-968" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 3: Apply to both train and test</span></span>
<span id="cb114-969"><a href="#cb114-969" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb114-970"><a href="#cb114-970" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> col <span class="kw">in</span> growth_cols:</span>
<span id="cb114-971"><a href="#cb114-971" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb114-972"><a href="#cb114-972" aria-hidden="true" tabindex="-1"></a>            df[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_missing'</span>] <span class="op">=</span> df[col].isna().astype(<span class="bu">int</span>)</span>
<span id="cb114-973"><a href="#cb114-973" aria-hidden="true" tabindex="-1"></a>            df[col].fillna(growth_medians[col], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-974"><a href="#cb114-974" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Filled and flagged missing values in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss"> for: </span><span class="sc">{</span>growth_cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-975"><a href="#cb114-975" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-976"><a href="#cb114-976" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-977"><a href="#cb114-977" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-980"><a href="#cb114-980" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-981"><a href="#cb114-981" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 1: List your growth features ===</span></span>
<span id="cb114-982"><a href="#cb114-982" aria-hidden="true" tabindex="-1"></a>growth_features <span class="op">=</span> [<span class="st">'land_value_growth'</span>, <span class="st">'building_value_growth'</span>, <span class="st">'assessed_growth'</span>]</span>
<span id="cb114-983"><a href="#cb114-983" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-984"><a href="#cb114-984" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 2: Binning Function (train-based binning) ===</span></span>
<span id="cb114-985"><a href="#cb114-985" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bin_growth_feature_safe(train_df, test_df, feature, bins<span class="op">=</span><span class="dv">4</span>):</span>
<span id="cb114-986"><a href="#cb114-986" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb114-987"><a href="#cb114-987" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Quantile binning on train only</span></span>
<span id="cb114-988"><a href="#cb114-988" aria-hidden="true" tabindex="-1"></a>        train_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>], bin_edges <span class="op">=</span> pd.qcut(train_df[feature], q<span class="op">=</span>bins, labels<span class="op">=</span><span class="va">False</span>, retbins<span class="op">=</span><span class="va">True</span>, duplicates<span class="op">=</span><span class="st">'drop'</span>)</span>
<span id="cb114-989"><a href="#cb114-989" aria-hidden="true" tabindex="-1"></a>        test_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>] <span class="op">=</span> pd.cut(test_df[feature], bins<span class="op">=</span>bin_edges, labels<span class="op">=</span><span class="va">False</span>, include_lowest<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-990"><a href="#cb114-990" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">ValueError</span>:</span>
<span id="cb114-991"><a href="#cb114-991" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Fallback: Equal-width binning</span></span>
<span id="cb114-992"><a href="#cb114-992" aria-hidden="true" tabindex="-1"></a>        min_val <span class="op">=</span> train_df[feature].<span class="bu">min</span>()</span>
<span id="cb114-993"><a href="#cb114-993" aria-hidden="true" tabindex="-1"></a>        max_val <span class="op">=</span> train_df[feature].<span class="bu">max</span>()</span>
<span id="cb114-994"><a href="#cb114-994" aria-hidden="true" tabindex="-1"></a>        bin_edges <span class="op">=</span> np.linspace(min_val, max_val, bins <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb114-995"><a href="#cb114-995" aria-hidden="true" tabindex="-1"></a>        train_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>] <span class="op">=</span> pd.cut(train_df[feature], bins<span class="op">=</span>bin_edges, labels<span class="op">=</span><span class="va">False</span>, include_lowest<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-996"><a href="#cb114-996" aria-hidden="true" tabindex="-1"></a>        test_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>] <span class="op">=</span> pd.cut(test_df[feature], bins<span class="op">=</span>bin_edges, labels<span class="op">=</span><span class="va">False</span>, include_lowest<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-997"><a href="#cb114-997" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-998"><a href="#cb114-998" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert to category</span></span>
<span id="cb114-999"><a href="#cb114-999" aria-hidden="true" tabindex="-1"></a>    train_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>] <span class="op">=</span> train_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>].astype(<span class="st">'category'</span>)</span>
<span id="cb114-1000"><a href="#cb114-1000" aria-hidden="true" tabindex="-1"></a>    test_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>] <span class="op">=</span> test_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>].astype(<span class="st">'category'</span>)</span>
<span id="cb114-1001"><a href="#cb114-1001" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> train_df, test_df</span>
<span id="cb114-1002"><a href="#cb114-1002" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1003"><a href="#cb114-1003" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 3: Apply to train_merged and test_merged ===</span></span>
<span id="cb114-1004"><a href="#cb114-1004" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> feature <span class="kw">in</span> growth_features:</span>
<span id="cb114-1005"><a href="#cb114-1005" aria-hidden="true" tabindex="-1"></a>    train_merged, test_merged <span class="op">=</span> bin_growth_feature_safe(train_merged, test_merged, feature)</span>
<span id="cb114-1006"><a href="#cb114-1006" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1007"><a href="#cb114-1007" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 4: Bin year_built_final using train-based quantiles ===</span></span>
<span id="cb114-1008"><a href="#cb114-1008" aria-hidden="true" tabindex="-1"></a>train_merged[<span class="st">'year_built_bin'</span>], bin_edges <span class="op">=</span> pd.qcut(</span>
<span id="cb114-1009"><a href="#cb114-1009" aria-hidden="true" tabindex="-1"></a>    train_merged[<span class="st">'year_built_final'</span>], q<span class="op">=</span><span class="dv">5</span>, retbins<span class="op">=</span><span class="va">True</span>, labels<span class="op">=</span><span class="va">False</span>, duplicates<span class="op">=</span><span class="st">'drop'</span></span>
<span id="cb114-1010"><a href="#cb114-1010" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb114-1011"><a href="#cb114-1011" aria-hidden="true" tabindex="-1"></a>test_merged[<span class="st">'year_built_bin'</span>] <span class="op">=</span> pd.cut(</span>
<span id="cb114-1012"><a href="#cb114-1012" aria-hidden="true" tabindex="-1"></a>    test_merged[<span class="st">'year_built_final'</span>], bins<span class="op">=</span>bin_edges, labels<span class="op">=</span><span class="va">False</span>, include_lowest<span class="op">=</span><span class="va">True</span></span>
<span id="cb114-1013"><a href="#cb114-1013" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb114-1014"><a href="#cb114-1014" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1015"><a href="#cb114-1015" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert to category</span></span>
<span id="cb114-1016"><a href="#cb114-1016" aria-hidden="true" tabindex="-1"></a>train_merged[<span class="st">'year_built_bin'</span>] <span class="op">=</span> train_merged[<span class="st">'year_built_bin'</span>].astype(<span class="st">'category'</span>)</span>
<span id="cb114-1017"><a href="#cb114-1017" aria-hidden="true" tabindex="-1"></a>test_merged[<span class="st">'year_built_bin'</span>] <span class="op">=</span> test_merged[<span class="st">'year_built_bin'</span>].astype(<span class="st">'category'</span>)</span>
<span id="cb114-1018"><a href="#cb114-1018" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1019"><a href="#cb114-1019" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 5: Drop original continuous columns ===</span></span>
<span id="cb114-1020"><a href="#cb114-1020" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> growth_features <span class="op">+</span> [<span class="st">'year_built_final'</span>]</span>
<span id="cb114-1021"><a href="#cb114-1021" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-1022"><a href="#cb114-1022" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-1023"><a href="#cb114-1023" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1024"><a href="#cb114-1024" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Binned growth &amp; year_built features safely with no leakage."</span>)</span>
<span id="cb114-1025"><a href="#cb114-1025" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1026"><a href="#cb114-1026" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1027"><a href="#cb114-1027" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1028"><a href="#cb114-1028" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1031"><a href="#cb114-1031" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1032"><a href="#cb114-1032" aria-hidden="true" tabindex="-1"></a>rare_threshold <span class="op">=</span> <span class="fl">0.001</span>  <span class="co"># 0.1%</span></span>
<span id="cb114-1033"><a href="#cb114-1033" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1034"><a href="#cb114-1034" aria-hidden="true" tabindex="-1"></a>cat_cols <span class="op">=</span> [</span>
<span id="cb114-1035"><a href="#cb114-1035" aria-hidden="true" tabindex="-1"></a>    <span class="st">"quality_description_final"</span>,</span>
<span id="cb114-1036"><a href="#cb114-1036" aria-hidden="true" tabindex="-1"></a>    <span class="st">"foundation_type_final_te"</span>,</span>
<span id="cb114-1037"><a href="#cb114-1037" aria-hidden="true" tabindex="-1"></a>    <span class="st">"physical_condition_final"</span>,</span>
<span id="cb114-1038"><a href="#cb114-1038" aria-hidden="true" tabindex="-1"></a>    <span class="st">"exterior_walls_final_te"</span>,</span>
<span id="cb114-1039"><a href="#cb114-1039" aria-hidden="true" tabindex="-1"></a>    <span class="st">"region_freq"</span>,</span>
<span id="cb114-1040"><a href="#cb114-1040" aria-hidden="true" tabindex="-1"></a>    <span class="st">"neighborhood_freq"</span></span>
<span id="cb114-1041"><a href="#cb114-1041" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb114-1042"><a href="#cb114-1042" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1043"><a href="#cb114-1043" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> cat_cols:</span>
<span id="cb114-1044"><a href="#cb114-1044" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-1045"><a href="#cb114-1045" aria-hidden="true" tabindex="-1"></a>        freq <span class="op">=</span> train_merged[col].value_counts(normalize<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-1046"><a href="#cb114-1046" aria-hidden="true" tabindex="-1"></a>        rare <span class="op">=</span> freq[freq <span class="op">&lt;</span> rare_threshold]</span>
<span id="cb114-1047"><a href="#cb114-1047" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> rare.empty:</span>
<span id="cb114-1048"><a href="#cb114-1048" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss"> Rare categories in '</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">' (less than 0.1% of training data):</span><span class="ch">\n</span><span class="sc">{</span>rare<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1049"><a href="#cb114-1049" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb114-1050"><a href="#cb114-1050" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Column '</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">' not found in train_merged"</span>)</span>
<span id="cb114-1051"><a href="#cb114-1051" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1052"><a href="#cb114-1052" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1053"><a href="#cb114-1053" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1054"><a href="#cb114-1054" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1055"><a href="#cb114-1055" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1058"><a href="#cb114-1058" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1059"><a href="#cb114-1059" aria-hidden="true" tabindex="-1"></a><span class="co"># Define frequency columns and threshold</span></span>
<span id="cb114-1060"><a href="#cb114-1060" aria-hidden="true" tabindex="-1"></a>freq_cols <span class="op">=</span> [<span class="st">'region_freq'</span>, <span class="st">'neighborhood_freq'</span>, <span class="st">'zone_freq'</span>, <span class="st">'subneighborhood_freq'</span>]</span>
<span id="cb114-1061"><a href="#cb114-1061" aria-hidden="true" tabindex="-1"></a>rare_thresh <span class="op">=</span> <span class="fl">0.001</span></span>
<span id="cb114-1062"><a href="#cb114-1062" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1063"><a href="#cb114-1063" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply rare value replacement for each frequency column</span></span>
<span id="cb114-1064"><a href="#cb114-1064" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> freq_cols:</span>
<span id="cb114-1065"><a href="#cb114-1065" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-1066"><a href="#cb114-1066" aria-hidden="true" tabindex="-1"></a>        rare_vals <span class="op">=</span> train_merged[col].value_counts(normalize<span class="op">=</span><span class="va">True</span>)[<span class="kw">lambda</span> x: x <span class="op">&lt;</span> rare_thresh].index</span>
<span id="cb114-1067"><a href="#cb114-1067" aria-hidden="true" tabindex="-1"></a>        train_merged[col] <span class="op">=</span> train_merged[col].replace(rare_vals, <span class="dv">0</span>)</span>
<span id="cb114-1068"><a href="#cb114-1068" aria-hidden="true" tabindex="-1"></a>        test_merged[col] <span class="op">=</span> test_merged[col].replace(rare_vals, <span class="dv">0</span>)</span>
<span id="cb114-1069"><a href="#cb114-1069" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Replaced rare values in </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> using train_merged threshold &lt; </span><span class="sc">{</span>rare_thresh<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1070"><a href="#cb114-1070" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb114-1071"><a href="#cb114-1071" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Column </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> not found in train_merged ‚Äî skipping."</span>)</span>
<span id="cb114-1072"><a href="#cb114-1072" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1073"><a href="#cb114-1073" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1074"><a href="#cb114-1074" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1075"><a href="#cb114-1075" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1078"><a href="#cb114-1078" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1079"><a href="#cb114-1079" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb114-1080"><a href="#cb114-1080" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1081"><a href="#cb114-1081" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 1: Skew-based Log Transformation (2015‚Äì2019 only) ===</span></span>
<span id="cb114-1082"><a href="#cb114-1082" aria-hidden="true" tabindex="-1"></a>log_bases <span class="op">=</span> [</span>
<span id="cb114-1083"><a href="#cb114-1083" aria-hidden="true" tabindex="-1"></a>    <span class="st">'floor_area_total'</span>, <span class="st">'porch_area'</span>, <span class="st">'building_area'</span>, <span class="st">'land_area'</span>,</span>
<span id="cb114-1084"><a href="#cb114-1084" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_value'</span>, <span class="st">'land_value'</span>, <span class="st">'assessed'</span></span>
<span id="cb114-1085"><a href="#cb114-1085" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb114-1086"><a href="#cb114-1086" aria-hidden="true" tabindex="-1"></a>neigh_stat_cols <span class="op">=</span> [</span>
<span id="cb114-1087"><a href="#cb114-1087" aria-hidden="true" tabindex="-1"></a>    <span class="st">'neigh_assess_mean'</span>, <span class="st">'neigh_assess_std'</span>, <span class="st">'neigh_assess_median'</span>,</span>
<span id="cb114-1088"><a href="#cb114-1088" aria-hidden="true" tabindex="-1"></a>    <span class="st">'neigh_assess_q1'</span>, <span class="st">'neigh_assess_q3'</span></span>
<span id="cb114-1089"><a href="#cb114-1089" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb114-1090"><a href="#cb114-1090" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1091"><a href="#cb114-1091" aria-hidden="true" tabindex="-1"></a><span class="co"># Collect log-transformable columns (2015‚Äì2019 + neighborhood stats)</span></span>
<span id="cb114-1092"><a href="#cb114-1092" aria-hidden="true" tabindex="-1"></a>log_transform_cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> base <span class="kw">in</span> log_bases <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)]</span>
<span id="cb114-1093"><a href="#cb114-1093" aria-hidden="true" tabindex="-1"></a>log_transform_cols <span class="op">+=</span> neigh_stat_cols</span>
<span id="cb114-1094"><a href="#cb114-1094" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1095"><a href="#cb114-1095" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute skewness on train and apply log1p only if skew &gt; 2</span></span>
<span id="cb114-1096"><a href="#cb114-1096" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> log_transform_cols:</span>
<span id="cb114-1097"><a href="#cb114-1097" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-1098"><a href="#cb114-1098" aria-hidden="true" tabindex="-1"></a>        skew <span class="op">=</span> train_merged[col].skew()</span>
<span id="cb114-1099"><a href="#cb114-1099" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> skew <span class="op">&gt;</span> <span class="dv">2</span>:</span>
<span id="cb114-1100"><a href="#cb114-1100" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> df <span class="kw">in</span> [train_merged, test_merged]:</span>
<span id="cb114-1101"><a href="#cb114-1101" aria-hidden="true" tabindex="-1"></a>                df[<span class="ss">f"log_</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">"</span>] <span class="op">=</span> np.log1p(df[col])</span>
<span id="cb114-1102"><a href="#cb114-1102" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Log-transformed: </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> (skew=</span><span class="sc">{</span>skew<span class="sc">:.2f}</span><span class="ss">)"</span>)</span>
<span id="cb114-1103"><a href="#cb114-1103" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb114-1104"><a href="#cb114-1104" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"‚Ñπ Skipped: </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> (skew=</span><span class="sc">{</span>skew<span class="sc">:.2f}</span><span class="ss">)"</span>)</span>
<span id="cb114-1105"><a href="#cb114-1105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1106"><a href="#cb114-1106" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 2: Percentile Clipping at 0.1%‚Äì99.9% ===</span></span>
<span id="cb114-1107"><a href="#cb114-1107" aria-hidden="true" tabindex="-1"></a>clip_bases <span class="op">=</span> [<span class="st">'floors'</span>, <span class="st">'full_bath'</span>, <span class="st">'total_rooms'</span>, <span class="st">'bedrooms'</span>]</span>
<span id="cb114-1108"><a href="#cb114-1108" aria-hidden="true" tabindex="-1"></a>clip_cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> base <span class="kw">in</span> clip_bases <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)]</span>
<span id="cb114-1109"><a href="#cb114-1109" aria-hidden="true" tabindex="-1"></a>clip_cols <span class="op">+=</span> [<span class="st">'neigh_count'</span>]  <span class="co"># add any other specific columns if needed</span></span>
<span id="cb114-1110"><a href="#cb114-1110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1111"><a href="#cb114-1111" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute clipping bounds from train</span></span>
<span id="cb114-1112"><a href="#cb114-1112" aria-hidden="true" tabindex="-1"></a>clip_bounds <span class="op">=</span> {</span>
<span id="cb114-1113"><a href="#cb114-1113" aria-hidden="true" tabindex="-1"></a>    col: (</span>
<span id="cb114-1114"><a href="#cb114-1114" aria-hidden="true" tabindex="-1"></a>        train_merged[col].quantile(<span class="fl">0.001</span>),</span>
<span id="cb114-1115"><a href="#cb114-1115" aria-hidden="true" tabindex="-1"></a>        train_merged[col].quantile(<span class="fl">0.999</span>)</span>
<span id="cb114-1116"><a href="#cb114-1116" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb114-1117"><a href="#cb114-1117" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> col <span class="kw">in</span> clip_cols <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns</span>
<span id="cb114-1118"><a href="#cb114-1118" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb114-1119"><a href="#cb114-1119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1120"><a href="#cb114-1120" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply clipping to both train and test</span></span>
<span id="cb114-1121"><a href="#cb114-1121" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col, (lower, upper) <span class="kw">in</span> clip_bounds.items():</span>
<span id="cb114-1122"><a href="#cb114-1122" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> df <span class="kw">in</span> [train_merged, test_merged]:</span>
<span id="cb114-1123"><a href="#cb114-1123" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb114-1124"><a href="#cb114-1124" aria-hidden="true" tabindex="-1"></a>            df[col] <span class="op">=</span> np.clip(df[col], lower, upper)</span>
<span id="cb114-1125"><a href="#cb114-1125" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Clipped: </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> to [</span><span class="sc">{</span>lower<span class="sc">:.2f}</span><span class="ss">, </span><span class="sc">{</span>upper<span class="sc">:.2f}</span><span class="ss">]"</span>)</span>
<span id="cb114-1126"><a href="#cb114-1126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1127"><a href="#cb114-1127" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> Finished: Skew-aware log transformation + 0.001‚Äì0.999 percentile clipping."</span>)</span>
<span id="cb114-1128"><a href="#cb114-1128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1129"><a href="#cb114-1129" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1130"><a href="#cb114-1130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1133"><a href="#cb114-1133" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1134"><a href="#cb114-1134" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add_features(df):</span>
<span id="cb114-1135"><a href="#cb114-1135" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.copy()</span>
<span id="cb114-1136"><a href="#cb114-1136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1137"><a href="#cb114-1137" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Ratio features ===</span></span>
<span id="cb114-1138"><a href="#cb114-1138" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'area_ratio'</span>] <span class="op">=</span> df[<span class="st">'building_area_2019'</span>] <span class="op">/</span> (df[<span class="st">'land_area_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb114-1139"><a href="#cb114-1139" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'porch_ratio'</span>] <span class="op">=</span> df[<span class="st">'porch_area_2019'</span>] <span class="op">/</span> (df[<span class="st">'building_area_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb114-1140"><a href="#cb114-1140" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'floor_density'</span>] <span class="op">=</span> df[<span class="st">'floor_area_total_2019'</span>] <span class="op">/</span> (df[<span class="st">'land_area_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb114-1141"><a href="#cb114-1141" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'log_build_density'</span>] <span class="op">=</span> df[<span class="st">'log_building_area_2019'</span>] <span class="op">-</span> df[<span class="st">'log_land_area_2019'</span>]</span>
<span id="cb114-1142"><a href="#cb114-1142" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'log_land_to_build_ratio'</span>] <span class="op">=</span> df[<span class="st">'log_land_area_2019'</span>] <span class="op">-</span> df[<span class="st">'log_building_area_2019'</span>]</span>
<span id="cb114-1143"><a href="#cb114-1143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1144"><a href="#cb114-1144" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'value_ratio'</span>] <span class="op">=</span> df[<span class="st">'building_value_2018'</span>] <span class="op">/</span> (df[<span class="st">'land_value_2018'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb114-1145"><a href="#cb114-1145" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'log_value_diff'</span>] <span class="op">=</span> df[<span class="st">'log_building_value_2018'</span>] <span class="op">-</span> df[<span class="st">'log_land_value_2018'</span>]</span>
<span id="cb114-1146"><a href="#cb114-1146" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'value_per_sqft'</span>] <span class="op">=</span> df[<span class="st">'building_value_2018'</span>] <span class="op">/</span> (df[<span class="st">'building_area_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb114-1147"><a href="#cb114-1147" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'price_per_sqft'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">/</span> (df[<span class="st">'building_area_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb114-1148"><a href="#cb114-1148" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1149"><a href="#cb114-1149" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Bathroom &amp; room structure ===</span></span>
<span id="cb114-1150"><a href="#cb114-1150" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'bathroom_score'</span>] <span class="op">=</span> df[<span class="st">'full_bath_2019'</span>] <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> df[<span class="st">'half_bath_2019'</span>]</span>
<span id="cb114-1151"><a href="#cb114-1151" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'bathroom_density'</span>] <span class="op">=</span> df[<span class="st">'bathroom_score'</span>] <span class="op">/</span> (df[<span class="st">'total_rooms_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb114-1152"><a href="#cb114-1152" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'bedroom_ratio'</span>] <span class="op">=</span> df[<span class="st">'bedrooms_2019'</span>] <span class="op">/</span> (df[<span class="st">'total_rooms_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb114-1153"><a href="#cb114-1153" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'rooms_per_floor'</span>] <span class="op">=</span> df[<span class="st">'total_rooms_2019'</span>] <span class="op">/</span> (df[<span class="st">'floors_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb114-1154"><a href="#cb114-1154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1155"><a href="#cb114-1155" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Core interactions ===</span></span>
<span id="cb114-1156"><a href="#cb114-1156" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'bedrooms_x_floors'</span>] <span class="op">=</span> df[<span class="st">'bedrooms_2019'</span>] <span class="op">*</span> df[<span class="st">'floors_2019'</span>]</span>
<span id="cb114-1157"><a href="#cb114-1157" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'rooms_x_quality'</span>] <span class="op">=</span> df[<span class="st">'total_rooms_2019'</span>] <span class="op">*</span> df[<span class="st">'quality_2019'</span>]</span>
<span id="cb114-1158"><a href="#cb114-1158" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'log_area_x_grade'</span>] <span class="op">=</span> df[<span class="st">'log_building_area_2019'</span>] <span class="op">*</span> df[<span class="st">'grade_2019'</span>]</span>
<span id="cb114-1159"><a href="#cb114-1159" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'log_assess_x_age'</span>] <span class="op">=</span> df[<span class="st">'log_assessed_2018'</span>] <span class="op">*</span> df[<span class="st">'building_age'</span>]</span>
<span id="cb114-1160"><a href="#cb114-1160" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'assess_spread_neigh'</span>] <span class="op">=</span> df[<span class="st">'log_neigh_assess_q3'</span>] <span class="op">-</span> df[<span class="st">'log_neigh_assess_q1'</span>]</span>
<span id="cb114-1161"><a href="#cb114-1161" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'grade_quality_index'</span>] <span class="op">=</span> df[<span class="st">'grade_2019'</span>] <span class="op">*</span> df[<span class="st">'quality_2019'</span>]</span>
<span id="cb114-1162"><a href="#cb114-1162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1163"><a href="#cb114-1163" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Clean up ===</span></span>
<span id="cb114-1164"><a href="#cb114-1164" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.replace([np.inf, <span class="op">-</span>np.inf], np.nan)</span>
<span id="cb114-1165"><a href="#cb114-1165" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.fillna(<span class="dv">0</span>)</span>
<span id="cb114-1166"><a href="#cb114-1166" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb114-1167"><a href="#cb114-1167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1168"><a href="#cb114-1168" aria-hidden="true" tabindex="-1"></a><span class="co"># === Apply to train and test ===</span></span>
<span id="cb114-1169"><a href="#cb114-1169" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> add_features(train_merged)</span>
<span id="cb114-1170"><a href="#cb114-1170" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> add_features(test_merged)</span>
<span id="cb114-1171"><a href="#cb114-1171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1172"><a href="#cb114-1172" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1173"><a href="#cb114-1173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1176"><a href="#cb114-1176" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1177"><a href="#cb114-1177" aria-hidden="true" tabindex="-1"></a><span class="co"># Select numeric columns only</span></span>
<span id="cb114-1178"><a href="#cb114-1178" aria-hidden="true" tabindex="-1"></a>numeric_features <span class="op">=</span> train_merged.select_dtypes(include<span class="op">=</span>[<span class="st">'int64'</span>, <span class="st">'float64'</span>])</span>
<span id="cb114-1179"><a href="#cb114-1179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1180"><a href="#cb114-1180" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate skewness</span></span>
<span id="cb114-1181"><a href="#cb114-1181" aria-hidden="true" tabindex="-1"></a>skewness <span class="op">=</span> numeric_features.skew(numeric_only<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-1182"><a href="#cb114-1182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1183"><a href="#cb114-1183" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter and sort features with skewness &gt; 30</span></span>
<span id="cb114-1184"><a href="#cb114-1184" aria-hidden="true" tabindex="-1"></a>highly_skewed <span class="op">=</span> skewness[skewness <span class="op">&gt;</span> <span class="dv">2</span>].sort_values(ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb114-1185"><a href="#cb114-1185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1186"><a href="#cb114-1186" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Features with skewness &gt; 2:"</span>)</span>
<span id="cb114-1187"><a href="#cb114-1187" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(highly_skewed)</span>
<span id="cb114-1188"><a href="#cb114-1188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1189"><a href="#cb114-1189" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1190"><a href="#cb114-1190" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1191"><a href="#cb114-1191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1194"><a href="#cb114-1194" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1195"><a href="#cb114-1195" aria-hidden="true" tabindex="-1"></a><span class="co"># List of columns to drop due to extreme skewness</span></span>
<span id="cb114-1196"><a href="#cb114-1196" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> [<span class="st">'building_value_growth_missing'</span>, <span class="st">'land_value_growth_missing'</span>,<span class="st">'assessed_growth_missing'</span>]</span>
<span id="cb114-1197"><a href="#cb114-1197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1198"><a href="#cb114-1198" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop from both train and test</span></span>
<span id="cb114-1199"><a href="#cb114-1199" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>, errors<span class="op">=</span><span class="st">'ignore'</span>)</span>
<span id="cb114-1200"><a href="#cb114-1200" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>, errors<span class="op">=</span><span class="st">'ignore'</span>)</span>
<span id="cb114-1201"><a href="#cb114-1201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1202"><a href="#cb114-1202" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Dropped extremely skewed columns related to value growth missingness."</span>)</span>
<span id="cb114-1203"><a href="#cb114-1203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1204"><a href="#cb114-1204" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1205"><a href="#cb114-1205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1208"><a href="#cb114-1208" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1209"><a href="#cb114-1209" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb114-1210"><a href="#cb114-1210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1211"><a href="#cb114-1211" aria-hidden="true" tabindex="-1"></a><span class="co"># Features to log-transform due to extreme skew</span></span>
<span id="cb114-1212"><a href="#cb114-1212" aria-hidden="true" tabindex="-1"></a>skewed_cols <span class="op">=</span> [<span class="st">'price_per_sqft'</span>, <span class="st">'value_per_sqft'</span>, <span class="st">'porch_ratio'</span>, <span class="st">'value_ratio'</span>,<span class="st">'land_area_2015'</span>,<span class="st">'land_area_2016'</span>,<span class="st">'land_area_2017'</span>,<span class="st">'land_area_2018'</span>,<span class="st">'land_area_2019'</span>]</span>
<span id="cb114-1213"><a href="#cb114-1213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1214"><a href="#cb114-1214" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb114-1215"><a href="#cb114-1215" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> col <span class="kw">in</span> skewed_cols:</span>
<span id="cb114-1216"><a href="#cb114-1216" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb114-1217"><a href="#cb114-1217" aria-hidden="true" tabindex="-1"></a>            df[<span class="ss">f'log_</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">'</span>] <span class="op">=</span> np.log1p(df[col])</span>
<span id="cb114-1218"><a href="#cb114-1218" aria-hidden="true" tabindex="-1"></a>            df.drop(columns<span class="op">=</span>col, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-1219"><a href="#cb114-1219" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1220"><a href="#cb114-1220" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Log-transformed and dropped raw versions of highly skewed ratio features."</span>)</span>
<span id="cb114-1221"><a href="#cb114-1221" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1222"><a href="#cb114-1222" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1223"><a href="#cb114-1223" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1226"><a href="#cb114-1226" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1227"><a href="#cb114-1227" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">"TARGET"</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-1228"><a href="#cb114-1228" aria-hidden="true" tabindex="-1"></a>    train_merged.drop(<span class="st">"TARGET"</span>, axis<span class="op">=</span><span class="dv">1</span>,inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-1229"><a href="#cb114-1229" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb114-1230"><a href="#cb114-1230" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"TARGET not found in columns:"</span>, train_merged.columns.tolist())</span>
<span id="cb114-1231"><a href="#cb114-1231" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1232"><a href="#cb114-1232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1235"><a href="#cb114-1235" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1236"><a href="#cb114-1236" aria-hidden="true" tabindex="-1"></a><span class="co"># Define columns to drop</span></span>
<span id="cb114-1237"><a href="#cb114-1237" aria-hidden="true" tabindex="-1"></a>year_built_cols <span class="op">=</span> [<span class="ss">f'year_built_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)]</span>
<span id="cb114-1238"><a href="#cb114-1238" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1239"><a href="#cb114-1239" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop if columns exist</span></span>
<span id="cb114-1240"><a href="#cb114-1240" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>[col <span class="cf">for</span> col <span class="kw">in</span> year_built_cols <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-1241"><a href="#cb114-1241" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>[col <span class="cf">for</span> col <span class="kw">in</span> year_built_cols <span class="cf">if</span> col <span class="kw">in</span> test_merged.columns], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-1242"><a href="#cb114-1242" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1243"><a href="#cb114-1243" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Dropped year_built_2015 to year_built_2018 from both train and test sets."</span>)</span>
<span id="cb114-1244"><a href="#cb114-1244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1245"><a href="#cb114-1245" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1246"><a href="#cb114-1246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1249"><a href="#cb114-1249" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1250"><a href="#cb114-1250" aria-hidden="true" tabindex="-1"></a>train_cols <span class="op">=</span> <span class="bu">set</span>(train_merged.columns)</span>
<span id="cb114-1251"><a href="#cb114-1251" aria-hidden="true" tabindex="-1"></a>test_cols <span class="op">=</span> <span class="bu">set</span>(test_merged.columns)</span>
<span id="cb114-1252"><a href="#cb114-1252" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1253"><a href="#cb114-1253" aria-hidden="true" tabindex="-1"></a>missing_in_test <span class="op">=</span> train_cols <span class="op">-</span> test_cols</span>
<span id="cb114-1254"><a href="#cb114-1254" aria-hidden="true" tabindex="-1"></a>missing_in_train <span class="op">=</span> test_cols <span class="op">-</span> train_cols</span>
<span id="cb114-1255"><a href="#cb114-1255" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1256"><a href="#cb114-1256" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Columns in train but not in test:"</span>)</span>
<span id="cb114-1257"><a href="#cb114-1257" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">sorted</span>(missing_in_test))</span>
<span id="cb114-1258"><a href="#cb114-1258" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1259"><a href="#cb114-1259" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> Columns in test but not in train:"</span>)</span>
<span id="cb114-1260"><a href="#cb114-1260" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">sorted</span>(missing_in_train))</span>
<span id="cb114-1261"><a href="#cb114-1261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1262"><a href="#cb114-1262" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1263"><a href="#cb114-1263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1266"><a href="#cb114-1266" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1267"><a href="#cb114-1267" aria-hidden="true" tabindex="-1"></a><span class="co"># Check if column sets match</span></span>
<span id="cb114-1268"><a href="#cb114-1268" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">set</span>(train_merged.columns) <span class="op">==</span> <span class="bu">set</span>(test_merged.columns))  <span class="co"># Should be True</span></span>
<span id="cb114-1269"><a href="#cb114-1269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1270"><a href="#cb114-1270" aria-hidden="true" tabindex="-1"></a><span class="co"># Check if column order matches</span></span>
<span id="cb114-1271"><a href="#cb114-1271" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">list</span>(train_merged.columns) <span class="op">==</span> <span class="bu">list</span>(test_merged.columns))  <span class="co"># Must also be True</span></span>
<span id="cb114-1272"><a href="#cb114-1272" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1273"><a href="#cb114-1273" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1274"><a href="#cb114-1274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1277"><a href="#cb114-1277" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1278"><a href="#cb114-1278" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb114-1279"><a href="#cb114-1279" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb114-1280"><a href="#cb114-1280" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> RidgeCV</span>
<span id="cb114-1281"><a href="#cb114-1281" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.pipeline <span class="im">import</span> make_pipeline</span>
<span id="cb114-1282"><a href="#cb114-1282" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> KFold</span>
<span id="cb114-1283"><a href="#cb114-1283" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> root_mean_squared_error</span>
<span id="cb114-1284"><a href="#cb114-1284" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb114-1285"><a href="#cb114-1285" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> KFold</span>
<span id="cb114-1286"><a href="#cb114-1286" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1287"><a href="#cb114-1287" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 2: Prepare training/test matrices ===</span></span>
<span id="cb114-1288"><a href="#cb114-1288" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> train_merged.copy()</span>
<span id="cb114-1289"><a href="#cb114-1289" aria-hidden="true" tabindex="-1"></a>X_test <span class="op">=</span> test_merged.copy()</span>
<span id="cb114-1290"><a href="#cb114-1290" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> pd.Series(y_train).values <span class="co"># use raw target (not log)</span></span>
<span id="cb114-1291"><a href="#cb114-1291" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1292"><a href="#cb114-1292" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 3: RidgeCV pipeline ===</span></span>
<span id="cb114-1293"><a href="#cb114-1293" aria-hidden="true" tabindex="-1"></a>kf <span class="op">=</span> KFold(n_splits<span class="op">=</span><span class="dv">3</span>, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb114-1294"><a href="#cb114-1294" aria-hidden="true" tabindex="-1"></a>alphas <span class="op">=</span> np.logspace(<span class="op">-</span><span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">10</span>)</span>
<span id="cb114-1295"><a href="#cb114-1295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1296"><a href="#cb114-1296" aria-hidden="true" tabindex="-1"></a>ridge_oof <span class="op">=</span> np.zeros(<span class="bu">len</span>(X))</span>
<span id="cb114-1297"><a href="#cb114-1297" aria-hidden="true" tabindex="-1"></a>ridge_test_preds <span class="op">=</span> np.zeros(<span class="bu">len</span>(X_test))</span>
<span id="cb114-1298"><a href="#cb114-1298" aria-hidden="true" tabindex="-1"></a>best_alphas <span class="op">=</span> []</span>
<span id="cb114-1299"><a href="#cb114-1299" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1300"><a href="#cb114-1300" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> fold, (train_idx, val_idx) <span class="kw">in</span> <span class="bu">enumerate</span>(kf.split(X)):</span>
<span id="cb114-1301"><a href="#cb114-1301" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss"> Fold </span><span class="sc">{</span>fold<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">/5"</span>)</span>
<span id="cb114-1302"><a href="#cb114-1302" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1303"><a href="#cb114-1303" aria-hidden="true" tabindex="-1"></a>    X_train, y_train_fold <span class="op">=</span> X.iloc[train_idx], y[train_idx]</span>
<span id="cb114-1304"><a href="#cb114-1304" aria-hidden="true" tabindex="-1"></a>    X_val, y_val <span class="op">=</span> X.iloc[val_idx], y[val_idx]</span>
<span id="cb114-1305"><a href="#cb114-1305" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1306"><a href="#cb114-1306" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> make_pipeline(</span>
<span id="cb114-1307"><a href="#cb114-1307" aria-hidden="true" tabindex="-1"></a>        StandardScaler(),</span>
<span id="cb114-1308"><a href="#cb114-1308" aria-hidden="true" tabindex="-1"></a>        RidgeCV(alphas<span class="op">=</span>alphas, cv<span class="op">=</span><span class="dv">3</span>, scoring<span class="op">=</span><span class="st">'neg_root_mean_squared_error'</span>)</span>
<span id="cb114-1309"><a href="#cb114-1309" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb114-1310"><a href="#cb114-1310" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1311"><a href="#cb114-1311" aria-hidden="true" tabindex="-1"></a>    model.fit(X_train, y_train_fold)</span>
<span id="cb114-1312"><a href="#cb114-1312" aria-hidden="true" tabindex="-1"></a>    ridge_oof[val_idx] <span class="op">=</span> model.predict(X_val)</span>
<span id="cb114-1313"><a href="#cb114-1313" aria-hidden="true" tabindex="-1"></a>    ridge_test_preds <span class="op">+=</span> model.predict(X_test) <span class="op">/</span> kf.get_n_splits()</span>
<span id="cb114-1314"><a href="#cb114-1314" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1315"><a href="#cb114-1315" aria-hidden="true" tabindex="-1"></a>    best_alpha <span class="op">=</span> model.named_steps[<span class="st">'ridgecv'</span>].alpha_</span>
<span id="cb114-1316"><a href="#cb114-1316" aria-hidden="true" tabindex="-1"></a>    best_alphas.append(best_alpha)</span>
<span id="cb114-1317"><a href="#cb114-1317" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb114-1318"><a href="#cb114-1318" aria-hidden="true" tabindex="-1"></a>    fold_rmse <span class="op">=</span> root_mean_squared_error(y_val, ridge_oof[val_idx])</span>
<span id="cb114-1319"><a href="#cb114-1319" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Fold </span><span class="sc">{</span>fold<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss"> RMSE: </span><span class="sc">{</span>fold_rmse<span class="sc">:,.2f}</span><span class="ss"> | Best alpha: </span><span class="sc">{</span>best_alpha<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb114-1320"><a href="#cb114-1320" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1321"><a href="#cb114-1321" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 4: Final RMSE ===</span></span>
<span id="cb114-1322"><a href="#cb114-1322" aria-hidden="true" tabindex="-1"></a>final_rmse <span class="op">=</span> root_mean_squared_error(y, ridge_oof)</span>
<span id="cb114-1323"><a href="#cb114-1323" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss"> Final OOF RMSE (RidgeCV): </span><span class="sc">{</span>final_rmse<span class="sc">:,.2f}</span><span class="ss">"</span>)</span>
<span id="cb114-1324"><a href="#cb114-1324" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" Average best alpha across folds: </span><span class="sc">{</span>np<span class="sc">.</span>mean(best_alphas)<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb114-1325"><a href="#cb114-1325" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1326"><a href="#cb114-1326" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 5: Save predictions ===</span></span>
<span id="cb114-1327"><a href="#cb114-1327" aria-hidden="true" tabindex="-1"></a>submission <span class="op">=</span> pd.DataFrame({</span>
<span id="cb114-1328"><a href="#cb114-1328" aria-hidden="true" tabindex="-1"></a>    <span class="st">"ACCOUNT"</span>: acct_test.values.ravel(),</span>
<span id="cb114-1329"><a href="#cb114-1329" aria-hidden="true" tabindex="-1"></a>    <span class="st">"TARGET"</span>: ridge_test_preds</span>
<span id="cb114-1330"><a href="#cb114-1330" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb114-1331"><a href="#cb114-1331" aria-hidden="true" tabindex="-1"></a>submission.to_csv(<span class="st">"submission_ridgecv_pipeline.csv"</span>, index<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb114-1332"><a href="#cb114-1332" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> Saved: submission_ridgecv_pipeline.csv"</span>)</span>
<span id="cb114-1333"><a href="#cb114-1333" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1334"><a href="#cb114-1334" aria-hidden="true" tabindex="-1"></a><span class="co"># === Optional: Save OOF &amp; test preds for stacking or analysis ===</span></span>
<span id="cb114-1335"><a href="#cb114-1335" aria-hidden="true" tabindex="-1"></a>np.save(<span class="st">"ridgecv_oof_preds.npy"</span>, ridge_oof)</span>
<span id="cb114-1336"><a href="#cb114-1336" aria-hidden="true" tabindex="-1"></a>np.save(<span class="st">"ridgecv_test_preds.npy"</span>, ridge_test_preds)</span>
<span id="cb114-1337"><a href="#cb114-1337" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Saved: ridgecv_oof_preds.npy and ridgecv_test_preds.npy"</span>)</span>
<span id="cb114-1338"><a href="#cb114-1338" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1339"><a href="#cb114-1339" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1340"><a href="#cb114-1340" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1341"><a href="#cb114-1341" aria-hidden="true" tabindex="-1"></a><span class="fu"># XGBoost &amp; LightGBM Pipeline</span></span>
<span id="cb114-1342"><a href="#cb114-1342" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1345"><a href="#cb114-1345" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1346"><a href="#cb114-1346" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb114-1347"><a href="#cb114-1347" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb114-1348"><a href="#cb114-1348" aria-hidden="true" tabindex="-1"></a><span class="co"># ===== Load Data =====</span></span>
<span id="cb114-1349"><a href="#cb114-1349" aria-hidden="true" tabindex="-1"></a>folder_path <span class="op">=</span> <span class="st">'/Users/Srijith97/Downloads/STA 9890 Housing Data/'</span></span>
<span id="cb114-1350"><a href="#cb114-1350" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1351"><a href="#cb114-1351" aria-hidden="true" tabindex="-1"></a>building_years <span class="op">=</span> []</span>
<span id="cb114-1352"><a href="#cb114-1352" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>):</span>
<span id="cb114-1353"><a href="#cb114-1353" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.read_csv(folder_path <span class="op">+</span> <span class="ss">f'building_details_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">.csv'</span>)</span>
<span id="cb114-1354"><a href="#cb114-1354" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'year'</span>] <span class="op">=</span> year</span>
<span id="cb114-1355"><a href="#cb114-1355" aria-hidden="true" tabindex="-1"></a>    building_years.append(df)</span>
<span id="cb114-1356"><a href="#cb114-1356" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1357"><a href="#cb114-1357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1358"><a href="#cb114-1358" aria-hidden="true" tabindex="-1"></a>building_all <span class="op">=</span> pd.concat(building_years, ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-1359"><a href="#cb114-1359" aria-hidden="true" tabindex="-1"></a>building_all <span class="op">=</span> building_all.drop_duplicates(subset<span class="op">=</span>[<span class="st">'acct'</span>, <span class="st">'year'</span>], keep<span class="op">=</span><span class="st">'first'</span>)</span>
<span id="cb114-1360"><a href="#cb114-1360" aria-hidden="true" tabindex="-1"></a>pivoted <span class="op">=</span> building_all.pivot(index<span class="op">=</span><span class="st">'acct'</span>, columns<span class="op">=</span><span class="st">'year'</span>)</span>
<span id="cb114-1361"><a href="#cb114-1361" aria-hidden="true" tabindex="-1"></a>pivoted.columns <span class="op">=</span> [<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> col, year <span class="kw">in</span> pivoted.columns]</span>
<span id="cb114-1362"><a href="#cb114-1362" aria-hidden="true" tabindex="-1"></a>pivoted <span class="op">=</span> pivoted.reset_index()</span>
<span id="cb114-1363"><a href="#cb114-1363" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1364"><a href="#cb114-1364" aria-hidden="true" tabindex="-1"></a>train <span class="op">=</span> pd.read_csv(folder_path <span class="op">+</span> <span class="st">'assessment_history_train.csv'</span>)</span>
<span id="cb114-1365"><a href="#cb114-1365" aria-hidden="true" tabindex="-1"></a>test <span class="op">=</span> pd.read_csv(folder_path <span class="op">+</span> <span class="st">'assessment_history_test.csv'</span>)</span>
<span id="cb114-1366"><a href="#cb114-1366" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1367"><a href="#cb114-1367" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> train.merge(pivoted, on<span class="op">=</span><span class="st">'acct'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb114-1368"><a href="#cb114-1368" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> test.merge(pivoted, on<span class="op">=</span><span class="st">'acct'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb114-1369"><a href="#cb114-1369" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1370"><a href="#cb114-1370" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1373"><a href="#cb114-1373" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1374"><a href="#cb114-1374" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1: Identify all '2019' columns in train</span></span>
<span id="cb114-1375"><a href="#cb114-1375" aria-hidden="true" tabindex="-1"></a>train_2019_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> <span class="st">'2019'</span> <span class="kw">in</span> col]</span>
<span id="cb114-1376"><a href="#cb114-1376" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1377"><a href="#cb114-1377" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 2: Find which 2019 columns are missing in test</span></span>
<span id="cb114-1378"><a href="#cb114-1378" aria-hidden="true" tabindex="-1"></a>train_only_2019_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_2019_cols <span class="cf">if</span> col <span class="kw">not</span> <span class="kw">in</span> test_merged.columns]</span>
<span id="cb114-1379"><a href="#cb114-1379" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1380"><a href="#cb114-1380" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 3: Always drop 'protested_2019' due to leakage risk</span></span>
<span id="cb114-1381"><a href="#cb114-1381" aria-hidden="true" tabindex="-1"></a>train_only_2019_cols.append(<span class="st">'protested_2019'</span>)</span>
<span id="cb114-1382"><a href="#cb114-1382" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1383"><a href="#cb114-1383" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 4: Drop the identified columns from train</span></span>
<span id="cb114-1384"><a href="#cb114-1384" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> train_merged.drop(columns<span class="op">=</span>train_only_2019_cols, errors<span class="op">=</span><span class="st">'ignore'</span>)</span>
<span id="cb114-1385"><a href="#cb114-1385" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1386"><a href="#cb114-1386" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 5: Optional logging</span></span>
<span id="cb114-1387"><a href="#cb114-1387" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" Dropped </span><span class="sc">{</span><span class="bu">len</span>(train_only_2019_cols)<span class="sc">}</span><span class="ss"> columns from train (including protested_2019 if present):"</span>)</span>
<span id="cb114-1388"><a href="#cb114-1388" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(train_only_2019_cols)</span>
<span id="cb114-1389"><a href="#cb114-1389" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1390"><a href="#cb114-1390" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1391"><a href="#cb114-1391" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1394"><a href="#cb114-1394" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1395"><a href="#cb114-1395" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb114-1396"><a href="#cb114-1396" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'protested_2019'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb114-1397"><a href="#cb114-1397" aria-hidden="true" tabindex="-1"></a>        df.drop(columns<span class="op">=</span><span class="st">'protested_2019'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-1398"><a href="#cb114-1398" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Dropped 'protested_2019' from </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1399"><a href="#cb114-1399" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb114-1400"><a href="#cb114-1400" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" 'protested_2019' not found in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1401"><a href="#cb114-1401" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1402"><a href="#cb114-1402" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1403"><a href="#cb114-1403" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1406"><a href="#cb114-1406" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1407"><a href="#cb114-1407" aria-hidden="true" tabindex="-1"></a><span class="co">## Get all '2019' columns in train and test</span></span>
<span id="cb114-1408"><a href="#cb114-1408" aria-hidden="true" tabindex="-1"></a>train_2019_cols <span class="op">=</span> <span class="bu">sorted</span>([col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> <span class="st">'2019'</span> <span class="kw">in</span> col])</span>
<span id="cb114-1409"><a href="#cb114-1409" aria-hidden="true" tabindex="-1"></a>test_2019_cols <span class="op">=</span> <span class="bu">sorted</span>([col <span class="cf">for</span> col <span class="kw">in</span> test_merged.columns <span class="cf">if</span> <span class="st">'2019'</span> <span class="kw">in</span> col])</span>
<span id="cb114-1410"><a href="#cb114-1410" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1411"><a href="#cb114-1411" aria-hidden="true" tabindex="-1"></a><span class="co"># Print train columns</span></span>
<span id="cb114-1412"><a href="#cb114-1412" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" 2019 Columns in train_merged:"</span>)</span>
<span id="cb114-1413"><a href="#cb114-1413" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> train_2019_cols:</span>
<span id="cb114-1414"><a href="#cb114-1414" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" - </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1415"><a href="#cb114-1415" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1416"><a href="#cb114-1416" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> 2019 Columns in test_merged:"</span>)</span>
<span id="cb114-1417"><a href="#cb114-1417" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> test_2019_cols:</span>
<span id="cb114-1418"><a href="#cb114-1418" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" - </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1419"><a href="#cb114-1419" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1420"><a href="#cb114-1420" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1421"><a href="#cb114-1421" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1422"><a href="#cb114-1422" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1425"><a href="#cb114-1425" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1426"><a href="#cb114-1426" aria-hidden="true" tabindex="-1"></a><span class="co"># Compare sets</span></span>
<span id="cb114-1427"><a href="#cb114-1427" aria-hidden="true" tabindex="-1"></a>train_only_2019 <span class="op">=</span> <span class="bu">sorted</span>(<span class="bu">list</span>(<span class="bu">set</span>(train_2019_cols) <span class="op">-</span> <span class="bu">set</span>(test_2019_cols)))</span>
<span id="cb114-1428"><a href="#cb114-1428" aria-hidden="true" tabindex="-1"></a>test_only_2019 <span class="op">=</span> <span class="bu">sorted</span>(<span class="bu">list</span>(<span class="bu">set</span>(test_2019_cols) <span class="op">-</span> <span class="bu">set</span>(train_2019_cols)))</span>
<span id="cb114-1429"><a href="#cb114-1429" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1430"><a href="#cb114-1430" aria-hidden="true" tabindex="-1"></a><span class="co"># Print comparison result</span></span>
<span id="cb114-1431"><a href="#cb114-1431" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> train_only_2019 <span class="kw">and</span> <span class="kw">not</span> test_only_2019:</span>
<span id="cb114-1432"><a href="#cb114-1432" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> All 2019 columns match between train_merged and test_merged."</span>)</span>
<span id="cb114-1433"><a href="#cb114-1433" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb114-1434"><a href="#cb114-1434" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> Mismatched 2019 columns found:"</span>)</span>
<span id="cb114-1435"><a href="#cb114-1435" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1436"><a href="#cb114-1436" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> train_only_2019:</span>
<span id="cb114-1437"><a href="#cb114-1437" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">" In train_merged but not in test_merged:"</span>)</span>
<span id="cb114-1438"><a href="#cb114-1438" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> col <span class="kw">in</span> train_only_2019:</span>
<span id="cb114-1439"><a href="#cb114-1439" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"   - </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1440"><a href="#cb114-1440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1441"><a href="#cb114-1441" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> test_only_2019:</span>
<span id="cb114-1442"><a href="#cb114-1442" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">" In test_merged but not in train_merged:"</span>)</span>
<span id="cb114-1443"><a href="#cb114-1443" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> col <span class="kw">in</span> test_only_2019:</span>
<span id="cb114-1444"><a href="#cb114-1444" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"   - </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1445"><a href="#cb114-1445" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1446"><a href="#cb114-1446" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1449"><a href="#cb114-1449" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1450"><a href="#cb114-1450" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1: Store target separately</span></span>
<span id="cb114-1451"><a href="#cb114-1451" aria-hidden="true" tabindex="-1"></a>y_train <span class="op">=</span> train_merged[<span class="st">"TARGET"</span>].values</span>
<span id="cb114-1452"><a href="#cb114-1452" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1453"><a href="#cb114-1453" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 4: Confirm sizes</span></span>
<span id="cb114-1454"><a href="#cb114-1454" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Train shape: </span><span class="sc">{</span>train<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1455"><a href="#cb114-1455" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Test shape: </span><span class="sc">{</span>test<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1456"><a href="#cb114-1456" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1457"><a href="#cb114-1457" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1458"><a href="#cb114-1458" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1461"><a href="#cb114-1461" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1462"><a href="#cb114-1462" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate % of missing values in each column of TRAIN only</span></span>
<span id="cb114-1463"><a href="#cb114-1463" aria-hidden="true" tabindex="-1"></a>train_na <span class="op">=</span> (train_merged.isnull().<span class="bu">sum</span>() <span class="op">/</span> train_merged.shape[<span class="dv">0</span>]) <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb114-1464"><a href="#cb114-1464" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1465"><a href="#cb114-1465" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop columns with no missing values, sort the rest</span></span>
<span id="cb114-1466"><a href="#cb114-1466" aria-hidden="true" tabindex="-1"></a>train_na <span class="op">=</span> train_na[train_na <span class="op">&gt;</span> <span class="dv">0</span>].sort_values(ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb114-1467"><a href="#cb114-1467" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1468"><a href="#cb114-1468" aria-hidden="true" tabindex="-1"></a><span class="co"># Optional: Show top 200 missing features</span></span>
<span id="cb114-1469"><a href="#cb114-1469" aria-hidden="true" tabindex="-1"></a>missing_data <span class="op">=</span> pd.DataFrame({<span class="st">'Missing Ratio (%)'</span>: train_na})</span>
<span id="cb114-1470"><a href="#cb114-1470" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1471"><a href="#cb114-1471" aria-hidden="true" tabindex="-1"></a><span class="co"># Display</span></span>
<span id="cb114-1472"><a href="#cb114-1472" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Top columns with missing data (based on training set only):"</span>)</span>
<span id="cb114-1473"><a href="#cb114-1473" aria-hidden="true" tabindex="-1"></a>missing_data.head(<span class="dv">20</span>)</span>
<span id="cb114-1474"><a href="#cb114-1474" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1475"><a href="#cb114-1475" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1476"><a href="#cb114-1476" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1477"><a href="#cb114-1477" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1480"><a href="#cb114-1480" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1481"><a href="#cb114-1481" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_floor_area_totals(df, years):</span>
<span id="cb114-1482"><a href="#cb114-1482" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> y <span class="kw">in</span> years:</span>
<span id="cb114-1483"><a href="#cb114-1483" aria-hidden="true" tabindex="-1"></a>        primary_col <span class="op">=</span> <span class="ss">f'floor_area_primary_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">'</span></span>
<span id="cb114-1484"><a href="#cb114-1484" aria-hidden="true" tabindex="-1"></a>        upper_col   <span class="op">=</span> <span class="ss">f'floor_area_upper_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">'</span></span>
<span id="cb114-1485"><a href="#cb114-1485" aria-hidden="true" tabindex="-1"></a>        lower_col   <span class="op">=</span> <span class="ss">f'floor_area_lower_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">'</span></span>
<span id="cb114-1486"><a href="#cb114-1486" aria-hidden="true" tabindex="-1"></a>        total_col   <span class="op">=</span> <span class="ss">f'floor_area_total_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">'</span></span>
<span id="cb114-1487"><a href="#cb114-1487" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1488"><a href="#cb114-1488" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">all</span>(col <span class="kw">in</span> df.columns <span class="cf">for</span> col <span class="kw">in</span> [primary_col, upper_col, lower_col]):</span>
<span id="cb114-1489"><a href="#cb114-1489" aria-hidden="true" tabindex="-1"></a>            df[total_col] <span class="op">=</span> (</span>
<span id="cb114-1490"><a href="#cb114-1490" aria-hidden="true" tabindex="-1"></a>                df[primary_col].fillna(<span class="dv">0</span>) <span class="op">+</span></span>
<span id="cb114-1491"><a href="#cb114-1491" aria-hidden="true" tabindex="-1"></a>                df[upper_col].fillna(<span class="dv">0</span>) <span class="op">+</span></span>
<span id="cb114-1492"><a href="#cb114-1492" aria-hidden="true" tabindex="-1"></a>                df[lower_col].fillna(<span class="dv">0</span>)</span>
<span id="cb114-1493"><a href="#cb114-1493" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb114-1494"><a href="#cb114-1494" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Created: </span><span class="sc">{</span>total_col<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1495"><a href="#cb114-1495" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb114-1496"><a href="#cb114-1496" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipping </span><span class="sc">{</span>total_col<span class="sc">}</span><span class="ss"> ‚Äî one or more components missing."</span>)</span>
<span id="cb114-1497"><a href="#cb114-1497" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb114-1498"><a href="#cb114-1498" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1499"><a href="#cb114-1499" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply for years 2015‚Äì2019</span></span>
<span id="cb114-1500"><a href="#cb114-1500" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2015'</span>, <span class="st">'2016'</span>, <span class="st">'2017'</span>, <span class="st">'2018'</span>, <span class="st">'2019'</span>]</span>
<span id="cb114-1501"><a href="#cb114-1501" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> create_floor_area_totals(train_merged, years)</span>
<span id="cb114-1502"><a href="#cb114-1502" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> create_floor_area_totals(test_merged, years)</span>
<span id="cb114-1503"><a href="#cb114-1503" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1504"><a href="#cb114-1504" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1505"><a href="#cb114-1505" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1506"><a href="#cb114-1506" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1507"><a href="#cb114-1507" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1508"><a href="#cb114-1508" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1509"><a href="#cb114-1509" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1512"><a href="#cb114-1512" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1513"><a href="#cb114-1513" aria-hidden="true" tabindex="-1"></a>zero_pct <span class="op">=</span> (train_merged[<span class="st">'mobile_home_area_2015'</span>] <span class="op">==</span> <span class="dv">0</span>).mean() <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb114-1514"><a href="#cb114-1514" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" mobile_home_area_2015 is 0 in </span><span class="sc">{</span>zero_pct<span class="sc">:.2f}</span><span class="ss">% of training rows"</span>)</span>
<span id="cb114-1515"><a href="#cb114-1515" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1516"><a href="#cb114-1516" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1517"><a href="#cb114-1517" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1520"><a href="#cb114-1520" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1521"><a href="#cb114-1521" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> col.startswith(<span class="st">"mobile_home_area"</span>)]</span>
<span id="cb114-1522"><a href="#cb114-1522" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1523"><a href="#cb114-1523" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop from both sets</span></span>
<span id="cb114-1524"><a href="#cb114-1524" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>, errors<span class="op">=</span><span class="st">'ignore'</span>)</span>
<span id="cb114-1525"><a href="#cb114-1525" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>, errors<span class="op">=</span><span class="st">'ignore'</span>)</span>
<span id="cb114-1526"><a href="#cb114-1526" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1527"><a href="#cb114-1527" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" Dropped columns from train/test: </span><span class="sc">{</span>cols_to_drop<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1528"><a href="#cb114-1528" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1529"><a href="#cb114-1529" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1530"><a href="#cb114-1530" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1531"><a href="#cb114-1531" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1534"><a href="#cb114-1534" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1535"><a href="#cb114-1535" aria-hidden="true" tabindex="-1"></a>zero_pct <span class="op">=</span> (train_merged[<span class="st">'deck_area_2015'</span>] <span class="op">==</span> <span class="dv">0</span>).mean() <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb114-1536"><a href="#cb114-1536" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" deck_area_2015 is 0 in </span><span class="sc">{</span>zero_pct<span class="sc">:.2f}</span><span class="ss">% of training rows"</span>)</span>
<span id="cb114-1537"><a href="#cb114-1537" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1538"><a href="#cb114-1538" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1539"><a href="#cb114-1539" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1540"><a href="#cb114-1540" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1543"><a href="#cb114-1543" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1544"><a href="#cb114-1544" aria-hidden="true" tabindex="-1"></a><span class="co"># Use training columns to identify which deck_area columns exist</span></span>
<span id="cb114-1545"><a href="#cb114-1545" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> col.startswith(<span class="st">"deck_area"</span>)]</span>
<span id="cb114-1546"><a href="#cb114-1546" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1547"><a href="#cb114-1547" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop those columns from both datasets</span></span>
<span id="cb114-1548"><a href="#cb114-1548" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-1549"><a href="#cb114-1549" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-1550"><a href="#cb114-1550" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1551"><a href="#cb114-1551" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" Dropped columns from train/test: </span><span class="sc">{</span>cols_to_drop<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1552"><a href="#cb114-1552" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1553"><a href="#cb114-1553" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1554"><a href="#cb114-1554" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1555"><a href="#cb114-1555" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1558"><a href="#cb114-1558" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1559"><a href="#cb114-1559" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_yearly_features(df, base_features, years):</span>
<span id="cb114-1560"><a href="#cb114-1560" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> feature <span class="kw">in</span> base_features:</span>
<span id="cb114-1561"><a href="#cb114-1561" aria-hidden="true" tabindex="-1"></a>        cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb114-1562"><a href="#cb114-1562" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb114-1563"><a href="#cb114-1563" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Backfill all relevant year columns in-place</span></span>
<span id="cb114-1564"><a href="#cb114-1564" aria-hidden="true" tabindex="-1"></a>            df[cols] <span class="op">=</span> df[cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-1565"><a href="#cb114-1565" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Backfilled: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> across </span><span class="sc">{</span>cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1566"><a href="#cb114-1566" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb114-1567"><a href="#cb114-1567" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipping </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> ‚Äî not enough year columns found."</span>)</span>
<span id="cb114-1568"><a href="#cb114-1568" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb114-1569"><a href="#cb114-1569" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1570"><a href="#cb114-1570" aria-hidden="true" tabindex="-1"></a><span class="co"># Years in reverse so that bfill works from most recent (2019) to oldest (2015)</span></span>
<span id="cb114-1571"><a href="#cb114-1571" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb114-1572"><a href="#cb114-1572" aria-hidden="true" tabindex="-1"></a>features <span class="op">=</span> [<span class="st">'garage_area'</span>, <span class="st">'porch_area'</span>]</span>
<span id="cb114-1573"><a href="#cb114-1573" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1574"><a href="#cb114-1574" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to both train and test</span></span>
<span id="cb114-1575"><a href="#cb114-1575" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_yearly_features(train_merged, features, years)</span>
<span id="cb114-1576"><a href="#cb114-1576" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_yearly_features(test_merged, features, years)</span>
<span id="cb114-1577"><a href="#cb114-1577" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1578"><a href="#cb114-1578" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1579"><a href="#cb114-1579" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1580"><a href="#cb114-1580" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1583"><a href="#cb114-1583" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1584"><a href="#cb114-1584" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_yearly_features(df, features, years):</span>
<span id="cb114-1585"><a href="#cb114-1585" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> feature <span class="kw">in</span> features:</span>
<span id="cb114-1586"><a href="#cb114-1586" aria-hidden="true" tabindex="-1"></a>        year_cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb114-1587"><a href="#cb114-1587" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(year_cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb114-1588"><a href="#cb114-1588" aria-hidden="true" tabindex="-1"></a>            df[year_cols] <span class="op">=</span> df[year_cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-1589"><a href="#cb114-1589" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Backfilled: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> across </span><span class="sc">{</span>year_cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1590"><a href="#cb114-1590" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb114-1591"><a href="#cb114-1591" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipped: Not enough year columns for '</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">'"</span>)</span>
<span id="cb114-1592"><a href="#cb114-1592" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb114-1593"><a href="#cb114-1593" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1594"><a href="#cb114-1594" aria-hidden="true" tabindex="-1"></a><span class="co"># Use years in reverse for proper backfill (newest to oldest)</span></span>
<span id="cb114-1595"><a href="#cb114-1595" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb114-1596"><a href="#cb114-1596" aria-hidden="true" tabindex="-1"></a>features <span class="op">=</span> [<span class="st">'floors'</span>, <span class="st">'half_bath'</span>, <span class="st">'full_bath'</span>, <span class="st">'total_rooms'</span>, <span class="st">'bedrooms'</span>]</span>
<span id="cb114-1597"><a href="#cb114-1597" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1598"><a href="#cb114-1598" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to both train and test</span></span>
<span id="cb114-1599"><a href="#cb114-1599" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_yearly_features(train_merged, features, years)</span>
<span id="cb114-1600"><a href="#cb114-1600" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_yearly_features(test_merged, features, years)</span>
<span id="cb114-1601"><a href="#cb114-1601" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1602"><a href="#cb114-1602" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1603"><a href="#cb114-1603" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1604"><a href="#cb114-1604" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1605"><a href="#cb114-1605" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1608"><a href="#cb114-1608" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1609"><a href="#cb114-1609" aria-hidden="true" tabindex="-1"></a><span class="co"># Identify elevator-related columns from training set</span></span>
<span id="cb114-1610"><a href="#cb114-1610" aria-hidden="true" tabindex="-1"></a>elevator_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> col.startswith(<span class="st">"elevator"</span>)]</span>
<span id="cb114-1611"><a href="#cb114-1611" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1612"><a href="#cb114-1612" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop from both train and test</span></span>
<span id="cb114-1613"><a href="#cb114-1613" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>elevator_cols, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-1614"><a href="#cb114-1614" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>elevator_cols, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-1615"><a href="#cb114-1615" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1616"><a href="#cb114-1616" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" Dropped elevator-related columns from train/test: </span><span class="sc">{</span>elevator_cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1617"><a href="#cb114-1617" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1618"><a href="#cb114-1618" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1619"><a href="#cb114-1619" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1622"><a href="#cb114-1622" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1623"><a href="#cb114-1623" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_year_features(df, features, years):</span>
<span id="cb114-1624"><a href="#cb114-1624" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> feature <span class="kw">in</span> features:</span>
<span id="cb114-1625"><a href="#cb114-1625" aria-hidden="true" tabindex="-1"></a>        cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb114-1626"><a href="#cb114-1626" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb114-1627"><a href="#cb114-1627" aria-hidden="true" tabindex="-1"></a>            df[cols] <span class="op">=</span> df[cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-1628"><a href="#cb114-1628" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Backfilled: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> across </span><span class="sc">{</span>cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1629"><a href="#cb114-1629" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb114-1630"><a href="#cb114-1630" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipped </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> ‚Äî not enough year-based columns found."</span>)</span>
<span id="cb114-1631"><a href="#cb114-1631" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb114-1632"><a href="#cb114-1632" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1633"><a href="#cb114-1633" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_year_built_final(df):</span>
<span id="cb114-1634"><a href="#cb114-1634" aria-hidden="true" tabindex="-1"></a>    year_cols <span class="op">=</span> [<span class="ss">f"year_built_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>] <span class="cf">if</span> <span class="ss">f"year_built_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb114-1635"><a href="#cb114-1635" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> year_cols:</span>
<span id="cb114-1636"><a href="#cb114-1636" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'year_built_final'</span>] <span class="op">=</span> df[year_cols].bfill(axis<span class="op">=</span><span class="dv">1</span>).iloc[:, <span class="dv">0</span>]</span>
<span id="cb114-1637"><a href="#cb114-1637" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Created year_built_final from: </span><span class="sc">{</span>year_cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1638"><a href="#cb114-1638" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb114-1639"><a href="#cb114-1639" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">" Skipped: no year_built_* columns found."</span>)</span>
<span id="cb114-1640"><a href="#cb114-1640" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb114-1641"><a href="#cb114-1641" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1642"><a href="#cb114-1642" aria-hidden="true" tabindex="-1"></a><span class="co"># Define reverse years for backfill (latest ‚Üí oldest)</span></span>
<span id="cb114-1643"><a href="#cb114-1643" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb114-1644"><a href="#cb114-1644" aria-hidden="true" tabindex="-1"></a>features_to_backfill <span class="op">=</span> [<span class="st">'fireplaces'</span>, <span class="st">'quality'</span>, <span class="st">'quality_description'</span>]</span>
<span id="cb114-1645"><a href="#cb114-1645" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1646"><a href="#cb114-1646" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to both train and test</span></span>
<span id="cb114-1647"><a href="#cb114-1647" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_year_features(train_merged, features_to_backfill, years)</span>
<span id="cb114-1648"><a href="#cb114-1648" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> create_year_built_final(train_merged)</span>
<span id="cb114-1649"><a href="#cb114-1649" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1650"><a href="#cb114-1650" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_year_features(test_merged, features_to_backfill, years)</span>
<span id="cb114-1651"><a href="#cb114-1651" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> create_year_built_final(test_merged)</span>
<span id="cb114-1652"><a href="#cb114-1652" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1653"><a href="#cb114-1653" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1654"><a href="#cb114-1654" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1655"><a href="#cb114-1655" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1658"><a href="#cb114-1658" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1659"><a href="#cb114-1659" aria-hidden="true" tabindex="-1"></a><span class="co">## Identify columns to drop from training data</span></span>
<span id="cb114-1660"><a href="#cb114-1660" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> col.startswith(<span class="st">"year_remodeled"</span>)]</span>
<span id="cb114-1661"><a href="#cb114-1661" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1662"><a href="#cb114-1662" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop from both train and test</span></span>
<span id="cb114-1663"><a href="#cb114-1663" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-1664"><a href="#cb114-1664" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>cols_to_drop, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-1665"><a href="#cb114-1665" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1666"><a href="#cb114-1666" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"üóëÔ∏è Dropped year_remodeled-related columns from train/test: </span><span class="sc">{</span>cols_to_drop<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1667"><a href="#cb114-1667" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1668"><a href="#cb114-1668" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1669"><a href="#cb114-1669" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1670"><a href="#cb114-1670" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1673"><a href="#cb114-1673" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1674"><a href="#cb114-1674" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_categorical_year_features(df, features, years):</span>
<span id="cb114-1675"><a href="#cb114-1675" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> feature <span class="kw">in</span> features:</span>
<span id="cb114-1676"><a href="#cb114-1676" aria-hidden="true" tabindex="-1"></a>        year_cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb114-1677"><a href="#cb114-1677" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(year_cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb114-1678"><a href="#cb114-1678" aria-hidden="true" tabindex="-1"></a>            df[year_cols] <span class="op">=</span> df[year_cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-1679"><a href="#cb114-1679" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Backfilled: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> across </span><span class="sc">{</span>year_cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1680"><a href="#cb114-1680" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb114-1681"><a href="#cb114-1681" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipped: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> ‚Äî not enough year-based columns."</span>)</span>
<span id="cb114-1682"><a href="#cb114-1682" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb114-1683"><a href="#cb114-1683" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1684"><a href="#cb114-1684" aria-hidden="true" tabindex="-1"></a><span class="co"># Backfill from most recent year to oldest</span></span>
<span id="cb114-1685"><a href="#cb114-1685" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb114-1686"><a href="#cb114-1686" aria-hidden="true" tabindex="-1"></a>features <span class="op">=</span> [<span class="st">'building_condition'</span>, <span class="st">'foundation_type'</span>, <span class="st">'grade'</span>, <span class="st">'has_cooling'</span>, </span>
<span id="cb114-1687"><a href="#cb114-1687" aria-hidden="true" tabindex="-1"></a>            <span class="st">'has_heat'</span>, <span class="st">'physical_condition'</span>, <span class="st">'exterior_walls'</span>]</span>
<span id="cb114-1688"><a href="#cb114-1688" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1689"><a href="#cb114-1689" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to train and test</span></span>
<span id="cb114-1690"><a href="#cb114-1690" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_categorical_year_features(train_merged, features, years)</span>
<span id="cb114-1691"><a href="#cb114-1691" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_categorical_year_features(test_merged, features, years)</span>
<span id="cb114-1692"><a href="#cb114-1692" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1693"><a href="#cb114-1693" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1694"><a href="#cb114-1694" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1695"><a href="#cb114-1695" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1696"><a href="#cb114-1696" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1699"><a href="#cb114-1699" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1700"><a href="#cb114-1700" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_year_columns(df, features, years):</span>
<span id="cb114-1701"><a href="#cb114-1701" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> feature <span class="kw">in</span> features:</span>
<span id="cb114-1702"><a href="#cb114-1702" aria-hidden="true" tabindex="-1"></a>        cols <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb114-1703"><a href="#cb114-1703" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb114-1704"><a href="#cb114-1704" aria-hidden="true" tabindex="-1"></a>            df[cols] <span class="op">=</span> df[cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-1705"><a href="#cb114-1705" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Backfilled: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> across </span><span class="sc">{</span>cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1706"><a href="#cb114-1706" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb114-1707"><a href="#cb114-1707" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipped: </span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss"> ‚Äî not enough year-based columns found."</span>)</span>
<span id="cb114-1708"><a href="#cb114-1708" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb114-1709"><a href="#cb114-1709" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1710"><a href="#cb114-1710" aria-hidden="true" tabindex="-1"></a><span class="co"># Define year ranges</span></span>
<span id="cb114-1711"><a href="#cb114-1711" aria-hidden="true" tabindex="-1"></a>area_years <span class="op">=</span> [<span class="st">'2019'</span>, <span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb114-1712"><a href="#cb114-1712" aria-hidden="true" tabindex="-1"></a>value_years <span class="op">=</span> [<span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb114-1713"><a href="#cb114-1713" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1714"><a href="#cb114-1714" aria-hidden="true" tabindex="-1"></a><span class="co"># Define feature groups</span></span>
<span id="cb114-1715"><a href="#cb114-1715" aria-hidden="true" tabindex="-1"></a>area_features <span class="op">=</span> [<span class="st">'building_area'</span>, <span class="st">'land_area'</span>]</span>
<span id="cb114-1716"><a href="#cb114-1716" aria-hidden="true" tabindex="-1"></a>value_features <span class="op">=</span> [<span class="st">'building_value'</span>, <span class="st">'land_value'</span>, <span class="st">'assessed'</span>]</span>
<span id="cb114-1717"><a href="#cb114-1717" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1718"><a href="#cb114-1718" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to train and test</span></span>
<span id="cb114-1719"><a href="#cb114-1719" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_year_columns(train_merged, area_features, area_years)</span>
<span id="cb114-1720"><a href="#cb114-1720" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_year_columns(train_merged, value_features, value_years)</span>
<span id="cb114-1721"><a href="#cb114-1721" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1722"><a href="#cb114-1722" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_year_columns(test_merged, area_features, area_years)</span>
<span id="cb114-1723"><a href="#cb114-1723" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_year_columns(test_merged, value_features, value_years)</span>
<span id="cb114-1724"><a href="#cb114-1724" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1725"><a href="#cb114-1725" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1726"><a href="#cb114-1726" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1727"><a href="#cb114-1727" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1728"><a href="#cb114-1728" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1731"><a href="#cb114-1731" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1732"><a href="#cb114-1732" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backfill_protested_columns(df, years):</span>
<span id="cb114-1733"><a href="#cb114-1733" aria-hidden="true" tabindex="-1"></a>    cols <span class="op">=</span> [<span class="ss">f"protested_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> y <span class="kw">in</span> years <span class="cf">if</span> <span class="ss">f"protested_</span><span class="sc">{</span>y<span class="sc">}</span><span class="ss">"</span> <span class="kw">in</span> df.columns]</span>
<span id="cb114-1734"><a href="#cb114-1734" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(cols) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb114-1735"><a href="#cb114-1735" aria-hidden="true" tabindex="-1"></a>        df[cols] <span class="op">=</span> df[cols].bfill(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-1736"><a href="#cb114-1736" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Backfilled: protested across </span><span class="sc">{</span>cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1737"><a href="#cb114-1737" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb114-1738"><a href="#cb114-1738" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">" Skipped protested ‚Äî not enough year-based columns found."</span>)</span>
<span id="cb114-1739"><a href="#cb114-1739" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb114-1740"><a href="#cb114-1740" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1741"><a href="#cb114-1741" aria-hidden="true" tabindex="-1"></a><span class="co"># Only use pre-2019 years to avoid leakage</span></span>
<span id="cb114-1742"><a href="#cb114-1742" aria-hidden="true" tabindex="-1"></a>years <span class="op">=</span> [<span class="st">'2018'</span>, <span class="st">'2017'</span>, <span class="st">'2016'</span>, <span class="st">'2015'</span>]</span>
<span id="cb114-1743"><a href="#cb114-1743" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1744"><a href="#cb114-1744" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply to both datasets</span></span>
<span id="cb114-1745"><a href="#cb114-1745" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> backfill_protested_columns(train_merged, years)</span>
<span id="cb114-1746"><a href="#cb114-1746" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> backfill_protested_columns(test_merged, years)</span>
<span id="cb114-1747"><a href="#cb114-1747" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1748"><a href="#cb114-1748" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1749"><a href="#cb114-1749" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1750"><a href="#cb114-1750" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1751"><a href="#cb114-1751" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1754"><a href="#cb114-1754" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1755"><a href="#cb114-1755" aria-hidden="true" tabindex="-1"></a><span class="co"># Save 'acct' from test_merged only</span></span>
<span id="cb114-1756"><a href="#cb114-1756" aria-hidden="true" tabindex="-1"></a>acct_test <span class="op">=</span> test_merged[[<span class="st">'acct'</span>]].copy() <span class="cf">if</span> <span class="st">'acct'</span> <span class="kw">in</span> test_merged.columns <span class="cf">else</span> <span class="va">None</span></span>
<span id="cb114-1757"><a href="#cb114-1757" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1758"><a href="#cb114-1758" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop 'acct' from both train and test</span></span>
<span id="cb114-1759"><a href="#cb114-1759" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb114-1760"><a href="#cb114-1760" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'acct'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb114-1761"><a href="#cb114-1761" aria-hidden="true" tabindex="-1"></a>        df.drop(columns<span class="op">=</span><span class="st">'acct'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-1762"><a href="#cb114-1762" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Dropped 'acct' from </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1763"><a href="#cb114-1763" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1764"><a href="#cb114-1764" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1765"><a href="#cb114-1765" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1766"><a href="#cb114-1766" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1767"><a href="#cb114-1767" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1770"><a href="#cb114-1770" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1771"><a href="#cb114-1771" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> [<span class="st">'zone'</span>, <span class="st">'subneighborhood'</span>, <span class="st">'neighborhood'</span>, <span class="st">'region'</span>]:</span>
<span id="cb114-1772"><a href="#cb114-1772" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-1773"><a href="#cb114-1773" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>train_merged[col]<span class="sc">.</span>nunique()<span class="sc">}</span><span class="ss"> unique values in training set"</span>)</span>
<span id="cb114-1774"><a href="#cb114-1774" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb114-1775"><a href="#cb114-1775" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> not found in training set"</span>)</span>
<span id="cb114-1776"><a href="#cb114-1776" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1777"><a href="#cb114-1777" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1778"><a href="#cb114-1778" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1779"><a href="#cb114-1779" aria-hidden="true" tabindex="-1"></a>cols_to_drop = <span class="co">[</span><span class="ot">'zone', 'subneighborhood'</span><span class="co">]</span></span>
<span id="cb114-1780"><a href="#cb114-1780" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1781"><a href="#cb114-1781" aria-hidden="true" tabindex="-1"></a>for df_name, df in <span class="co">[</span><span class="ot">('train_merged', train_merged), ('test_merged', test_merged)</span><span class="co">]</span>:</span>
<span id="cb114-1782"><a href="#cb114-1782" aria-hidden="true" tabindex="-1"></a>    drop_cols = <span class="co">[</span><span class="ot">col for col in cols_to_drop if col in df.columns</span><span class="co">]</span></span>
<span id="cb114-1783"><a href="#cb114-1783" aria-hidden="true" tabindex="-1"></a>    if drop_cols:</span>
<span id="cb114-1784"><a href="#cb114-1784" aria-hidden="true" tabindex="-1"></a>        df.drop(columns=drop_cols, inplace=True)</span>
<span id="cb114-1785"><a href="#cb114-1785" aria-hidden="true" tabindex="-1"></a>        print(f"üóëÔ∏è Dropped columns from {df_name}: {drop_cols}")</span>
<span id="cb114-1786"><a href="#cb114-1786" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1787"><a href="#cb114-1787" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1790"><a href="#cb114-1790" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1791"><a href="#cb114-1791" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> [<span class="st">'neighborhood'</span>, <span class="st">'region'</span>,<span class="st">'zone'</span>,<span class="st">'subneighborhood'</span>]:</span>
<span id="cb114-1792"><a href="#cb114-1792" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-1793"><a href="#cb114-1793" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 1: Compute frequency from training data</span></span>
<span id="cb114-1794"><a href="#cb114-1794" aria-hidden="true" tabindex="-1"></a>        freq_map <span class="op">=</span> train_merged[col].value_counts(normalize<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-1795"><a href="#cb114-1795" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1796"><a href="#cb114-1796" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 2: Apply to both datasets</span></span>
<span id="cb114-1797"><a href="#cb114-1797" aria-hidden="true" tabindex="-1"></a>        train_merged[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_freq'</span>] <span class="op">=</span> train_merged[col].<span class="bu">map</span>(freq_map)</span>
<span id="cb114-1798"><a href="#cb114-1798" aria-hidden="true" tabindex="-1"></a>        test_merged[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_freq'</span>] <span class="op">=</span> test_merged[col].<span class="bu">map</span>(freq_map)</span>
<span id="cb114-1799"><a href="#cb114-1799" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1800"><a href="#cb114-1800" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Frequency encoded: </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> ‚Üí </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_freq (based on training set)"</span>)</span>
<span id="cb114-1801"><a href="#cb114-1801" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb114-1802"><a href="#cb114-1802" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Column '</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">' not found in training set"</span>)</span>
<span id="cb114-1803"><a href="#cb114-1803" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1804"><a href="#cb114-1804" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1805"><a href="#cb114-1805" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1808"><a href="#cb114-1808" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1809"><a href="#cb114-1809" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">all</span>(col <span class="kw">in</span> train_merged.columns <span class="cf">for</span> col <span class="kw">in</span> [<span class="st">'land_area_2019'</span>, <span class="st">'land_area_2015'</span>]):</span>
<span id="cb114-1810"><a href="#cb114-1810" aria-hidden="true" tabindex="-1"></a>    growth <span class="op">=</span> train_merged[<span class="st">'land_area_2019'</span>] <span class="op">-</span> train_merged[<span class="st">'land_area_2015'</span>]</span>
<span id="cb114-1811"><a href="#cb114-1811" aria-hidden="true" tabindex="-1"></a>    changed_pct <span class="op">=</span> (growth <span class="op">!=</span> <span class="dv">0</span>).mean() <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb114-1812"><a href="#cb114-1812" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Percentage of homes with land area change (2015‚Üí2019): </span><span class="sc">{</span>changed_pct<span class="sc">:.2f}</span><span class="ss">%"</span>)</span>
<span id="cb114-1813"><a href="#cb114-1813" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb114-1814"><a href="#cb114-1814" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">" One or both columns ('land_area_2015', 'land_area_2019') not found in training set"</span>)</span>
<span id="cb114-1815"><a href="#cb114-1815" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1816"><a href="#cb114-1816" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1817"><a href="#cb114-1817" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1818"><a href="#cb114-1818" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1819"><a href="#cb114-1819" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1822"><a href="#cb114-1822" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1823"><a href="#cb114-1823" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb114-1824"><a href="#cb114-1824" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb114-1825"><a href="#cb114-1825" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'year_built_final'</span>] <span class="op">=</span> df[<span class="st">'year_built_final'</span>].astype(<span class="bu">str</span>)</span>
<span id="cb114-1826"><a href="#cb114-1826" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Converted 'year_built_final' to string in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1827"><a href="#cb114-1827" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb114-1828"><a href="#cb114-1828" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" 'year_built_final' not found in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1829"><a href="#cb114-1829" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1830"><a href="#cb114-1830" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1831"><a href="#cb114-1831" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1834"><a href="#cb114-1834" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1835"><a href="#cb114-1835" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb114-1836"><a href="#cb114-1836" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'floor_area_total_final'</span> <span class="kw">in</span> df.columns <span class="kw">and</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb114-1837"><a href="#cb114-1837" aria-hidden="true" tabindex="-1"></a>        df.loc[df[<span class="st">'floor_area_total_final'</span>] <span class="op">==</span> <span class="dv">0</span>, <span class="st">'year_built_final'</span>] <span class="op">=</span> <span class="st">'None'</span></span>
<span id="cb114-1838"><a href="#cb114-1838" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Set 'year_built_final' to 'None' where 'floor_area_total_final' == 0 in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1839"><a href="#cb114-1839" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb114-1840"><a href="#cb114-1840" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Required columns missing in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1841"><a href="#cb114-1841" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1842"><a href="#cb114-1842" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1843"><a href="#cb114-1843" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1846"><a href="#cb114-1846" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1847"><a href="#cb114-1847" aria-hidden="true" tabindex="-1"></a><span class="co"># Define year ranges per feature type</span></span>
<span id="cb114-1848"><a href="#cb114-1848" aria-hidden="true" tabindex="-1"></a>value_years <span class="op">=</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2019</span>)   <span class="co"># 2015‚Äì2018 for value columns</span></span>
<span id="cb114-1849"><a href="#cb114-1849" aria-hidden="true" tabindex="-1"></a>area_years  <span class="op">=</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)   <span class="co"># 2015‚Äì2019 for area columns</span></span>
<span id="cb114-1850"><a href="#cb114-1850" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1851"><a href="#cb114-1851" aria-hidden="true" tabindex="-1"></a><span class="co"># Define base columns</span></span>
<span id="cb114-1852"><a href="#cb114-1852" aria-hidden="true" tabindex="-1"></a>base_cols_year_map <span class="op">=</span> {</span>
<span id="cb114-1853"><a href="#cb114-1853" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_value'</span>: value_years,</span>
<span id="cb114-1854"><a href="#cb114-1854" aria-hidden="true" tabindex="-1"></a>    <span class="st">'land_value'</span>: value_years,</span>
<span id="cb114-1855"><a href="#cb114-1855" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_area'</span>: area_years,</span>
<span id="cb114-1856"><a href="#cb114-1856" aria-hidden="true" tabindex="-1"></a>    <span class="st">'land_area'</span>: area_years,</span>
<span id="cb114-1857"><a href="#cb114-1857" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb114-1858"><a href="#cb114-1858" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1859"><a href="#cb114-1859" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate full list of columns to impute</span></span>
<span id="cb114-1860"><a href="#cb114-1860" aria-hidden="true" tabindex="-1"></a>cols_to_impute <span class="op">=</span> []</span>
<span id="cb114-1861"><a href="#cb114-1861" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> base, years <span class="kw">in</span> base_cols_year_map.items():</span>
<span id="cb114-1862"><a href="#cb114-1862" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> year <span class="kw">in</span> years:</span>
<span id="cb114-1863"><a href="#cb114-1863" aria-hidden="true" tabindex="-1"></a>        cols_to_impute.append(<span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1864"><a href="#cb114-1864" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1865"><a href="#cb114-1865" aria-hidden="true" tabindex="-1"></a><span class="co"># Impute using neighborhood ‚Üí region strategy</span></span>
<span id="cb114-1866"><a href="#cb114-1866" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> cols_to_impute:</span>
<span id="cb114-1867"><a href="#cb114-1867" aria-hidden="true" tabindex="-1"></a>    <span class="co"># First, fill by neighborhood (train only)</span></span>
<span id="cb114-1868"><a href="#cb114-1868" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'neighborhood'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-1869"><a href="#cb114-1869" aria-hidden="true" tabindex="-1"></a>        medians_by_neigh <span class="op">=</span> train_merged.groupby(<span class="st">'neighborhood'</span>)[col].median()</span>
<span id="cb114-1870"><a href="#cb114-1870" aria-hidden="true" tabindex="-1"></a>        train_merged[col] <span class="op">=</span> train_merged.<span class="bu">apply</span>(</span>
<span id="cb114-1871"><a href="#cb114-1871" aria-hidden="true" tabindex="-1"></a>            <span class="kw">lambda</span> row: medians_by_neigh[row[<span class="st">'neighborhood'</span>]] <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-1872"><a href="#cb114-1872" aria-hidden="true" tabindex="-1"></a>        test_merged[col] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb114-1873"><a href="#cb114-1873" aria-hidden="true" tabindex="-1"></a>            <span class="kw">lambda</span> row: medians_by_neigh.get(row[<span class="st">'neighborhood'</span>], np.nan) <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-1874"><a href="#cb114-1874" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1875"><a href="#cb114-1875" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Then, fill remaining by region (train only)</span></span>
<span id="cb114-1876"><a href="#cb114-1876" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'region'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-1877"><a href="#cb114-1877" aria-hidden="true" tabindex="-1"></a>        medians_by_region <span class="op">=</span> train_merged.groupby(<span class="st">'region'</span>)[col].median()</span>
<span id="cb114-1878"><a href="#cb114-1878" aria-hidden="true" tabindex="-1"></a>        train_merged[col] <span class="op">=</span> train_merged.<span class="bu">apply</span>(</span>
<span id="cb114-1879"><a href="#cb114-1879" aria-hidden="true" tabindex="-1"></a>            <span class="kw">lambda</span> row: medians_by_region[row[<span class="st">'region'</span>]] <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-1880"><a href="#cb114-1880" aria-hidden="true" tabindex="-1"></a>        test_merged[col] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb114-1881"><a href="#cb114-1881" aria-hidden="true" tabindex="-1"></a>            <span class="kw">lambda</span> row: medians_by_region.get(row[<span class="st">'region'</span>], np.nan) <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-1882"><a href="#cb114-1882" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1883"><a href="#cb114-1883" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Imputed '</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">' using group medians (neighborhood ‚Üí region) from training data"</span>)</span>
<span id="cb114-1884"><a href="#cb114-1884" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1885"><a href="#cb114-1885" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1886"><a href="#cb114-1886" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1887"><a href="#cb114-1887" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1890"><a href="#cb114-1890" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1891"><a href="#cb114-1891" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pandas.api.types <span class="im">import</span> is_numeric_dtype</span>
<span id="cb114-1892"><a href="#cb114-1892" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1893"><a href="#cb114-1893" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1: Coerce non-numeric to NaN in both sets</span></span>
<span id="cb114-1894"><a href="#cb114-1894" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb114-1895"><a href="#cb114-1895" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb114-1896"><a href="#cb114-1896" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'year_built_final'</span>] <span class="op">=</span> pd.to_numeric(df[<span class="st">'year_built_final'</span>], errors<span class="op">=</span><span class="st">'coerce'</span>)</span>
<span id="cb114-1897"><a href="#cb114-1897" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Coerced 'year_built_final' to numeric in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-1898"><a href="#cb114-1898" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1899"><a href="#cb114-1899" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 2: Group-based imputation (use training data only)</span></span>
<span id="cb114-1900"><a href="#cb114-1900" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> train_merged.columns <span class="kw">and</span> <span class="st">'neighborhood'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-1901"><a href="#cb114-1901" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Neighborhood-based median from train</span></span>
<span id="cb114-1902"><a href="#cb114-1902" aria-hidden="true" tabindex="-1"></a>    neigh_medians <span class="op">=</span> train_merged.groupby(<span class="st">'neighborhood'</span>)[<span class="st">'year_built_final'</span>].median()</span>
<span id="cb114-1903"><a href="#cb114-1903" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1904"><a href="#cb114-1904" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Apply to train</span></span>
<span id="cb114-1905"><a href="#cb114-1905" aria-hidden="true" tabindex="-1"></a>    train_merged[<span class="st">'year_built_final'</span>] <span class="op">=</span> train_merged.<span class="bu">apply</span>(</span>
<span id="cb114-1906"><a href="#cb114-1906" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: neigh_medians[row[<span class="st">'neighborhood'</span>]] <span class="cf">if</span> pd.isna(row[<span class="st">'year_built_final'</span>]) <span class="cf">else</span> row[<span class="st">'year_built_final'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-1907"><a href="#cb114-1907" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1908"><a href="#cb114-1908" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Apply to test</span></span>
<span id="cb114-1909"><a href="#cb114-1909" aria-hidden="true" tabindex="-1"></a>    test_merged[<span class="st">'year_built_final'</span>] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb114-1910"><a href="#cb114-1910" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: neigh_medians.get(row[<span class="st">'neighborhood'</span>], np.nan) <span class="cf">if</span> pd.isna(row[<span class="st">'year_built_final'</span>]) <span class="cf">else</span> row[<span class="st">'year_built_final'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-1911"><a href="#cb114-1911" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1912"><a href="#cb114-1912" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'region'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-1913"><a href="#cb114-1913" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Region-based fallback median from train</span></span>
<span id="cb114-1914"><a href="#cb114-1914" aria-hidden="true" tabindex="-1"></a>    region_medians <span class="op">=</span> train_merged.groupby(<span class="st">'region'</span>)[<span class="st">'year_built_final'</span>].median()</span>
<span id="cb114-1915"><a href="#cb114-1915" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1916"><a href="#cb114-1916" aria-hidden="true" tabindex="-1"></a>    train_merged[<span class="st">'year_built_final'</span>] <span class="op">=</span> train_merged.<span class="bu">apply</span>(</span>
<span id="cb114-1917"><a href="#cb114-1917" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: region_medians[row[<span class="st">'region'</span>]] <span class="cf">if</span> pd.isna(row[<span class="st">'year_built_final'</span>]) <span class="cf">else</span> row[<span class="st">'year_built_final'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-1918"><a href="#cb114-1918" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1919"><a href="#cb114-1919" aria-hidden="true" tabindex="-1"></a>    test_merged[<span class="st">'year_built_final'</span>] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb114-1920"><a href="#cb114-1920" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: region_medians.get(row[<span class="st">'region'</span>], np.nan) <span class="cf">if</span> pd.isna(row[<span class="st">'year_built_final'</span>]) <span class="cf">else</span> row[<span class="st">'year_built_final'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-1921"><a href="#cb114-1921" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1922"><a href="#cb114-1922" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Imputed 'year_built_final' using neighborhood ‚Üí region medians from training set"</span>)</span>
<span id="cb114-1923"><a href="#cb114-1923" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1924"><a href="#cb114-1924" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1925"><a href="#cb114-1925" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1928"><a href="#cb114-1928" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1929"><a href="#cb114-1929" aria-hidden="true" tabindex="-1"></a><span class="co"># List of all assessed columns to impute</span></span>
<span id="cb114-1930"><a href="#cb114-1930" aria-hidden="true" tabindex="-1"></a>assessed_cols <span class="op">=</span> [<span class="st">'assessed_2015'</span>, <span class="st">'assessed_2016'</span>, <span class="st">'assessed_2017'</span>, <span class="st">'assessed_2018'</span>]</span>
<span id="cb114-1931"><a href="#cb114-1931" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1932"><a href="#cb114-1932" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> assessed_cols:</span>
<span id="cb114-1933"><a href="#cb114-1933" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">not</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-1934"><a href="#cb114-1934" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span></span>
<span id="cb114-1935"><a href="#cb114-1935" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1936"><a href="#cb114-1936" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: Compute medians from training data only</span></span>
<span id="cb114-1937"><a href="#cb114-1937" aria-hidden="true" tabindex="-1"></a>    neigh_medians <span class="op">=</span> train_merged.groupby(<span class="st">'neighborhood'</span>)[col].median()</span>
<span id="cb114-1938"><a href="#cb114-1938" aria-hidden="true" tabindex="-1"></a>    region_medians <span class="op">=</span> train_merged.groupby(<span class="st">'region'</span>)[col].median()</span>
<span id="cb114-1939"><a href="#cb114-1939" aria-hidden="true" tabindex="-1"></a>    global_median <span class="op">=</span> train_merged[col].median()</span>
<span id="cb114-1940"><a href="#cb114-1940" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1941"><a href="#cb114-1941" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 2: Train set imputation</span></span>
<span id="cb114-1942"><a href="#cb114-1942" aria-hidden="true" tabindex="-1"></a>    train_merged[col] <span class="op">=</span> train_merged.<span class="bu">apply</span>(</span>
<span id="cb114-1943"><a href="#cb114-1943" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: neigh_medians[row[<span class="st">'neighborhood'</span>]]</span>
<span id="cb114-1944"><a href="#cb114-1944" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pd.isna(row[col]) <span class="kw">and</span> row[<span class="st">'neighborhood'</span>] <span class="kw">in</span> neigh_medians <span class="cf">else</span></span>
<span id="cb114-1945"><a href="#cb114-1945" aria-hidden="true" tabindex="-1"></a>        region_medians[row[<span class="st">'region'</span>]]</span>
<span id="cb114-1946"><a href="#cb114-1946" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pd.isna(row[col]) <span class="kw">and</span> row[<span class="st">'region'</span>] <span class="kw">in</span> region_medians <span class="cf">else</span></span>
<span id="cb114-1947"><a href="#cb114-1947" aria-hidden="true" tabindex="-1"></a>        global_median</span>
<span id="cb114-1948"><a href="#cb114-1948" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span></span>
<span id="cb114-1949"><a href="#cb114-1949" aria-hidden="true" tabindex="-1"></a>        row[col],</span>
<span id="cb114-1950"><a href="#cb114-1950" aria-hidden="true" tabindex="-1"></a>        axis<span class="op">=</span><span class="dv">1</span></span>
<span id="cb114-1951"><a href="#cb114-1951" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb114-1952"><a href="#cb114-1952" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1953"><a href="#cb114-1953" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 3: Test set imputation (using train medians only)</span></span>
<span id="cb114-1954"><a href="#cb114-1954" aria-hidden="true" tabindex="-1"></a>    test_merged[col] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb114-1955"><a href="#cb114-1955" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: neigh_medians.get(row[<span class="st">'neighborhood'</span>], np.nan)</span>
<span id="cb114-1956"><a href="#cb114-1956" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col],</span>
<span id="cb114-1957"><a href="#cb114-1957" aria-hidden="true" tabindex="-1"></a>        axis<span class="op">=</span><span class="dv">1</span></span>
<span id="cb114-1958"><a href="#cb114-1958" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb114-1959"><a href="#cb114-1959" aria-hidden="true" tabindex="-1"></a>    test_merged[col] <span class="op">=</span> test_merged.<span class="bu">apply</span>(</span>
<span id="cb114-1960"><a href="#cb114-1960" aria-hidden="true" tabindex="-1"></a>        <span class="kw">lambda</span> row: region_medians.get(row[<span class="st">'region'</span>], np.nan)</span>
<span id="cb114-1961"><a href="#cb114-1961" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pd.isna(row[col]) <span class="cf">else</span> row[col],</span>
<span id="cb114-1962"><a href="#cb114-1962" aria-hidden="true" tabindex="-1"></a>        axis<span class="op">=</span><span class="dv">1</span></span>
<span id="cb114-1963"><a href="#cb114-1963" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb114-1964"><a href="#cb114-1964" aria-hidden="true" tabindex="-1"></a>    test_merged[col].fillna(global_median, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-1965"><a href="#cb114-1965" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1966"><a href="#cb114-1966" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Imputed '</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">' using neighborhood ‚Üí region ‚Üí global medians (from training data)"</span>)</span>
<span id="cb114-1967"><a href="#cb114-1967" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1968"><a href="#cb114-1968" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-1969"><a href="#cb114-1969" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1972"><a href="#cb114-1972" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-1973"><a href="#cb114-1973" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 1: Compute neighborhood-level stats ===</span></span>
<span id="cb114-1974"><a href="#cb114-1974" aria-hidden="true" tabindex="-1"></a>neigh_stats <span class="op">=</span> train_merged.groupby(<span class="st">'neighborhood'</span>)[<span class="st">'assessed_2018'</span>].agg([</span>
<span id="cb114-1975"><a href="#cb114-1975" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'neigh_assess_mean'</span>, <span class="st">'mean'</span>),</span>
<span id="cb114-1976"><a href="#cb114-1976" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'neigh_assess_median'</span>, <span class="st">'median'</span>),</span>
<span id="cb114-1977"><a href="#cb114-1977" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'neigh_assess_std'</span>, <span class="st">'std'</span>),</span>
<span id="cb114-1978"><a href="#cb114-1978" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'neigh_assess_q1'</span>, <span class="kw">lambda</span> x: x.quantile(<span class="fl">0.25</span>)),</span>
<span id="cb114-1979"><a href="#cb114-1979" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'neigh_assess_q3'</span>, <span class="kw">lambda</span> x: x.quantile(<span class="fl">0.75</span>)),</span>
<span id="cb114-1980"><a href="#cb114-1980" aria-hidden="true" tabindex="-1"></a>]).reset_index()</span>
<span id="cb114-1981"><a href="#cb114-1981" aria-hidden="true" tabindex="-1"></a>neigh_stats[<span class="st">'neigh_assess_iqr'</span>] <span class="op">=</span> neigh_stats[<span class="st">'neigh_assess_q3'</span>] <span class="op">-</span> neigh_stats[<span class="st">'neigh_assess_q1'</span>]</span>
<span id="cb114-1982"><a href="#cb114-1982" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1983"><a href="#cb114-1983" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 2: Compute region-level stats ===</span></span>
<span id="cb114-1984"><a href="#cb114-1984" aria-hidden="true" tabindex="-1"></a>region_stats <span class="op">=</span> train_merged.groupby(<span class="st">'region'</span>)[<span class="st">'assessed_2018'</span>].agg([</span>
<span id="cb114-1985"><a href="#cb114-1985" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'region_assess_mean'</span>, <span class="st">'mean'</span>),</span>
<span id="cb114-1986"><a href="#cb114-1986" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'region_assess_median'</span>, <span class="st">'median'</span>),</span>
<span id="cb114-1987"><a href="#cb114-1987" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'region_assess_std'</span>, <span class="st">'std'</span>),</span>
<span id="cb114-1988"><a href="#cb114-1988" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'region_assess_q1'</span>, <span class="kw">lambda</span> x: x.quantile(<span class="fl">0.25</span>)),</span>
<span id="cb114-1989"><a href="#cb114-1989" aria-hidden="true" tabindex="-1"></a>    (<span class="st">'region_assess_q3'</span>, <span class="kw">lambda</span> x: x.quantile(<span class="fl">0.75</span>)),</span>
<span id="cb114-1990"><a href="#cb114-1990" aria-hidden="true" tabindex="-1"></a>]).reset_index()</span>
<span id="cb114-1991"><a href="#cb114-1991" aria-hidden="true" tabindex="-1"></a>region_stats[<span class="st">'region_assess_iqr'</span>] <span class="op">=</span> region_stats[<span class="st">'region_assess_q3'</span>] <span class="op">-</span> region_stats[<span class="st">'region_assess_q1'</span>]</span>
<span id="cb114-1992"><a href="#cb114-1992" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1993"><a href="#cb114-1993" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 3: Fallback std maps from training data ===</span></span>
<span id="cb114-1994"><a href="#cb114-1994" aria-hidden="true" tabindex="-1"></a><span class="co"># For neighborhood fallback, group region medians of neighborhood std</span></span>
<span id="cb114-1995"><a href="#cb114-1995" aria-hidden="true" tabindex="-1"></a>neigh_std_by_region <span class="op">=</span> neigh_stats.merge(train_merged[[<span class="st">'neighborhood'</span>, <span class="st">'region'</span>]], on<span class="op">=</span><span class="st">'neighborhood'</span>, how<span class="op">=</span><span class="st">'left'</span>) <span class="op">\</span></span>
<span id="cb114-1996"><a href="#cb114-1996" aria-hidden="true" tabindex="-1"></a>                                  .groupby(<span class="st">'region'</span>)[<span class="st">'neigh_assess_std'</span>].median()</span>
<span id="cb114-1997"><a href="#cb114-1997" aria-hidden="true" tabindex="-1"></a>global_neigh_std <span class="op">=</span> neigh_stats[<span class="st">'neigh_assess_std'</span>].median()</span>
<span id="cb114-1998"><a href="#cb114-1998" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-1999"><a href="#cb114-1999" aria-hidden="true" tabindex="-1"></a>region_std_by_neigh <span class="op">=</span> region_stats.merge(train_merged[[<span class="st">'neighborhood'</span>, <span class="st">'region'</span>]], on<span class="op">=</span><span class="st">'region'</span>, how<span class="op">=</span><span class="st">'left'</span>) <span class="op">\</span></span>
<span id="cb114-2000"><a href="#cb114-2000" aria-hidden="true" tabindex="-1"></a>                                   .groupby(<span class="st">'neighborhood'</span>)[<span class="st">'region_assess_std'</span>].median()</span>
<span id="cb114-2001"><a href="#cb114-2001" aria-hidden="true" tabindex="-1"></a>global_region_std <span class="op">=</span> region_stats[<span class="st">'region_assess_std'</span>].median()</span>
<span id="cb114-2002"><a href="#cb114-2002" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2003"><a href="#cb114-2003" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 4: Merge into train/test and compute features ===</span></span>
<span id="cb114-2004"><a href="#cb114-2004" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb114-2005"><a href="#cb114-2005" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.merge(neigh_stats, on<span class="op">=</span><span class="st">'neighborhood'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb114-2006"><a href="#cb114-2006" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.merge(region_stats, on<span class="op">=</span><span class="st">'region'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb114-2007"><a href="#cb114-2007" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2008"><a href="#cb114-2008" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill missing std values via fallback</span></span>
<span id="cb114-2009"><a href="#cb114-2009" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'neigh_assess_std'</span>] <span class="op">=</span> df[<span class="st">'neigh_assess_std'</span>].fillna(</span>
<span id="cb114-2010"><a href="#cb114-2010" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'region'</span>].<span class="bu">map</span>(neigh_std_by_region)</span>
<span id="cb114-2011"><a href="#cb114-2011" aria-hidden="true" tabindex="-1"></a>    ).fillna(global_neigh_std)</span>
<span id="cb114-2012"><a href="#cb114-2012" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2013"><a href="#cb114-2013" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'region_assess_std'</span>] <span class="op">=</span> df[<span class="st">'region_assess_std'</span>].fillna(</span>
<span id="cb114-2014"><a href="#cb114-2014" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'neighborhood'</span>].<span class="bu">map</span>(region_std_by_neigh)</span>
<span id="cb114-2015"><a href="#cb114-2015" aria-hidden="true" tabindex="-1"></a>    ).fillna(global_region_std)</span>
<span id="cb114-2016"><a href="#cb114-2016" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2017"><a href="#cb114-2017" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute derived features</span></span>
<span id="cb114-2018"><a href="#cb114-2018" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'assess_minus_neigh_mean'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">-</span> df[<span class="st">'neigh_assess_mean'</span>]</span>
<span id="cb114-2019"><a href="#cb114-2019" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'assess_ratio_neigh_mean'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">/</span> (df[<span class="st">'neigh_assess_mean'</span>] <span class="op">+</span> <span class="fl">1e-6</span>)</span>
<span id="cb114-2020"><a href="#cb114-2020" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'z_score_assess_neigh'</span>] <span class="op">=</span> df[<span class="st">'assess_minus_neigh_mean'</span>] <span class="op">/</span> (df[<span class="st">'neigh_assess_std'</span>] <span class="op">+</span> <span class="fl">1e-6</span>)</span>
<span id="cb114-2021"><a href="#cb114-2021" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2022"><a href="#cb114-2022" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'assess_minus_region_mean'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">-</span> df[<span class="st">'region_assess_mean'</span>]</span>
<span id="cb114-2023"><a href="#cb114-2023" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'assess_ratio_region_mean'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">/</span> (df[<span class="st">'region_assess_mean'</span>] <span class="op">+</span> <span class="fl">1e-6</span>)</span>
<span id="cb114-2024"><a href="#cb114-2024" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'z_score_assess_region'</span>] <span class="op">=</span> df[<span class="st">'assess_minus_region_mean'</span>] <span class="op">/</span> (df[<span class="st">'region_assess_std'</span>] <span class="op">+</span> <span class="fl">1e-6</span>)</span>
<span id="cb114-2025"><a href="#cb114-2025" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2026"><a href="#cb114-2026" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Save back</span></span>
<span id="cb114-2027"><a href="#cb114-2027" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> df_name <span class="op">==</span> <span class="st">'train_merged'</span>:</span>
<span id="cb114-2028"><a href="#cb114-2028" aria-hidden="true" tabindex="-1"></a>        train_merged <span class="op">=</span> df</span>
<span id="cb114-2029"><a href="#cb114-2029" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb114-2030"><a href="#cb114-2030" aria-hidden="true" tabindex="-1"></a>        test_merged <span class="op">=</span> df</span>
<span id="cb114-2031"><a href="#cb114-2031" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2032"><a href="#cb114-2032" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Completed: Stats merge + std fallback + z-score computation."</span>)</span>
<span id="cb114-2033"><a href="#cb114-2033" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2034"><a href="#cb114-2034" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-2035"><a href="#cb114-2035" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2038"><a href="#cb114-2038" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-2039"><a href="#cb114-2039" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> [<span class="st">'neighborhood'</span>, <span class="st">'region'</span>,<span class="st">'zone'</span>,<span class="st">'subneighborhood'</span>]</span>
<span id="cb114-2040"><a href="#cb114-2040" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2041"><a href="#cb114-2041" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb114-2042"><a href="#cb114-2042" aria-hidden="true" tabindex="-1"></a>    drop_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> cols_to_drop <span class="cf">if</span> col <span class="kw">in</span> df.columns]</span>
<span id="cb114-2043"><a href="#cb114-2043" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> drop_cols:</span>
<span id="cb114-2044"><a href="#cb114-2044" aria-hidden="true" tabindex="-1"></a>        df.drop(columns<span class="op">=</span>drop_cols, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-2045"><a href="#cb114-2045" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Dropped columns from </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>drop_cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-2046"><a href="#cb114-2046" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2047"><a href="#cb114-2047" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-2048"><a href="#cb114-2048" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2051"><a href="#cb114-2051" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-2052"><a href="#cb114-2052" aria-hidden="true" tabindex="-1"></a>growth_pairs <span class="op">=</span> {</span>
<span id="cb114-2053"><a href="#cb114-2053" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_value_growth'</span>: (<span class="st">'building_value_2018'</span>, <span class="st">'building_value_2015'</span>),</span>
<span id="cb114-2054"><a href="#cb114-2054" aria-hidden="true" tabindex="-1"></a>    <span class="st">'land_value_growth'</span>:     (<span class="st">'land_value_2018'</span>, <span class="st">'land_value_2015'</span>),</span>
<span id="cb114-2055"><a href="#cb114-2055" aria-hidden="true" tabindex="-1"></a>    <span class="st">'assessed_growth'</span>:       (<span class="st">'assessed_2018'</span>, <span class="st">'assessed_2015'</span>)</span>
<span id="cb114-2056"><a href="#cb114-2056" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb114-2057"><a href="#cb114-2057" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2058"><a href="#cb114-2058" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb114-2059"><a href="#cb114-2059" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> new_col, (final_col, base_col) <span class="kw">in</span> growth_pairs.items():</span>
<span id="cb114-2060"><a href="#cb114-2060" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> final_col <span class="kw">in</span> df.columns <span class="kw">and</span> base_col <span class="kw">in</span> df.columns:</span>
<span id="cb114-2061"><a href="#cb114-2061" aria-hidden="true" tabindex="-1"></a>            df[new_col] <span class="op">=</span> df[final_col] <span class="op">-</span> df[base_col]</span>
<span id="cb114-2062"><a href="#cb114-2062" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Created </span><span class="sc">{</span>new_col<span class="sc">}</span><span class="ss"> in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-2063"><a href="#cb114-2063" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb114-2064"><a href="#cb114-2064" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Skipped </span><span class="sc">{</span>new_col<span class="sc">}</span><span class="ss"> in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">: missing </span><span class="sc">{</span>final_col<span class="sc">}</span><span class="ss"> or </span><span class="sc">{</span>base_col<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-2065"><a href="#cb114-2065" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2066"><a href="#cb114-2066" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Building Age ===</span></span>
<span id="cb114-2067"><a href="#cb114-2067" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb114-2068"><a href="#cb114-2068" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'year_built_final'</span>] <span class="op">=</span> pd.to_numeric(df[<span class="st">'year_built_final'</span>], errors<span class="op">=</span><span class="st">'coerce'</span>)  <span class="co"># handle 'Vacant', etc.</span></span>
<span id="cb114-2069"><a href="#cb114-2069" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'building_age'</span>] <span class="op">=</span> <span class="dv">2018</span> <span class="op">-</span> df[<span class="st">'year_built_final'</span>]</span>
<span id="cb114-2070"><a href="#cb114-2070" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Created building_age in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-2071"><a href="#cb114-2071" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb114-2072"><a href="#cb114-2072" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Skipped building_age in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">: missing year_built_final"</span>)</span>
<span id="cb114-2073"><a href="#cb114-2073" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2074"><a href="#cb114-2074" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-2075"><a href="#cb114-2075" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2078"><a href="#cb114-2078" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-2079"><a href="#cb114-2079" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'school_dist'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-2080"><a href="#cb114-2080" aria-hidden="true" tabindex="-1"></a>    missing_pct <span class="op">=</span> train_merged[<span class="st">'school_dist'</span>].isna().mean() <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb114-2081"><a href="#cb114-2081" aria-hidden="true" tabindex="-1"></a>    missing_count <span class="op">=</span> train_merged[<span class="st">'school_dist'</span>].isna().<span class="bu">sum</span>()</span>
<span id="cb114-2082"><a href="#cb114-2082" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2083"><a href="#cb114-2083" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" 'school_dist' has </span><span class="sc">{</span>missing_count<span class="sc">}</span><span class="ss"> missing values (</span><span class="sc">{</span>missing_pct<span class="sc">:.2f}</span><span class="ss">%) in training set"</span>)</span>
<span id="cb114-2084"><a href="#cb114-2084" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb114-2085"><a href="#cb114-2085" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">" 'school_dist' not found in training set"</span>)</span>
<span id="cb114-2086"><a href="#cb114-2086" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2087"><a href="#cb114-2087" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-2088"><a href="#cb114-2088" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2091"><a href="#cb114-2091" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-2092"><a href="#cb114-2092" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'school_dist'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-2093"><a href="#cb114-2093" aria-hidden="true" tabindex="-1"></a>    school_dist_median <span class="op">=</span> train_merged[<span class="st">'school_dist'</span>].median()</span>
<span id="cb114-2094"><a href="#cb114-2094" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2095"><a href="#cb114-2095" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb114-2096"><a href="#cb114-2096" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="st">'school_dist'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb114-2097"><a href="#cb114-2097" aria-hidden="true" tabindex="-1"></a>            df[<span class="st">'school_dist'</span>] <span class="op">=</span> df[<span class="st">'school_dist'</span>].fillna(school_dist_median)</span>
<span id="cb114-2098"><a href="#cb114-2098" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f" Filled missing 'school_dist' in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss"> using train median (</span><span class="sc">{</span>school_dist_median<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb114-2099"><a href="#cb114-2099" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb114-2100"><a href="#cb114-2100" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">" 'school_dist' not found in train_merged"</span>)</span>
<span id="cb114-2101"><a href="#cb114-2101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2102"><a href="#cb114-2102" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-2103"><a href="#cb114-2103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2106"><a href="#cb114-2106" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-2107"><a href="#cb114-2107" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">'year_built_final'</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-2108"><a href="#cb114-2108" aria-hidden="true" tabindex="-1"></a>    missing_pct <span class="op">=</span> train_merged[<span class="st">'year_built_final'</span>].isna().mean() <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb114-2109"><a href="#cb114-2109" aria-hidden="true" tabindex="-1"></a>    missing_count <span class="op">=</span> train_merged[<span class="st">'year_built_final'</span>].isna().<span class="bu">sum</span>()</span>
<span id="cb114-2110"><a href="#cb114-2110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2111"><a href="#cb114-2111" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" 'year_built_final' has </span><span class="sc">{</span>missing_count<span class="sc">}</span><span class="ss"> missing values (</span><span class="sc">{</span>missing_pct<span class="sc">:.2f}</span><span class="ss">%) in training set"</span>)</span>
<span id="cb114-2112"><a href="#cb114-2112" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb114-2113"><a href="#cb114-2113" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">" 'year_built_final' not found in training set"</span>)</span>
<span id="cb114-2114"><a href="#cb114-2114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2115"><a href="#cb114-2115" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-2116"><a href="#cb114-2116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2119"><a href="#cb114-2119" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-2120"><a href="#cb114-2120" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 0: Define base feature names ===</span></span>
<span id="cb114-2121"><a href="#cb114-2121" aria-hidden="true" tabindex="-1"></a>numeric_bases <span class="op">=</span> [</span>
<span id="cb114-2122"><a href="#cb114-2122" aria-hidden="true" tabindex="-1"></a>    <span class="st">'garage_area'</span>, <span class="st">'porch_area'</span>, <span class="st">'floors'</span>, <span class="st">'half_bath'</span>, <span class="st">'full_bath'</span>,</span>
<span id="cb114-2123"><a href="#cb114-2123" aria-hidden="true" tabindex="-1"></a>    <span class="st">'total_rooms'</span>, <span class="st">'bedrooms'</span>, <span class="st">'fireplaces'</span>, <span class="st">'building_area'</span>, <span class="st">'building_value'</span></span>
<span id="cb114-2124"><a href="#cb114-2124" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb114-2125"><a href="#cb114-2125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2126"><a href="#cb114-2126" aria-hidden="true" tabindex="-1"></a>categorical_fill_map <span class="op">=</span> {</span>
<span id="cb114-2127"><a href="#cb114-2127" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality'</span>: <span class="st">'None'</span>,</span>
<span id="cb114-2128"><a href="#cb114-2128" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality_description'</span>: <span class="st">'None'</span>,</span>
<span id="cb114-2129"><a href="#cb114-2129" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_condition'</span>: <span class="st">'None'</span>,</span>
<span id="cb114-2130"><a href="#cb114-2130" aria-hidden="true" tabindex="-1"></a>    <span class="st">'foundation_type'</span>: <span class="st">'None'</span>,</span>
<span id="cb114-2131"><a href="#cb114-2131" aria-hidden="true" tabindex="-1"></a>    <span class="st">'grade'</span>: <span class="st">'None'</span>,</span>
<span id="cb114-2132"><a href="#cb114-2132" aria-hidden="true" tabindex="-1"></a>    <span class="st">'has_cooling'</span>: <span class="va">False</span>,</span>
<span id="cb114-2133"><a href="#cb114-2133" aria-hidden="true" tabindex="-1"></a>    <span class="st">'has_heat'</span>: <span class="va">False</span>,</span>
<span id="cb114-2134"><a href="#cb114-2134" aria-hidden="true" tabindex="-1"></a>    <span class="st">'physical_condition'</span>: <span class="st">'None'</span>,</span>
<span id="cb114-2135"><a href="#cb114-2135" aria-hidden="true" tabindex="-1"></a>    <span class="st">'exterior_walls'</span>: <span class="st">'None'</span>,</span>
<span id="cb114-2136"><a href="#cb114-2136" aria-hidden="true" tabindex="-1"></a>    <span class="st">'protested'</span>: <span class="va">False</span></span>
<span id="cb114-2137"><a href="#cb114-2137" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb114-2138"><a href="#cb114-2138" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2139"><a href="#cb114-2139" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate full list of columns (2015‚Äì2019 only, no final columns)</span></span>
<span id="cb114-2140"><a href="#cb114-2140" aria-hidden="true" tabindex="-1"></a>numeric_cols_to_zero <span class="op">=</span> [</span>
<span id="cb114-2141"><a href="#cb114-2141" aria-hidden="true" tabindex="-1"></a>    <span class="ss">f'</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> base <span class="kw">in</span> numeric_bases <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)</span>
<span id="cb114-2142"><a href="#cb114-2142" aria-hidden="true" tabindex="-1"></a>] <span class="op">+</span> [<span class="st">'building_value_growth'</span>]</span>
<span id="cb114-2143"><a href="#cb114-2143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2144"><a href="#cb114-2144" aria-hidden="true" tabindex="-1"></a>categorical_cols_to_fill <span class="op">=</span> {</span>
<span id="cb114-2145"><a href="#cb114-2145" aria-hidden="true" tabindex="-1"></a>    <span class="ss">f'</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">'</span>: val</span>
<span id="cb114-2146"><a href="#cb114-2146" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> base, val <span class="kw">in</span> categorical_fill_map.items()</span>
<span id="cb114-2147"><a href="#cb114-2147" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)</span>
<span id="cb114-2148"><a href="#cb114-2148" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb114-2149"><a href="#cb114-2149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2150"><a href="#cb114-2150" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 1: Apply imputation if floor_area_total_2019 == 0 ===</span></span>
<span id="cb114-2151"><a href="#cb114-2151" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb114-2152"><a href="#cb114-2152" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'floor_area_total_2019'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb114-2153"><a href="#cb114-2153" aria-hidden="true" tabindex="-1"></a>        zero_floor_mask <span class="op">=</span> df[<span class="st">'floor_area_total_2019'</span>] <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb114-2154"><a href="#cb114-2154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2155"><a href="#cb114-2155" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Fill numeric columns with 0</span></span>
<span id="cb114-2156"><a href="#cb114-2156" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> col <span class="kw">in</span> numeric_cols_to_zero:</span>
<span id="cb114-2157"><a href="#cb114-2157" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb114-2158"><a href="#cb114-2158" aria-hidden="true" tabindex="-1"></a>                df.loc[zero_floor_mask, col] <span class="op">=</span> df.loc[zero_floor_mask, col].fillna(<span class="dv">0</span>)</span>
<span id="cb114-2159"><a href="#cb114-2159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2160"><a href="#cb114-2160" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Fill categorical/boolean columns</span></span>
<span id="cb114-2161"><a href="#cb114-2161" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> col, fill_val <span class="kw">in</span> categorical_cols_to_fill.items():</span>
<span id="cb114-2162"><a href="#cb114-2162" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb114-2163"><a href="#cb114-2163" aria-hidden="true" tabindex="-1"></a>                df.loc[zero_floor_mask, col] <span class="op">=</span> df.loc[zero_floor_mask, col].fillna(fill_val)</span>
<span id="cb114-2164"><a href="#cb114-2164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2165"><a href="#cb114-2165" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Filled structure-dependent missing values in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss"> for </span><span class="sc">{</span>zero_floor_mask<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ss"> rows"</span>)</span>
<span id="cb114-2166"><a href="#cb114-2166" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb114-2167"><a href="#cb114-2167" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" 'floor_area_total_2019' not found in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-2168"><a href="#cb114-2168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2169"><a href="#cb114-2169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2170"><a href="#cb114-2170" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-2171"><a href="#cb114-2171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2174"><a href="#cb114-2174" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-2175"><a href="#cb114-2175" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb114-2176"><a href="#cb114-2176" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb114-2177"><a href="#cb114-2177" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> OrdinalEncoder</span>
<span id="cb114-2178"><a href="#cb114-2178" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> KFold</span>
<span id="cb114-2179"><a href="#cb114-2179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2180"><a href="#cb114-2180" aria-hidden="true" tabindex="-1"></a><span class="co"># Clear specific variables</span></span>
<span id="cb114-2181"><a href="#cb114-2181" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> var <span class="kw">in</span> [<span class="st">'ordinal_cols_all'</span>, <span class="st">'bool_cols_all'</span>]:</span>
<span id="cb114-2182"><a href="#cb114-2182" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> var <span class="kw">in</span> <span class="bu">locals</span>():</span>
<span id="cb114-2183"><a href="#cb114-2183" aria-hidden="true" tabindex="-1"></a>        <span class="kw">del</span> <span class="bu">globals</span>()[var]</span>
<span id="cb114-2184"><a href="#cb114-2184" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2185"><a href="#cb114-2185" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 1: Boolean Encoding (2015‚Äì2019 only) ===</span></span>
<span id="cb114-2186"><a href="#cb114-2186" aria-hidden="true" tabindex="-1"></a>bool_bases <span class="op">=</span> [<span class="st">'has_cooling'</span>, <span class="st">'has_heat'</span>, <span class="st">'protested'</span>]</span>
<span id="cb114-2187"><a href="#cb114-2187" aria-hidden="true" tabindex="-1"></a>bool_cols_all <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> base <span class="kw">in</span> bool_bases <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)]</span>
<span id="cb114-2188"><a href="#cb114-2188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2189"><a href="#cb114-2189" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> bool_cols_all:</span>
<span id="cb114-2190"><a href="#cb114-2190" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-2191"><a href="#cb114-2191" aria-hidden="true" tabindex="-1"></a>        mode_val <span class="op">=</span> train_merged[col].mode(dropna<span class="op">=</span><span class="va">True</span>)[<span class="dv">0</span>]</span>
<span id="cb114-2192"><a href="#cb114-2192" aria-hidden="true" tabindex="-1"></a>        train_merged[col] <span class="op">=</span> train_merged[col].fillna(mode_val).astype(<span class="bu">int</span>)</span>
<span id="cb114-2193"><a href="#cb114-2193" aria-hidden="true" tabindex="-1"></a>        test_merged[col] <span class="op">=</span> test_merged[col].fillna(mode_val).astype(<span class="bu">int</span>)</span>
<span id="cb114-2194"><a href="#cb114-2194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2195"><a href="#cb114-2195" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 2: Ordinal Cleaning and Encoding (2015‚Äì2019 only) ===</span></span>
<span id="cb114-2196"><a href="#cb114-2196" aria-hidden="true" tabindex="-1"></a>ordinal_bases <span class="op">=</span> [</span>
<span id="cb114-2197"><a href="#cb114-2197" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality'</span>, <span class="st">'quality_description'</span>, <span class="st">'grade'</span>,</span>
<span id="cb114-2198"><a href="#cb114-2198" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_condition'</span>, <span class="st">'physical_condition'</span></span>
<span id="cb114-2199"><a href="#cb114-2199" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb114-2200"><a href="#cb114-2200" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2201"><a href="#cb114-2201" aria-hidden="true" tabindex="-1"></a>ordinal_cols_all <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> base <span class="kw">in</span> ordinal_bases <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)]</span>
<span id="cb114-2202"><a href="#cb114-2202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2203"><a href="#cb114-2203" aria-hidden="true" tabindex="-1"></a><span class="co"># Column-specific replacements</span></span>
<span id="cb114-2204"><a href="#cb114-2204" aria-hidden="true" tabindex="-1"></a>replacement_maps <span class="op">=</span> {</span>
<span id="cb114-2205"><a href="#cb114-2205" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality'</span>: {<span class="st">'E'</span>: <span class="st">'D'</span>, <span class="st">'F'</span>: <span class="st">'D'</span>, <span class="st">'X'</span>: np.nan, <span class="st">'None'</span>: np.nan},</span>
<span id="cb114-2206"><a href="#cb114-2206" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality_description'</span>: {<span class="st">'Poor'</span>: <span class="st">'Very Low'</span>, <span class="st">'None'</span>: np.nan},</span>
<span id="cb114-2207"><a href="#cb114-2207" aria-hidden="true" tabindex="-1"></a>    <span class="st">'grade'</span>: {<span class="st">'X'</span>: <span class="st">'F'</span>, <span class="st">'X-'</span>: <span class="st">'F'</span>, <span class="st">'X+'</span>: <span class="st">'F'</span>, <span class="st">'E'</span>: <span class="st">'D'</span>, <span class="st">'E-'</span>: <span class="st">'D-'</span>, <span class="st">'E+'</span>: <span class="st">'D+'</span>, <span class="st">'None'</span>: np.nan},</span>
<span id="cb114-2208"><a href="#cb114-2208" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_condition'</span>: {<span class="st">'Very Poor'</span>: <span class="st">'Poor'</span>, <span class="st">'Unsound'</span>: <span class="st">'Poor'</span>, <span class="st">'None'</span>: np.nan},</span>
<span id="cb114-2209"><a href="#cb114-2209" aria-hidden="true" tabindex="-1"></a>    <span class="st">'physical_condition'</span>: {<span class="st">'Very Poor'</span>: <span class="st">'Poor'</span>, <span class="st">'Unsound'</span>: <span class="st">'Poor'</span>, <span class="st">'None'</span>: np.nan}</span>
<span id="cb114-2210"><a href="#cb114-2210" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb114-2211"><a href="#cb114-2211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2212"><a href="#cb114-2212" aria-hidden="true" tabindex="-1"></a><span class="co"># Ordinal category order</span></span>
<span id="cb114-2213"><a href="#cb114-2213" aria-hidden="true" tabindex="-1"></a>ord_categories <span class="op">=</span> {</span>
<span id="cb114-2214"><a href="#cb114-2214" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality'</span>: [<span class="st">'D'</span>, <span class="st">'C'</span>, <span class="st">'B'</span>, <span class="st">'A'</span>],</span>
<span id="cb114-2215"><a href="#cb114-2215" aria-hidden="true" tabindex="-1"></a>    <span class="st">'quality_description'</span>: [<span class="st">'Very Low'</span>, <span class="st">'Low'</span>, <span class="st">'Average'</span>, <span class="st">'Good'</span>, <span class="st">'Excellent'</span>, <span class="st">'Superior'</span>],</span>
<span id="cb114-2216"><a href="#cb114-2216" aria-hidden="true" tabindex="-1"></a>    <span class="st">'grade'</span>: [<span class="st">'F'</span>, <span class="st">'D-'</span>, <span class="st">'D'</span>, <span class="st">'D+'</span>, <span class="st">'C-'</span>, <span class="st">'C'</span>, <span class="st">'C+'</span>, <span class="st">'B-'</span>, <span class="st">'B'</span>, <span class="st">'B+'</span>, <span class="st">'A-'</span>, <span class="st">'A'</span>, <span class="st">'A+'</span>],</span>
<span id="cb114-2217"><a href="#cb114-2217" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_condition'</span>: [<span class="st">'Poor'</span>, <span class="st">'Fair'</span>, <span class="st">'Average'</span>, <span class="st">'Good'</span>, <span class="st">'Very Good'</span>, <span class="st">'Excellent'</span>],</span>
<span id="cb114-2218"><a href="#cb114-2218" aria-hidden="true" tabindex="-1"></a>    <span class="st">'physical_condition'</span>: [<span class="st">'Poor'</span>, <span class="st">'Fair'</span>, <span class="st">'Average'</span>, <span class="st">'Good'</span>, <span class="st">'Very Good'</span>, <span class="st">'Excellent'</span>]</span>
<span id="cb114-2219"><a href="#cb114-2219" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb114-2220"><a href="#cb114-2220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2221"><a href="#cb114-2221" aria-hidden="true" tabindex="-1"></a><span class="co"># Clean and encode</span></span>
<span id="cb114-2222"><a href="#cb114-2222" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> base <span class="kw">in</span> ordinal_bases:</span>
<span id="cb114-2223"><a href="#cb114-2223" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>):</span>
<span id="cb114-2224"><a href="#cb114-2224" aria-hidden="true" tabindex="-1"></a>        col <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb114-2225"><a href="#cb114-2225" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-2226"><a href="#cb114-2226" aria-hidden="true" tabindex="-1"></a>            replacements <span class="op">=</span> replacement_maps.get(base, {})</span>
<span id="cb114-2227"><a href="#cb114-2227" aria-hidden="true" tabindex="-1"></a>            train_merged[col] <span class="op">=</span> train_merged[col].replace(replacements)</span>
<span id="cb114-2228"><a href="#cb114-2228" aria-hidden="true" tabindex="-1"></a>            test_merged[col] <span class="op">=</span> test_merged[col].replace(replacements)</span>
<span id="cb114-2229"><a href="#cb114-2229" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2230"><a href="#cb114-2230" aria-hidden="true" tabindex="-1"></a>            mode_val <span class="op">=</span> train_merged[col].mode(dropna<span class="op">=</span><span class="va">True</span>)[<span class="dv">0</span>]</span>
<span id="cb114-2231"><a href="#cb114-2231" aria-hidden="true" tabindex="-1"></a>            train_merged[col] <span class="op">=</span> train_merged[col].fillna(mode_val)</span>
<span id="cb114-2232"><a href="#cb114-2232" aria-hidden="true" tabindex="-1"></a>            test_merged[col] <span class="op">=</span> test_merged[col].fillna(mode_val)</span>
<span id="cb114-2233"><a href="#cb114-2233" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2234"><a href="#cb114-2234" aria-hidden="true" tabindex="-1"></a>            encoder <span class="op">=</span> OrdinalEncoder(categories<span class="op">=</span>[ord_categories[base]], handle_unknown<span class="op">=</span><span class="st">'use_encoded_value'</span>, unknown_value<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb114-2235"><a href="#cb114-2235" aria-hidden="true" tabindex="-1"></a>            train_merged[[col]] <span class="op">=</span> encoder.fit_transform(train_merged[[col]])</span>
<span id="cb114-2236"><a href="#cb114-2236" aria-hidden="true" tabindex="-1"></a>            test_merged[[col]] <span class="op">=</span> encoder.transform(test_merged[[col]])</span>
<span id="cb114-2237"><a href="#cb114-2237" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2238"><a href="#cb114-2238" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2239"><a href="#cb114-2239" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-2240"><a href="#cb114-2240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2243"><a href="#cb114-2243" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-2244"><a href="#cb114-2244" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 3: Target Encoding (2015‚Äì2019 only) ===</span></span>
<span id="cb114-2245"><a href="#cb114-2245" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> group_and_target_encode_cv(train_df, test_df, target_name, column, rare_threshold<span class="op">=</span><span class="fl">0.001</span>, smoothing<span class="op">=</span><span class="dv">10</span>, n_splits<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb114-2246"><a href="#cb114-2246" aria-hidden="true" tabindex="-1"></a>    freq <span class="op">=</span> train_df[column].value_counts(normalize<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-2247"><a href="#cb114-2247" aria-hidden="true" tabindex="-1"></a>    rare_cats <span class="op">=</span> freq[freq <span class="op">&lt;</span> rare_threshold].index</span>
<span id="cb114-2248"><a href="#cb114-2248" aria-hidden="true" tabindex="-1"></a>    train_df[column] <span class="op">=</span> train_df[column].replace(rare_cats, <span class="st">'Other'</span>)</span>
<span id="cb114-2249"><a href="#cb114-2249" aria-hidden="true" tabindex="-1"></a>    test_df[column] <span class="op">=</span> test_df[column].replace(rare_cats, <span class="st">'Other'</span>)</span>
<span id="cb114-2250"><a href="#cb114-2250" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2251"><a href="#cb114-2251" aria-hidden="true" tabindex="-1"></a>    global_mean <span class="op">=</span> train_df[target_name].mean()</span>
<span id="cb114-2252"><a href="#cb114-2252" aria-hidden="true" tabindex="-1"></a>    oof_encoded <span class="op">=</span> pd.Series(index<span class="op">=</span>train_df.index, dtype<span class="op">=</span><span class="st">'float64'</span>)</span>
<span id="cb114-2253"><a href="#cb114-2253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2254"><a href="#cb114-2254" aria-hidden="true" tabindex="-1"></a>    kf <span class="op">=</span> KFold(n_splits<span class="op">=</span>n_splits, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb114-2255"><a href="#cb114-2255" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> train_idx, val_idx <span class="kw">in</span> kf.split(train_df):</span>
<span id="cb114-2256"><a href="#cb114-2256" aria-hidden="true" tabindex="-1"></a>        X_tr, X_val <span class="op">=</span> train_df.iloc[train_idx], train_df.iloc[val_idx]</span>
<span id="cb114-2257"><a href="#cb114-2257" aria-hidden="true" tabindex="-1"></a>        stats <span class="op">=</span> X_tr.groupby(column)[target_name].agg([<span class="st">'mean'</span>, <span class="st">'count'</span>])</span>
<span id="cb114-2258"><a href="#cb114-2258" aria-hidden="true" tabindex="-1"></a>        smooth <span class="op">=</span> (stats[<span class="st">'mean'</span>] <span class="op">*</span> stats[<span class="st">'count'</span>] <span class="op">+</span> global_mean <span class="op">*</span> smoothing) <span class="op">/</span> (stats[<span class="st">'count'</span>] <span class="op">+</span> smoothing)</span>
<span id="cb114-2259"><a href="#cb114-2259" aria-hidden="true" tabindex="-1"></a>        oof_encoded.iloc[val_idx] <span class="op">=</span> X_val[column].<span class="bu">map</span>(smooth).fillna(global_mean)</span>
<span id="cb114-2260"><a href="#cb114-2260" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2261"><a href="#cb114-2261" aria-hidden="true" tabindex="-1"></a>    final_stats <span class="op">=</span> train_df.groupby(column)[target_name].agg([<span class="st">'mean'</span>, <span class="st">'count'</span>])</span>
<span id="cb114-2262"><a href="#cb114-2262" aria-hidden="true" tabindex="-1"></a>    final_smooth <span class="op">=</span> (final_stats[<span class="st">'mean'</span>] <span class="op">*</span> final_stats[<span class="st">'count'</span>] <span class="op">+</span> global_mean <span class="op">*</span> smoothing) <span class="op">/</span> (final_stats[<span class="st">'count'</span>] <span class="op">+</span> smoothing)</span>
<span id="cb114-2263"><a href="#cb114-2263" aria-hidden="true" tabindex="-1"></a>    test_encoded <span class="op">=</span> test_df[column].<span class="bu">map</span>(final_smooth).fillna(global_mean)</span>
<span id="cb114-2264"><a href="#cb114-2264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2265"><a href="#cb114-2265" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> oof_encoded, test_encoded</span>
<span id="cb114-2266"><a href="#cb114-2266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2267"><a href="#cb114-2267" aria-hidden="true" tabindex="-1"></a><span class="co"># Target-encodable nominal columns</span></span>
<span id="cb114-2268"><a href="#cb114-2268" aria-hidden="true" tabindex="-1"></a>target_encodable_bases <span class="op">=</span> [<span class="st">'foundation_type'</span>, <span class="st">'exterior_walls'</span>]</span>
<span id="cb114-2269"><a href="#cb114-2269" aria-hidden="true" tabindex="-1"></a>target_encodable_cols_all <span class="op">=</span> [<span class="ss">f"</span><span class="sc">{</span>base<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> base <span class="kw">in</span> target_encodable_bases <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)]</span>
<span id="cb114-2270"><a href="#cb114-2270" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2271"><a href="#cb114-2271" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply target encoding</span></span>
<span id="cb114-2272"><a href="#cb114-2272" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> target_encodable_cols_all:</span>
<span id="cb114-2273"><a href="#cb114-2273" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-2274"><a href="#cb114-2274" aria-hidden="true" tabindex="-1"></a>        mode_val <span class="op">=</span> train_merged[col].mode(dropna<span class="op">=</span><span class="va">True</span>)[<span class="dv">0</span>]</span>
<span id="cb114-2275"><a href="#cb114-2275" aria-hidden="true" tabindex="-1"></a>        train_merged[col] <span class="op">=</span> train_merged[col].fillna(mode_val)</span>
<span id="cb114-2276"><a href="#cb114-2276" aria-hidden="true" tabindex="-1"></a>        test_merged[col] <span class="op">=</span> test_merged[col].fillna(mode_val)</span>
<span id="cb114-2277"><a href="#cb114-2277" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2278"><a href="#cb114-2278" aria-hidden="true" tabindex="-1"></a>        train_merged[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_te'</span>], test_merged[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_te'</span>] <span class="op">=</span> group_and_target_encode_cv(</span>
<span id="cb114-2279"><a href="#cb114-2279" aria-hidden="true" tabindex="-1"></a>            train_merged, test_merged, target_name<span class="op">=</span><span class="st">'assessed_2018'</span>, column<span class="op">=</span>col,</span>
<span id="cb114-2280"><a href="#cb114-2280" aria-hidden="true" tabindex="-1"></a>            rare_threshold<span class="op">=</span><span class="fl">0.001</span>, smoothing<span class="op">=</span><span class="dv">10</span>, n_splits<span class="op">=</span><span class="dv">5</span></span>
<span id="cb114-2281"><a href="#cb114-2281" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb114-2282"><a href="#cb114-2282" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2283"><a href="#cb114-2283" aria-hidden="true" tabindex="-1"></a>        train_merged.drop(columns<span class="op">=</span>[col], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-2284"><a href="#cb114-2284" aria-hidden="true" tabindex="-1"></a>        test_merged.drop(columns<span class="op">=</span>[col], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-2285"><a href="#cb114-2285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2286"><a href="#cb114-2286" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Done: Boolean, Ordinal, and Target Encoding for 2015‚Äì2019 features only."</span>)</span>
<span id="cb114-2287"><a href="#cb114-2287" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-2288"><a href="#cb114-2288" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2291"><a href="#cb114-2291" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-2292"><a href="#cb114-2292" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1: Get growth columns from training set</span></span>
<span id="cb114-2293"><a href="#cb114-2293" aria-hidden="true" tabindex="-1"></a>growth_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> train_merged.columns <span class="cf">if</span> <span class="st">'_growth'</span> <span class="kw">in</span> col]</span>
<span id="cb114-2294"><a href="#cb114-2294" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2295"><a href="#cb114-2295" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 2: Compute medians from train_merged only</span></span>
<span id="cb114-2296"><a href="#cb114-2296" aria-hidden="true" tabindex="-1"></a>growth_medians <span class="op">=</span> {col: train_merged[col].median() <span class="cf">for</span> col <span class="kw">in</span> growth_cols}</span>
<span id="cb114-2297"><a href="#cb114-2297" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2298"><a href="#cb114-2298" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 3: Apply to both train and test</span></span>
<span id="cb114-2299"><a href="#cb114-2299" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb114-2300"><a href="#cb114-2300" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> col <span class="kw">in</span> growth_cols:</span>
<span id="cb114-2301"><a href="#cb114-2301" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb114-2302"><a href="#cb114-2302" aria-hidden="true" tabindex="-1"></a>            df[<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_missing'</span>] <span class="op">=</span> df[col].isna().astype(<span class="bu">int</span>)</span>
<span id="cb114-2303"><a href="#cb114-2303" aria-hidden="true" tabindex="-1"></a>            df[col].fillna(growth_medians[col], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-2304"><a href="#cb114-2304" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Filled and flagged missing values in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss"> for: </span><span class="sc">{</span>growth_cols<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-2305"><a href="#cb114-2305" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2306"><a href="#cb114-2306" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-2307"><a href="#cb114-2307" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2310"><a href="#cb114-2310" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-2311"><a href="#cb114-2311" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 1: List your growth features ===</span></span>
<span id="cb114-2312"><a href="#cb114-2312" aria-hidden="true" tabindex="-1"></a>growth_features <span class="op">=</span> [<span class="st">'land_value_growth'</span>, <span class="st">'building_value_growth'</span>, <span class="st">'assessed_growth'</span>]</span>
<span id="cb114-2313"><a href="#cb114-2313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2314"><a href="#cb114-2314" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 2: Binning Function (train-based binning) ===</span></span>
<span id="cb114-2315"><a href="#cb114-2315" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bin_growth_feature_safe(train_df, test_df, feature, bins<span class="op">=</span><span class="dv">4</span>):</span>
<span id="cb114-2316"><a href="#cb114-2316" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb114-2317"><a href="#cb114-2317" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Quantile binning on train only</span></span>
<span id="cb114-2318"><a href="#cb114-2318" aria-hidden="true" tabindex="-1"></a>        train_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>], bin_edges <span class="op">=</span> pd.qcut(train_df[feature], q<span class="op">=</span>bins, labels<span class="op">=</span><span class="va">False</span>, retbins<span class="op">=</span><span class="va">True</span>, duplicates<span class="op">=</span><span class="st">'drop'</span>)</span>
<span id="cb114-2319"><a href="#cb114-2319" aria-hidden="true" tabindex="-1"></a>        test_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>] <span class="op">=</span> pd.cut(test_df[feature], bins<span class="op">=</span>bin_edges, labels<span class="op">=</span><span class="va">False</span>, include_lowest<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-2320"><a href="#cb114-2320" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">ValueError</span>:</span>
<span id="cb114-2321"><a href="#cb114-2321" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Fallback: Equal-width binning</span></span>
<span id="cb114-2322"><a href="#cb114-2322" aria-hidden="true" tabindex="-1"></a>        min_val <span class="op">=</span> train_df[feature].<span class="bu">min</span>()</span>
<span id="cb114-2323"><a href="#cb114-2323" aria-hidden="true" tabindex="-1"></a>        max_val <span class="op">=</span> train_df[feature].<span class="bu">max</span>()</span>
<span id="cb114-2324"><a href="#cb114-2324" aria-hidden="true" tabindex="-1"></a>        bin_edges <span class="op">=</span> np.linspace(min_val, max_val, bins <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb114-2325"><a href="#cb114-2325" aria-hidden="true" tabindex="-1"></a>        train_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>] <span class="op">=</span> pd.cut(train_df[feature], bins<span class="op">=</span>bin_edges, labels<span class="op">=</span><span class="va">False</span>, include_lowest<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-2326"><a href="#cb114-2326" aria-hidden="true" tabindex="-1"></a>        test_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>] <span class="op">=</span> pd.cut(test_df[feature], bins<span class="op">=</span>bin_edges, labels<span class="op">=</span><span class="va">False</span>, include_lowest<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-2327"><a href="#cb114-2327" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2328"><a href="#cb114-2328" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert to category</span></span>
<span id="cb114-2329"><a href="#cb114-2329" aria-hidden="true" tabindex="-1"></a>    train_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>] <span class="op">=</span> train_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>].astype(<span class="st">'category'</span>)</span>
<span id="cb114-2330"><a href="#cb114-2330" aria-hidden="true" tabindex="-1"></a>    test_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>] <span class="op">=</span> test_df[<span class="ss">f'</span><span class="sc">{</span>feature<span class="sc">}</span><span class="ss">_bin'</span>].astype(<span class="st">'category'</span>)</span>
<span id="cb114-2331"><a href="#cb114-2331" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> train_df, test_df</span>
<span id="cb114-2332"><a href="#cb114-2332" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2333"><a href="#cb114-2333" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 3: Apply to train_merged and test_merged ===</span></span>
<span id="cb114-2334"><a href="#cb114-2334" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> feature <span class="kw">in</span> growth_features:</span>
<span id="cb114-2335"><a href="#cb114-2335" aria-hidden="true" tabindex="-1"></a>    train_merged, test_merged <span class="op">=</span> bin_growth_feature_safe(train_merged, test_merged, feature)</span>
<span id="cb114-2336"><a href="#cb114-2336" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2337"><a href="#cb114-2337" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 4: Bin year_built_final using train-based quantiles ===</span></span>
<span id="cb114-2338"><a href="#cb114-2338" aria-hidden="true" tabindex="-1"></a>train_merged[<span class="st">'year_built_bin'</span>], bin_edges <span class="op">=</span> pd.qcut(</span>
<span id="cb114-2339"><a href="#cb114-2339" aria-hidden="true" tabindex="-1"></a>    train_merged[<span class="st">'year_built_final'</span>], q<span class="op">=</span><span class="dv">5</span>, retbins<span class="op">=</span><span class="va">True</span>, labels<span class="op">=</span><span class="va">False</span>, duplicates<span class="op">=</span><span class="st">'drop'</span></span>
<span id="cb114-2340"><a href="#cb114-2340" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb114-2341"><a href="#cb114-2341" aria-hidden="true" tabindex="-1"></a>test_merged[<span class="st">'year_built_bin'</span>] <span class="op">=</span> pd.cut(</span>
<span id="cb114-2342"><a href="#cb114-2342" aria-hidden="true" tabindex="-1"></a>    test_merged[<span class="st">'year_built_final'</span>], bins<span class="op">=</span>bin_edges, labels<span class="op">=</span><span class="va">False</span>, include_lowest<span class="op">=</span><span class="va">True</span></span>
<span id="cb114-2343"><a href="#cb114-2343" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb114-2344"><a href="#cb114-2344" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2345"><a href="#cb114-2345" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert to category</span></span>
<span id="cb114-2346"><a href="#cb114-2346" aria-hidden="true" tabindex="-1"></a>train_merged[<span class="st">'year_built_bin'</span>] <span class="op">=</span> train_merged[<span class="st">'year_built_bin'</span>].astype(<span class="st">'category'</span>)</span>
<span id="cb114-2347"><a href="#cb114-2347" aria-hidden="true" tabindex="-1"></a>test_merged[<span class="st">'year_built_bin'</span>] <span class="op">=</span> test_merged[<span class="st">'year_built_bin'</span>].astype(<span class="st">'category'</span>)</span>
<span id="cb114-2348"><a href="#cb114-2348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2349"><a href="#cb114-2349" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2350"><a href="#cb114-2350" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Binned growth &amp; year_built features safely with no leakage."</span>)</span>
<span id="cb114-2351"><a href="#cb114-2351" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2352"><a href="#cb114-2352" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2353"><a href="#cb114-2353" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-2354"><a href="#cb114-2354" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2357"><a href="#cb114-2357" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-2358"><a href="#cb114-2358" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 5: Drop original continuous columns ===</span></span>
<span id="cb114-2359"><a href="#cb114-2359" aria-hidden="true" tabindex="-1"></a>cols_to_drop <span class="op">=</span> growth_features <span class="op">+</span> [<span class="st">'year_built_final'</span>]</span>
<span id="cb114-2360"><a href="#cb114-2360" aria-hidden="true" tabindex="-1"></a>train_merged<span class="op">=</span>train_merged.drop(columns<span class="op">=</span>cols_to_drop)</span>
<span id="cb114-2361"><a href="#cb114-2361" aria-hidden="true" tabindex="-1"></a>test_merged<span class="op">=</span>test_merged.drop(columns<span class="op">=</span>cols_to_drop)</span>
<span id="cb114-2362"><a href="#cb114-2362" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-2363"><a href="#cb114-2363" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2366"><a href="#cb114-2366" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-2367"><a href="#cb114-2367" aria-hidden="true" tabindex="-1"></a>rare_threshold <span class="op">=</span> <span class="fl">0.001</span>  <span class="co"># 0.1%</span></span>
<span id="cb114-2368"><a href="#cb114-2368" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2369"><a href="#cb114-2369" aria-hidden="true" tabindex="-1"></a>cat_cols <span class="op">=</span> [</span>
<span id="cb114-2370"><a href="#cb114-2370" aria-hidden="true" tabindex="-1"></a>    <span class="st">"quality_description_final"</span>,</span>
<span id="cb114-2371"><a href="#cb114-2371" aria-hidden="true" tabindex="-1"></a>    <span class="st">"foundation_type_final_te"</span>,</span>
<span id="cb114-2372"><a href="#cb114-2372" aria-hidden="true" tabindex="-1"></a>    <span class="st">"physical_condition_final"</span>,</span>
<span id="cb114-2373"><a href="#cb114-2373" aria-hidden="true" tabindex="-1"></a>    <span class="st">"exterior_walls_final_te"</span>,</span>
<span id="cb114-2374"><a href="#cb114-2374" aria-hidden="true" tabindex="-1"></a>    <span class="st">"region_freq"</span>,</span>
<span id="cb114-2375"><a href="#cb114-2375" aria-hidden="true" tabindex="-1"></a>    <span class="st">"neighborhood_freq"</span></span>
<span id="cb114-2376"><a href="#cb114-2376" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb114-2377"><a href="#cb114-2377" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2378"><a href="#cb114-2378" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> cat_cols:</span>
<span id="cb114-2379"><a href="#cb114-2379" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-2380"><a href="#cb114-2380" aria-hidden="true" tabindex="-1"></a>        freq <span class="op">=</span> train_merged[col].value_counts(normalize<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-2381"><a href="#cb114-2381" aria-hidden="true" tabindex="-1"></a>        rare <span class="op">=</span> freq[freq <span class="op">&lt;</span> rare_threshold]</span>
<span id="cb114-2382"><a href="#cb114-2382" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> rare.empty:</span>
<span id="cb114-2383"><a href="#cb114-2383" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss"> Rare categories in '</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">' (less than 0.1% of training data):</span><span class="ch">\n</span><span class="sc">{</span>rare<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-2384"><a href="#cb114-2384" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb114-2385"><a href="#cb114-2385" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Column '</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">' not found in train_merged"</span>)</span>
<span id="cb114-2386"><a href="#cb114-2386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2387"><a href="#cb114-2387" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2388"><a href="#cb114-2388" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2389"><a href="#cb114-2389" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-2390"><a href="#cb114-2390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2393"><a href="#cb114-2393" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-2394"><a href="#cb114-2394" aria-hidden="true" tabindex="-1"></a><span class="co"># Define frequency columns and threshold</span></span>
<span id="cb114-2395"><a href="#cb114-2395" aria-hidden="true" tabindex="-1"></a>freq_cols <span class="op">=</span> [<span class="st">'region_freq'</span>, <span class="st">'neighborhood_freq'</span>, <span class="st">'zone_freq'</span>, <span class="st">'subneighborhood_freq'</span>]</span>
<span id="cb114-2396"><a href="#cb114-2396" aria-hidden="true" tabindex="-1"></a>rare_thresh <span class="op">=</span> <span class="fl">0.001</span></span>
<span id="cb114-2397"><a href="#cb114-2397" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2398"><a href="#cb114-2398" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply rare value replacement for each frequency column</span></span>
<span id="cb114-2399"><a href="#cb114-2399" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> freq_cols:</span>
<span id="cb114-2400"><a href="#cb114-2400" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-2401"><a href="#cb114-2401" aria-hidden="true" tabindex="-1"></a>        rare_vals <span class="op">=</span> train_merged[col].value_counts(normalize<span class="op">=</span><span class="va">True</span>)[<span class="kw">lambda</span> x: x <span class="op">&lt;</span> rare_thresh].index</span>
<span id="cb114-2402"><a href="#cb114-2402" aria-hidden="true" tabindex="-1"></a>        train_merged[col] <span class="op">=</span> train_merged[col].replace(rare_vals, <span class="dv">0</span>)</span>
<span id="cb114-2403"><a href="#cb114-2403" aria-hidden="true" tabindex="-1"></a>        test_merged[col] <span class="op">=</span> test_merged[col].replace(rare_vals, <span class="dv">0</span>)</span>
<span id="cb114-2404"><a href="#cb114-2404" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Replaced rare values in </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> using train_merged threshold &lt; </span><span class="sc">{</span>rare_thresh<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-2405"><a href="#cb114-2405" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb114-2406"><a href="#cb114-2406" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Column </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss"> not found in train_merged ‚Äî skipping."</span>)</span>
<span id="cb114-2407"><a href="#cb114-2407" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2408"><a href="#cb114-2408" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2409"><a href="#cb114-2409" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-2410"><a href="#cb114-2410" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2413"><a href="#cb114-2413" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-2414"><a href="#cb114-2414" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb114-2415"><a href="#cb114-2415" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2416"><a href="#cb114-2416" aria-hidden="true" tabindex="-1"></a><span class="co"># === Compute skewness for numeric columns ===</span></span>
<span id="cb114-2417"><a href="#cb114-2417" aria-hidden="true" tabindex="-1"></a>numeric_cols <span class="op">=</span> train_merged.select_dtypes(include<span class="op">=</span>[np.number])</span>
<span id="cb114-2418"><a href="#cb114-2418" aria-hidden="true" tabindex="-1"></a>skew_values <span class="op">=</span> numeric_cols.skew().sort_values(ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb114-2419"><a href="#cb114-2419" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2420"><a href="#cb114-2420" aria-hidden="true" tabindex="-1"></a><span class="co"># === Save skewness to CSV ===</span></span>
<span id="cb114-2421"><a href="#cb114-2421" aria-hidden="true" tabindex="-1"></a>skew_df <span class="op">=</span> skew_values.reset_index()</span>
<span id="cb114-2422"><a href="#cb114-2422" aria-hidden="true" tabindex="-1"></a>skew_df.columns <span class="op">=</span> [<span class="st">'feature'</span>, <span class="st">'skewness'</span>]</span>
<span id="cb114-2423"><a href="#cb114-2423" aria-hidden="true" tabindex="-1"></a>skew_df.to_csv(<span class="st">"feature_skewness.csv"</span>, index<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb114-2424"><a href="#cb114-2424" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2425"><a href="#cb114-2425" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Saved skewness stats to 'feature_skewness.csv'"</span>)</span>
<span id="cb114-2426"><a href="#cb114-2426" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2427"><a href="#cb114-2427" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-2428"><a href="#cb114-2428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2431"><a href="#cb114-2431" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-2432"><a href="#cb114-2432" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb114-2433"><a href="#cb114-2433" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2434"><a href="#cb114-2434" aria-hidden="true" tabindex="-1"></a><span class="co"># Load your skewness report</span></span>
<span id="cb114-2435"><a href="#cb114-2435" aria-hidden="true" tabindex="-1"></a>skew_df <span class="op">=</span> pd.read_csv(<span class="st">"feature_skewness.csv"</span>)  <span class="co"># Update path if needed</span></span>
<span id="cb114-2436"><a href="#cb114-2436" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2437"><a href="#cb114-2437" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 1: Categorize features by skew level ===</span></span>
<span id="cb114-2438"><a href="#cb114-2438" aria-hidden="true" tabindex="-1"></a>ultra_skewed <span class="op">=</span> []</span>
<span id="cb114-2439"><a href="#cb114-2439" aria-hidden="true" tabindex="-1"></a>moderately_skewed <span class="op">=</span> []</span>
<span id="cb114-2440"><a href="#cb114-2440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2441"><a href="#cb114-2441" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _, row <span class="kw">in</span> skew_df.iterrows():</span>
<span id="cb114-2442"><a href="#cb114-2442" aria-hidden="true" tabindex="-1"></a>    feature <span class="op">=</span> row[<span class="st">'feature'</span>]</span>
<span id="cb114-2443"><a href="#cb114-2443" aria-hidden="true" tabindex="-1"></a>    skew <span class="op">=</span> row[<span class="st">'skewness'</span>]</span>
<span id="cb114-2444"><a href="#cb114-2444" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb114-2445"><a href="#cb114-2445" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> feature <span class="kw">not</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-2446"><a href="#cb114-2446" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span></span>
<span id="cb114-2447"><a href="#cb114-2447" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2448"><a href="#cb114-2448" aria-hidden="true" tabindex="-1"></a>    unique_vals <span class="op">=</span> train_merged[feature].nunique()</span>
<span id="cb114-2449"><a href="#cb114-2449" aria-hidden="true" tabindex="-1"></a>    is_binary <span class="op">=</span> <span class="bu">set</span>(train_merged[feature].dropna().unique()).issubset({<span class="dv">0</span>, <span class="dv">1</span>})</span>
<span id="cb114-2450"><a href="#cb114-2450" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2451"><a href="#cb114-2451" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> unique_vals <span class="op">&gt;</span> <span class="dv">10</span> <span class="kw">and</span> <span class="kw">not</span> is_binary <span class="kw">and</span> <span class="kw">not</span> feature.endswith(<span class="st">'_te'</span>):</span>
<span id="cb114-2452"><a href="#cb114-2452" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> skew <span class="op">&gt;</span> <span class="dv">100</span>:</span>
<span id="cb114-2453"><a href="#cb114-2453" aria-hidden="true" tabindex="-1"></a>            ultra_skewed.append(feature)</span>
<span id="cb114-2454"><a href="#cb114-2454" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="dv">2</span><span class="op">&lt;</span> skew <span class="op">&lt;=</span> <span class="dv">100</span>:</span>
<span id="cb114-2455"><a href="#cb114-2455" aria-hidden="true" tabindex="-1"></a>            moderately_skewed.append(feature)</span>
<span id="cb114-2456"><a href="#cb114-2456" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2457"><a href="#cb114-2457" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" </span><span class="sc">{</span><span class="bu">len</span>(ultra_skewed)<span class="sc">}</span><span class="ss"> ultra-skewed features to clip at 0.995."</span>)</span>
<span id="cb114-2458"><a href="#cb114-2458" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" </span><span class="sc">{</span><span class="bu">len</span>(moderately_skewed)<span class="sc">}</span><span class="ss"> moderately-skewed features to clip at 0.999."</span>)</span>
<span id="cb114-2459"><a href="#cb114-2459" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2460"><a href="#cb114-2460" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 2: Compute quantile clipping bounds ===</span></span>
<span id="cb114-2461"><a href="#cb114-2461" aria-hidden="true" tabindex="-1"></a>clip_bounds <span class="op">=</span> {}</span>
<span id="cb114-2462"><a href="#cb114-2462" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2463"><a href="#cb114-2463" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> ultra_skewed:</span>
<span id="cb114-2464"><a href="#cb114-2464" aria-hidden="true" tabindex="-1"></a>    clip_bounds[col] <span class="op">=</span> (</span>
<span id="cb114-2465"><a href="#cb114-2465" aria-hidden="true" tabindex="-1"></a>        train_merged[col].quantile(<span class="fl">0.005</span>),</span>
<span id="cb114-2466"><a href="#cb114-2466" aria-hidden="true" tabindex="-1"></a>        train_merged[col].quantile(<span class="fl">0.995</span>)</span>
<span id="cb114-2467"><a href="#cb114-2467" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb114-2468"><a href="#cb114-2468" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2469"><a href="#cb114-2469" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> moderately_skewed:</span>
<span id="cb114-2470"><a href="#cb114-2470" aria-hidden="true" tabindex="-1"></a>    clip_bounds[col] <span class="op">=</span> (</span>
<span id="cb114-2471"><a href="#cb114-2471" aria-hidden="true" tabindex="-1"></a>        train_merged[col].quantile(<span class="fl">0.001</span>),</span>
<span id="cb114-2472"><a href="#cb114-2472" aria-hidden="true" tabindex="-1"></a>        train_merged[col].quantile(<span class="fl">0.999</span>)</span>
<span id="cb114-2473"><a href="#cb114-2473" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb114-2474"><a href="#cb114-2474" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2475"><a href="#cb114-2475" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 3: Apply clipping to both train and test ===</span></span>
<span id="cb114-2476"><a href="#cb114-2476" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb114-2477"><a href="#cb114-2477" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> col, (lower, upper) <span class="kw">in</span> clip_bounds.items():</span>
<span id="cb114-2478"><a href="#cb114-2478" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb114-2479"><a href="#cb114-2479" aria-hidden="true" tabindex="-1"></a>            df[col] <span class="op">=</span> df[col].clip(lower, upper)</span>
<span id="cb114-2480"><a href="#cb114-2480" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2481"><a href="#cb114-2481" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Adaptive clipping applied: 0.995 for ultra-skewed, 0.999 for moderately-skewed features."</span>)</span>
<span id="cb114-2482"><a href="#cb114-2482" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2483"><a href="#cb114-2483" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-2484"><a href="#cb114-2484" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2487"><a href="#cb114-2487" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-2488"><a href="#cb114-2488" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add_features(df):</span>
<span id="cb114-2489"><a href="#cb114-2489" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.copy()</span>
<span id="cb114-2490"><a href="#cb114-2490" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb114-2491"><a href="#cb114-2491" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Ratio features ===</span></span>
<span id="cb114-2492"><a href="#cb114-2492" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'area_ratio'</span>] <span class="op">=</span> df[<span class="st">'building_area_2019'</span>] <span class="op">/</span> (df[<span class="st">'land_area_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb114-2493"><a href="#cb114-2493" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'porch_ratio'</span>] <span class="op">=</span> df[<span class="st">'porch_area_2019'</span>] <span class="op">/</span> (df[<span class="st">'building_area_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb114-2494"><a href="#cb114-2494" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'floor_density'</span>] <span class="op">=</span> df[<span class="st">'floor_area_total_2019'</span>] <span class="op">/</span> (df[<span class="st">'land_area_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb114-2495"><a href="#cb114-2495" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb114-2496"><a href="#cb114-2496" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'value_ratio'</span>] <span class="op">=</span> df[<span class="st">'building_value_2018'</span>] <span class="op">/</span> (df[<span class="st">'land_value_2018'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb114-2497"><a href="#cb114-2497" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'value_per_sqft'</span>] <span class="op">=</span> df[<span class="st">'building_value_2018'</span>] <span class="op">/</span> (df[<span class="st">'building_area_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb114-2498"><a href="#cb114-2498" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'price_per_sqft'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">/</span> (df[<span class="st">'building_area_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb114-2499"><a href="#cb114-2499" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2500"><a href="#cb114-2500" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Bathroom &amp; room structure ===</span></span>
<span id="cb114-2501"><a href="#cb114-2501" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'bathroom_score'</span>] <span class="op">=</span> df[<span class="st">'full_bath_2019'</span>] <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> df[<span class="st">'half_bath_2019'</span>]</span>
<span id="cb114-2502"><a href="#cb114-2502" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'bathroom_density'</span>] <span class="op">=</span> df[<span class="st">'bathroom_score'</span>] <span class="op">/</span> (df[<span class="st">'total_rooms_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb114-2503"><a href="#cb114-2503" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'bedroom_ratio'</span>] <span class="op">=</span> df[<span class="st">'bedrooms_2019'</span>] <span class="op">/</span> (df[<span class="st">'total_rooms_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb114-2504"><a href="#cb114-2504" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'rooms_per_floor'</span>] <span class="op">=</span> df[<span class="st">'total_rooms_2019'</span>] <span class="op">/</span> (df[<span class="st">'floors_2019'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb114-2505"><a href="#cb114-2505" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2506"><a href="#cb114-2506" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Core interactions ===</span></span>
<span id="cb114-2507"><a href="#cb114-2507" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'bedrooms_x_floors'</span>] <span class="op">=</span> df[<span class="st">'bedrooms_2019'</span>] <span class="op">*</span> df[<span class="st">'floors_2019'</span>]</span>
<span id="cb114-2508"><a href="#cb114-2508" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'rooms_x_quality'</span>] <span class="op">=</span> df[<span class="st">'total_rooms_2019'</span>] <span class="op">*</span> df[<span class="st">'quality_2019'</span>]</span>
<span id="cb114-2509"><a href="#cb114-2509" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'assess_x_age'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">*</span> df[<span class="st">'building_age'</span>]</span>
<span id="cb114-2510"><a href="#cb114-2510" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'grade_quality_index'</span>] <span class="op">=</span> df[<span class="st">'grade_2019'</span>] <span class="op">*</span> df[<span class="st">'quality_2019'</span>]</span>
<span id="cb114-2511"><a href="#cb114-2511" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2512"><a href="#cb114-2512" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Selected high-signal interactions ===</span></span>
<span id="cb114-2513"><a href="#cb114-2513" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'area_x_quality'</span>] <span class="op">=</span> df[<span class="st">'building_area_2019'</span>] <span class="op">*</span> df[<span class="st">'quality_2019'</span>]</span>
<span id="cb114-2514"><a href="#cb114-2514" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'floor_area_x_grade'</span>] <span class="op">=</span> df[<span class="st">'floor_area_total_2019'</span>] <span class="op">*</span> df[<span class="st">'grade_2019'</span>]</span>
<span id="cb114-2515"><a href="#cb114-2515" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'value_to_neigh_median'</span>] <span class="op">=</span> df[<span class="st">'building_value_2018'</span>] <span class="op">/</span> (df[<span class="st">'neigh_assess_median'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb114-2516"><a href="#cb114-2516" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'assess_to_neigh_mean'</span>] <span class="op">=</span> df[<span class="st">'assessed_2018'</span>] <span class="op">/</span> (df[<span class="st">'neigh_assess_mean'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb114-2517"><a href="#cb114-2517" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'value_per_age'</span>] <span class="op">=</span> df[<span class="st">'building_value_2018'</span>] <span class="op">/</span> (df[<span class="st">'building_age'</span>] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb114-2518"><a href="#cb114-2518" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2519"><a href="#cb114-2519" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Clean up ===</span></span>
<span id="cb114-2520"><a href="#cb114-2520" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.replace([np.inf, <span class="op">-</span>np.inf], np.nan)</span>
<span id="cb114-2521"><a href="#cb114-2521" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> df.fillna(<span class="dv">0</span>)</span>
<span id="cb114-2522"><a href="#cb114-2522" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb114-2523"><a href="#cb114-2523" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb114-2524"><a href="#cb114-2524" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2525"><a href="#cb114-2525" aria-hidden="true" tabindex="-1"></a><span class="co"># === Apply to train and test sets ===</span></span>
<span id="cb114-2526"><a href="#cb114-2526" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> add_features(train_merged)</span>
<span id="cb114-2527"><a href="#cb114-2527" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> add_features(test_merged)</span>
<span id="cb114-2528"><a href="#cb114-2528" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2529"><a href="#cb114-2529" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2530"><a href="#cb114-2530" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-2531"><a href="#cb114-2531" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2534"><a href="#cb114-2534" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-2535"><a href="#cb114-2535" aria-hidden="true" tabindex="-1"></a><span class="co"># Select numeric columns only</span></span>
<span id="cb114-2536"><a href="#cb114-2536" aria-hidden="true" tabindex="-1"></a>numeric_features <span class="op">=</span> train_merged.select_dtypes(include<span class="op">=</span>[<span class="st">'int64'</span>, <span class="st">'float64'</span>])</span>
<span id="cb114-2537"><a href="#cb114-2537" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2538"><a href="#cb114-2538" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate skewness</span></span>
<span id="cb114-2539"><a href="#cb114-2539" aria-hidden="true" tabindex="-1"></a>skewness <span class="op">=</span> numeric_features.skew(numeric_only<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-2540"><a href="#cb114-2540" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2541"><a href="#cb114-2541" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter and sort features with skewness &gt; 30</span></span>
<span id="cb114-2542"><a href="#cb114-2542" aria-hidden="true" tabindex="-1"></a>highly_skewed <span class="op">=</span> skewness[skewness <span class="op">&gt;</span> <span class="dv">5</span>].sort_values(ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb114-2543"><a href="#cb114-2543" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2544"><a href="#cb114-2544" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"üìä Features with skewness &gt; 5:"</span>)</span>
<span id="cb114-2545"><a href="#cb114-2545" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(highly_skewed)</span>
<span id="cb114-2546"><a href="#cb114-2546" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-2547"><a href="#cb114-2547" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2550"><a href="#cb114-2550" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-2551"><a href="#cb114-2551" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb114-2552"><a href="#cb114-2552" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb114-2553"><a href="#cb114-2553" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2554"><a href="#cb114-2554" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 1: Drop dummy _missing columns ===</span></span>
<span id="cb114-2555"><a href="#cb114-2555" aria-hidden="true" tabindex="-1"></a>drop_cols <span class="op">=</span> [</span>
<span id="cb114-2556"><a href="#cb114-2556" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_value_growth_missing'</span>,</span>
<span id="cb114-2557"><a href="#cb114-2557" aria-hidden="true" tabindex="-1"></a>    <span class="st">'land_value_growth_missing'</span>,</span>
<span id="cb114-2558"><a href="#cb114-2558" aria-hidden="true" tabindex="-1"></a>    <span class="st">'assessed_growth_missing'</span></span>
<span id="cb114-2559"><a href="#cb114-2559" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb114-2560"><a href="#cb114-2560" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> train_merged.drop(columns<span class="op">=</span>drop_cols, errors<span class="op">=</span><span class="st">'ignore'</span>)</span>
<span id="cb114-2561"><a href="#cb114-2561" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> test_merged.drop(columns<span class="op">=</span>drop_cols, errors<span class="op">=</span><span class="st">'ignore'</span>)</span>
<span id="cb114-2562"><a href="#cb114-2562" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"üóëÔ∏è Dropped dummy _missing columns from train and test."</span>)</span>
<span id="cb114-2563"><a href="#cb114-2563" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2564"><a href="#cb114-2564" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 2: Compute skewness from train_merged only ===</span></span>
<span id="cb114-2565"><a href="#cb114-2565" aria-hidden="true" tabindex="-1"></a>numeric_cols <span class="op">=</span> train_merged.select_dtypes(include<span class="op">=</span>[np.number])</span>
<span id="cb114-2566"><a href="#cb114-2566" aria-hidden="true" tabindex="-1"></a>skew_series <span class="op">=</span> numeric_cols.skew()</span>
<span id="cb114-2567"><a href="#cb114-2567" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2568"><a href="#cb114-2568" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 3: Categorize by skew level (excluding _te and _missing) ===</span></span>
<span id="cb114-2569"><a href="#cb114-2569" aria-hidden="true" tabindex="-1"></a>ultra_skewed <span class="op">=</span> []</span>
<span id="cb114-2570"><a href="#cb114-2570" aria-hidden="true" tabindex="-1"></a>moderately_skewed <span class="op">=</span> []</span>
<span id="cb114-2571"><a href="#cb114-2571" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2572"><a href="#cb114-2572" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col, skew_val <span class="kw">in</span> skew_series.items():</span>
<span id="cb114-2573"><a href="#cb114-2573" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> col.endswith(<span class="st">'_te'</span>) <span class="kw">or</span> col.endswith(<span class="st">'_missing'</span>):</span>
<span id="cb114-2574"><a href="#cb114-2574" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span></span>
<span id="cb114-2575"><a href="#cb114-2575" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> skew_val <span class="op">&gt;</span> <span class="dv">100</span>:</span>
<span id="cb114-2576"><a href="#cb114-2576" aria-hidden="true" tabindex="-1"></a>        ultra_skewed.append(col)</span>
<span id="cb114-2577"><a href="#cb114-2577" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> skew_val <span class="op">&gt;</span> <span class="dv">2</span>:</span>
<span id="cb114-2578"><a href="#cb114-2578" aria-hidden="true" tabindex="-1"></a>        moderately_skewed.append(col)</span>
<span id="cb114-2579"><a href="#cb114-2579" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2580"><a href="#cb114-2580" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" </span><span class="sc">{</span><span class="bu">len</span>(ultra_skewed)<span class="sc">}</span><span class="ss"> ultra-skewed features (clip at 0.5%‚Äì99.5%)."</span>)</span>
<span id="cb114-2581"><a href="#cb114-2581" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" </span><span class="sc">{</span><span class="bu">len</span>(moderately_skewed)<span class="sc">}</span><span class="ss"> moderately-skewed features (clip at 0.1%‚Äì99.9%)."</span>)</span>
<span id="cb114-2582"><a href="#cb114-2582" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2583"><a href="#cb114-2583" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 4: Compute clipping bounds ===</span></span>
<span id="cb114-2584"><a href="#cb114-2584" aria-hidden="true" tabindex="-1"></a>clip_bounds <span class="op">=</span> {}</span>
<span id="cb114-2585"><a href="#cb114-2585" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2586"><a href="#cb114-2586" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> ultra_skewed:</span>
<span id="cb114-2587"><a href="#cb114-2587" aria-hidden="true" tabindex="-1"></a>    clip_bounds[col] <span class="op">=</span> (</span>
<span id="cb114-2588"><a href="#cb114-2588" aria-hidden="true" tabindex="-1"></a>        train_merged[col].quantile(<span class="fl">0.005</span>),</span>
<span id="cb114-2589"><a href="#cb114-2589" aria-hidden="true" tabindex="-1"></a>        train_merged[col].quantile(<span class="fl">0.995</span>)</span>
<span id="cb114-2590"><a href="#cb114-2590" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb114-2591"><a href="#cb114-2591" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2592"><a href="#cb114-2592" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> moderately_skewed:</span>
<span id="cb114-2593"><a href="#cb114-2593" aria-hidden="true" tabindex="-1"></a>    clip_bounds[col] <span class="op">=</span> (</span>
<span id="cb114-2594"><a href="#cb114-2594" aria-hidden="true" tabindex="-1"></a>        train_merged[col].quantile(<span class="fl">0.001</span>),</span>
<span id="cb114-2595"><a href="#cb114-2595" aria-hidden="true" tabindex="-1"></a>        train_merged[col].quantile(<span class="fl">0.999</span>)</span>
<span id="cb114-2596"><a href="#cb114-2596" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb114-2597"><a href="#cb114-2597" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2598"><a href="#cb114-2598" aria-hidden="true" tabindex="-1"></a><span class="co"># === Step 5: Apply clipping to both train and test sets ===</span></span>
<span id="cb114-2599"><a href="#cb114-2599" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df <span class="kw">in</span> [train_merged, test_merged]:</span>
<span id="cb114-2600"><a href="#cb114-2600" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> col, (lower, upper) <span class="kw">in</span> clip_bounds.items():</span>
<span id="cb114-2601"><a href="#cb114-2601" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> col <span class="kw">in</span> df.columns:</span>
<span id="cb114-2602"><a href="#cb114-2602" aria-hidden="true" tabindex="-1"></a>            df[col] <span class="op">=</span> df[col].clip(lower, upper)</span>
<span id="cb114-2603"><a href="#cb114-2603" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2604"><a href="#cb114-2604" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Adaptive clipping complete: 0.995 for ultra-skewed, 0.999 for moderately skewed."</span>)</span>
<span id="cb114-2605"><a href="#cb114-2605" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2606"><a href="#cb114-2606" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-2607"><a href="#cb114-2607" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2610"><a href="#cb114-2610" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-2611"><a href="#cb114-2611" aria-hidden="true" tabindex="-1"></a><span class="co"># Define columns to drop</span></span>
<span id="cb114-2612"><a href="#cb114-2612" aria-hidden="true" tabindex="-1"></a>year_built_cols <span class="op">=</span> [<span class="ss">f'year_built_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>)]</span>
<span id="cb114-2613"><a href="#cb114-2613" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2614"><a href="#cb114-2614" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop if columns exist</span></span>
<span id="cb114-2615"><a href="#cb114-2615" aria-hidden="true" tabindex="-1"></a>train_merged.drop(columns<span class="op">=</span>[col <span class="cf">for</span> col <span class="kw">in</span> year_built_cols <span class="cf">if</span> col <span class="kw">in</span> train_merged.columns], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-2616"><a href="#cb114-2616" aria-hidden="true" tabindex="-1"></a>test_merged.drop(columns<span class="op">=</span>[col <span class="cf">for</span> col <span class="kw">in</span> year_built_cols <span class="cf">if</span> col <span class="kw">in</span> test_merged.columns], inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-2617"><a href="#cb114-2617" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2618"><a href="#cb114-2618" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Dropped year_built_2015 to year_built_2019 from both train and test sets."</span>)</span>
<span id="cb114-2619"><a href="#cb114-2619" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-2620"><a href="#cb114-2620" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2623"><a href="#cb114-2623" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-2624"><a href="#cb114-2624" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">"TARGET"</span> <span class="kw">in</span> train_merged.columns:</span>
<span id="cb114-2625"><a href="#cb114-2625" aria-hidden="true" tabindex="-1"></a>    train_merged.drop(<span class="st">"TARGET"</span>, axis<span class="op">=</span><span class="dv">1</span>,inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-2626"><a href="#cb114-2626" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb114-2627"><a href="#cb114-2627" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"TARGET not found in columns:"</span>, train_merged.columns.tolist())</span>
<span id="cb114-2628"><a href="#cb114-2628" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2629"><a href="#cb114-2629" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-2630"><a href="#cb114-2630" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2633"><a href="#cb114-2633" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-2634"><a href="#cb114-2634" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop floor_area_total_final if it exists</span></span>
<span id="cb114-2635"><a href="#cb114-2635" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> df_name, df <span class="kw">in</span> [(<span class="st">'train_merged'</span>, train_merged), (<span class="st">'test_merged'</span>, test_merged)]:</span>
<span id="cb114-2636"><a href="#cb114-2636" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'floor_area_total_final'</span> <span class="kw">in</span> df.columns:</span>
<span id="cb114-2637"><a href="#cb114-2637" aria-hidden="true" tabindex="-1"></a>        df.drop(columns<span class="op">=</span><span class="st">'floor_area_total_final'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-2638"><a href="#cb114-2638" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f" Dropped 'floor_area_total_final' from </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-2639"><a href="#cb114-2639" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb114-2640"><a href="#cb114-2640" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"‚Ñπ 'floor_area_total_final' not found in </span><span class="sc">{</span>df_name<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-2641"><a href="#cb114-2641" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2642"><a href="#cb114-2642" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-2643"><a href="#cb114-2643" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2646"><a href="#cb114-2646" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-2647"><a href="#cb114-2647" aria-hidden="true" tabindex="-1"></a>train_cols <span class="op">=</span> <span class="bu">set</span>(train_merged.columns)</span>
<span id="cb114-2648"><a href="#cb114-2648" aria-hidden="true" tabindex="-1"></a>test_cols <span class="op">=</span> <span class="bu">set</span>(test_merged.columns)</span>
<span id="cb114-2649"><a href="#cb114-2649" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2650"><a href="#cb114-2650" aria-hidden="true" tabindex="-1"></a>missing_in_test <span class="op">=</span> train_cols <span class="op">-</span> test_cols</span>
<span id="cb114-2651"><a href="#cb114-2651" aria-hidden="true" tabindex="-1"></a>missing_in_train <span class="op">=</span> test_cols <span class="op">-</span> train_cols</span>
<span id="cb114-2652"><a href="#cb114-2652" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2653"><a href="#cb114-2653" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Columns in train but not in test:"</span>)</span>
<span id="cb114-2654"><a href="#cb114-2654" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">sorted</span>(missing_in_test))</span>
<span id="cb114-2655"><a href="#cb114-2655" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2656"><a href="#cb114-2656" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st"> Columns in test but not in train:"</span>)</span>
<span id="cb114-2657"><a href="#cb114-2657" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">sorted</span>(missing_in_train))</span>
<span id="cb114-2658"><a href="#cb114-2658" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2659"><a href="#cb114-2659" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-2660"><a href="#cb114-2660" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2663"><a href="#cb114-2663" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-2664"><a href="#cb114-2664" aria-hidden="true" tabindex="-1"></a><span class="co"># Check if column sets match</span></span>
<span id="cb114-2665"><a href="#cb114-2665" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">set</span>(train_merged.columns) <span class="op">==</span> <span class="bu">set</span>(test_merged.columns))  <span class="co"># Should be True</span></span>
<span id="cb114-2666"><a href="#cb114-2666" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2667"><a href="#cb114-2667" aria-hidden="true" tabindex="-1"></a><span class="co"># Check if column order matches</span></span>
<span id="cb114-2668"><a href="#cb114-2668" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">list</span>(train_merged.columns) <span class="op">==</span> <span class="bu">list</span>(test_merged.columns))  <span class="co"># Must also be True</span></span>
<span id="cb114-2669"><a href="#cb114-2669" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2670"><a href="#cb114-2670" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-2671"><a href="#cb114-2671" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2674"><a href="#cb114-2674" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-2675"><a href="#cb114-2675" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb114-2676"><a href="#cb114-2676" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb114-2677"><a href="#cb114-2677" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> optuna</span>
<span id="cb114-2678"><a href="#cb114-2678" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> lightgbm <span class="im">as</span> lgb</span>
<span id="cb114-2679"><a href="#cb114-2679" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> shap</span>
<span id="cb114-2680"><a href="#cb114-2680" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> KFold</span>
<span id="cb114-2681"><a href="#cb114-2681" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> root_mean_squared_error</span>
<span id="cb114-2682"><a href="#cb114-2682" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> optuna.integration <span class="im">import</span> LightGBMPruningCallback</span>
<span id="cb114-2683"><a href="#cb114-2683" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> optuna.pruners <span class="im">import</span> SuccessiveHalvingPruner</span>
<span id="cb114-2684"><a href="#cb114-2684" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> lightgbm <span class="im">import</span> log_evaluation, early_stopping</span>
<span id="cb114-2685"><a href="#cb114-2685" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2686"><a href="#cb114-2686" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 0: Setup Data ===</span></span>
<span id="cb114-2687"><a href="#cb114-2687" aria-hidden="true" tabindex="-1"></a>X_full <span class="op">=</span> train_merged.copy()</span>
<span id="cb114-2688"><a href="#cb114-2688" aria-hidden="true" tabindex="-1"></a>y_full <span class="op">=</span> pd.Series(y_train)</span>
<span id="cb114-2689"><a href="#cb114-2689" aria-hidden="true" tabindex="-1"></a>X_test <span class="op">=</span> test_merged.copy()</span>
<span id="cb114-2690"><a href="#cb114-2690" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2691"><a href="#cb114-2691" aria-hidden="true" tabindex="-1"></a><span class="co"># Detect categorical columns</span></span>
<span id="cb114-2692"><a href="#cb114-2692" aria-hidden="true" tabindex="-1"></a>cat_cols <span class="op">=</span> X_full.select_dtypes(include<span class="op">=</span>[<span class="st">'category'</span>, <span class="st">'object'</span>]).columns.tolist()</span>
<span id="cb114-2693"><a href="#cb114-2693" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> cat_cols:</span>
<span id="cb114-2694"><a href="#cb114-2694" aria-hidden="true" tabindex="-1"></a>    X_full[col] <span class="op">=</span> X_full[col].astype(<span class="st">"category"</span>)</span>
<span id="cb114-2695"><a href="#cb114-2695" aria-hidden="true" tabindex="-1"></a>    X_test[col] <span class="op">=</span> X_test[col].astype(<span class="st">"category"</span>)</span>
<span id="cb114-2696"><a href="#cb114-2696" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2697"><a href="#cb114-2697" aria-hidden="true" tabindex="-1"></a>global_oof_preds <span class="op">=</span> np.zeros(<span class="bu">len</span>(X_full))</span>
<span id="cb114-2698"><a href="#cb114-2698" aria-hidden="true" tabindex="-1"></a>best_score <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb114-2699"><a href="#cb114-2699" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2700"><a href="#cb114-2700" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 1: Define Optuna Objective ===</span></span>
<span id="cb114-2701"><a href="#cb114-2701" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> objective(trial):</span>
<span id="cb114-2702"><a href="#cb114-2702" aria-hidden="true" tabindex="-1"></a>    <span class="kw">global</span> global_oof_preds, best_score</span>
<span id="cb114-2703"><a href="#cb114-2703" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2704"><a href="#cb114-2704" aria-hidden="true" tabindex="-1"></a>    params <span class="op">=</span> {</span>
<span id="cb114-2705"><a href="#cb114-2705" aria-hidden="true" tabindex="-1"></a>        <span class="st">"objective"</span>: <span class="st">"regression"</span>,</span>
<span id="cb114-2706"><a href="#cb114-2706" aria-hidden="true" tabindex="-1"></a>        <span class="st">"metric"</span>: <span class="st">"rmse"</span>,</span>
<span id="cb114-2707"><a href="#cb114-2707" aria-hidden="true" tabindex="-1"></a>        <span class="st">"boosting_type"</span>: <span class="st">"gbdt"</span>,</span>
<span id="cb114-2708"><a href="#cb114-2708" aria-hidden="true" tabindex="-1"></a>        <span class="st">"learning_rate"</span>: trial.suggest_float(<span class="st">"learning_rate"</span>, <span class="fl">0.025</span>, <span class="fl">0.04</span>, log<span class="op">=</span><span class="va">True</span>),</span>
<span id="cb114-2709"><a href="#cb114-2709" aria-hidden="true" tabindex="-1"></a>        <span class="st">"num_leaves"</span>: trial.suggest_int(<span class="st">"num_leaves"</span>, <span class="dv">160</span>, <span class="dv">220</span>),</span>
<span id="cb114-2710"><a href="#cb114-2710" aria-hidden="true" tabindex="-1"></a>        <span class="st">"max_depth"</span>: trial.suggest_int(<span class="st">"max_depth"</span>, <span class="dv">7</span>, <span class="dv">11</span>),</span>
<span id="cb114-2711"><a href="#cb114-2711" aria-hidden="true" tabindex="-1"></a>        <span class="st">"min_child_samples"</span>: trial.suggest_int(<span class="st">"min_child_samples"</span>, <span class="dv">18</span>, <span class="dv">30</span>),</span>
<span id="cb114-2712"><a href="#cb114-2712" aria-hidden="true" tabindex="-1"></a>        <span class="st">"subsample"</span>: trial.suggest_float(<span class="st">"subsample"</span>, <span class="fl">0.65</span>, <span class="fl">0.88</span>),</span>
<span id="cb114-2713"><a href="#cb114-2713" aria-hidden="true" tabindex="-1"></a>        <span class="st">"colsample_bytree"</span>: trial.suggest_float(<span class="st">"colsample_bytree"</span>, <span class="fl">0.6</span>, <span class="fl">0.75</span>),</span>
<span id="cb114-2714"><a href="#cb114-2714" aria-hidden="true" tabindex="-1"></a>        <span class="st">"reg_alpha"</span>: trial.suggest_float(<span class="st">"reg_alpha"</span>, <span class="fl">1.0</span>, <span class="fl">5.0</span>, log<span class="op">=</span><span class="va">True</span>),</span>
<span id="cb114-2715"><a href="#cb114-2715" aria-hidden="true" tabindex="-1"></a>        <span class="st">"reg_lambda"</span>: trial.suggest_float(<span class="st">"reg_lambda"</span>, <span class="fl">1.0</span>, <span class="fl">4.0</span>, log<span class="op">=</span><span class="va">True</span>),</span>
<span id="cb114-2716"><a href="#cb114-2716" aria-hidden="true" tabindex="-1"></a>        <span class="st">"min_split_gain"</span>: trial.suggest_float(<span class="st">"min_split_gain"</span>, <span class="fl">0.15</span>, <span class="fl">0.25</span>),</span>
<span id="cb114-2717"><a href="#cb114-2717" aria-hidden="true" tabindex="-1"></a>        <span class="st">"verbose"</span>: <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb114-2718"><a href="#cb114-2718" aria-hidden="true" tabindex="-1"></a>        <span class="st">"n_jobs"</span>: <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb114-2719"><a href="#cb114-2719" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb114-2720"><a href="#cb114-2720" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2721"><a href="#cb114-2721" aria-hidden="true" tabindex="-1"></a>    kf <span class="op">=</span> KFold(n_splits<span class="op">=</span><span class="dv">3</span>, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb114-2722"><a href="#cb114-2722" aria-hidden="true" tabindex="-1"></a>    val_rmse <span class="op">=</span> []</span>
<span id="cb114-2723"><a href="#cb114-2723" aria-hidden="true" tabindex="-1"></a>    oof_preds <span class="op">=</span> np.zeros(<span class="bu">len</span>(X_full))</span>
<span id="cb114-2724"><a href="#cb114-2724" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2725"><a href="#cb114-2725" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> fold, (train_idx, val_idx) <span class="kw">in</span> <span class="bu">enumerate</span>(kf.split(X_full)):</span>
<span id="cb114-2726"><a href="#cb114-2726" aria-hidden="true" tabindex="-1"></a>        X_train, X_val <span class="op">=</span> X_full.iloc[train_idx], X_full.iloc[val_idx]</span>
<span id="cb114-2727"><a href="#cb114-2727" aria-hidden="true" tabindex="-1"></a>        y_train_fold, y_val <span class="op">=</span> y_full.iloc[train_idx], y_full.iloc[val_idx]</span>
<span id="cb114-2728"><a href="#cb114-2728" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2729"><a href="#cb114-2729" aria-hidden="true" tabindex="-1"></a>        dtrain <span class="op">=</span> lgb.Dataset(X_train, label<span class="op">=</span>y_train_fold, categorical_feature<span class="op">=</span>cat_cols)</span>
<span id="cb114-2730"><a href="#cb114-2730" aria-hidden="true" tabindex="-1"></a>        dvalid <span class="op">=</span> lgb.Dataset(X_val, label<span class="op">=</span>y_val, categorical_feature<span class="op">=</span>cat_cols)</span>
<span id="cb114-2731"><a href="#cb114-2731" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2732"><a href="#cb114-2732" aria-hidden="true" tabindex="-1"></a>        model <span class="op">=</span> lgb.train(</span>
<span id="cb114-2733"><a href="#cb114-2733" aria-hidden="true" tabindex="-1"></a>            params,</span>
<span id="cb114-2734"><a href="#cb114-2734" aria-hidden="true" tabindex="-1"></a>            dtrain,</span>
<span id="cb114-2735"><a href="#cb114-2735" aria-hidden="true" tabindex="-1"></a>            valid_sets<span class="op">=</span>[dvalid],</span>
<span id="cb114-2736"><a href="#cb114-2736" aria-hidden="true" tabindex="-1"></a>            num_boost_round<span class="op">=</span><span class="dv">1000</span>,</span>
<span id="cb114-2737"><a href="#cb114-2737" aria-hidden="true" tabindex="-1"></a>            callbacks<span class="op">=</span>[</span>
<span id="cb114-2738"><a href="#cb114-2738" aria-hidden="true" tabindex="-1"></a>                early_stopping(stopping_rounds<span class="op">=</span><span class="dv">100</span>),</span>
<span id="cb114-2739"><a href="#cb114-2739" aria-hidden="true" tabindex="-1"></a>                log_evaluation(period<span class="op">=</span><span class="dv">100</span>),</span>
<span id="cb114-2740"><a href="#cb114-2740" aria-hidden="true" tabindex="-1"></a>                LightGBMPruningCallback(trial, <span class="st">"rmse"</span>)</span>
<span id="cb114-2741"><a href="#cb114-2741" aria-hidden="true" tabindex="-1"></a>            ]</span>
<span id="cb114-2742"><a href="#cb114-2742" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb114-2743"><a href="#cb114-2743" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2744"><a href="#cb114-2744" aria-hidden="true" tabindex="-1"></a>        val_pred <span class="op">=</span> model.predict(X_val, num_iteration<span class="op">=</span>model.best_iteration)</span>
<span id="cb114-2745"><a href="#cb114-2745" aria-hidden="true" tabindex="-1"></a>        oof_preds[val_idx] <span class="op">=</span> val_pred</span>
<span id="cb114-2746"><a href="#cb114-2746" aria-hidden="true" tabindex="-1"></a>        val_rmse.append(root_mean_squared_error(y_val, val_pred))</span>
<span id="cb114-2747"><a href="#cb114-2747" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2748"><a href="#cb114-2748" aria-hidden="true" tabindex="-1"></a>    mean_rmse <span class="op">=</span> np.mean(val_rmse)</span>
<span id="cb114-2749"><a href="#cb114-2749" aria-hidden="true" tabindex="-1"></a>    trial.set_user_attr(<span class="st">"cv_rmse"</span>, mean_rmse)</span>
<span id="cb114-2750"><a href="#cb114-2750" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2751"><a href="#cb114-2751" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> mean_rmse <span class="op">&lt;</span> best_score:</span>
<span id="cb114-2752"><a href="#cb114-2752" aria-hidden="true" tabindex="-1"></a>        best_score <span class="op">=</span> mean_rmse</span>
<span id="cb114-2753"><a href="#cb114-2753" aria-hidden="true" tabindex="-1"></a>        global_oof_preds[:] <span class="op">=</span> oof_preds</span>
<span id="cb114-2754"><a href="#cb114-2754" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2755"><a href="#cb114-2755" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Trial </span><span class="sc">{</span>trial<span class="sc">.</span>number<span class="sc">}</span><span class="ss"> | CV RMSE: </span><span class="sc">{</span>mean_rmse<span class="sc">:,.2f}</span><span class="ss">"</span>)</span>
<span id="cb114-2756"><a href="#cb114-2756" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mean_rmse</span>
<span id="cb114-2757"><a href="#cb114-2757" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2758"><a href="#cb114-2758" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 2: Run Optuna ===</span></span>
<span id="cb114-2759"><a href="#cb114-2759" aria-hidden="true" tabindex="-1"></a>study <span class="op">=</span> optuna.create_study(</span>
<span id="cb114-2760"><a href="#cb114-2760" aria-hidden="true" tabindex="-1"></a>    direction<span class="op">=</span><span class="st">'minimize'</span>,</span>
<span id="cb114-2761"><a href="#cb114-2761" aria-hidden="true" tabindex="-1"></a>    study_name<span class="op">=</span><span class="st">'lgbm_study_final_with_shap'</span>,</span>
<span id="cb114-2762"><a href="#cb114-2762" aria-hidden="true" tabindex="-1"></a>    storage<span class="op">=</span><span class="st">'sqlite:///lgbm_study_final_with_shap.db'</span>,</span>
<span id="cb114-2763"><a href="#cb114-2763" aria-hidden="true" tabindex="-1"></a>    load_if_exists<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb114-2764"><a href="#cb114-2764" aria-hidden="true" tabindex="-1"></a>    pruner<span class="op">=</span>SuccessiveHalvingPruner(min_resource<span class="op">=</span><span class="dv">100</span>, reduction_factor<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb114-2765"><a href="#cb114-2765" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb114-2766"><a href="#cb114-2766" aria-hidden="true" tabindex="-1"></a>study.optimize(objective, n_trials<span class="op">=</span><span class="dv">25</span>, show_progress_bar<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-2767"><a href="#cb114-2767" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2768"><a href="#cb114-2768" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Best RMSE:"</span>, study.best_value)</span>
<span id="cb114-2769"><a href="#cb114-2769" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Best Parameters:"</span>, study.best_params)</span>
<span id="cb114-2770"><a href="#cb114-2770" aria-hidden="true" tabindex="-1"></a>np.save(<span class="st">"oof_preds_lgbm.npy"</span>, global_oof_preds)</span>
<span id="cb114-2771"><a href="#cb114-2771" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Saved: oof_preds_lgbm.npy"</span>)</span>
<span id="cb114-2772"><a href="#cb114-2772" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2773"><a href="#cb114-2773" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 3: SHAP + GAIN Feature Selection ===</span></span>
<span id="cb114-2774"><a href="#cb114-2774" aria-hidden="true" tabindex="-1"></a>kf <span class="op">=</span> KFold(n_splits<span class="op">=</span><span class="dv">3</span>, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb114-2775"><a href="#cb114-2775" aria-hidden="true" tabindex="-1"></a>selected_feature_sets <span class="op">=</span> []</span>
<span id="cb114-2776"><a href="#cb114-2776" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2777"><a href="#cb114-2777" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> fold, (train_idx, val_idx) <span class="kw">in</span> <span class="bu">enumerate</span>(kf.split(X_full)):</span>
<span id="cb114-2778"><a href="#cb114-2778" aria-hidden="true" tabindex="-1"></a>    X_train_raw, y_train_fold <span class="op">=</span> X_full.iloc[train_idx], y_full.iloc[train_idx]</span>
<span id="cb114-2779"><a href="#cb114-2779" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2780"><a href="#cb114-2780" aria-hidden="true" tabindex="-1"></a>    train_dataset <span class="op">=</span> lgb.Dataset(X_train_raw, label<span class="op">=</span>y_train_fold, categorical_feature<span class="op">=</span>cat_cols)</span>
<span id="cb114-2781"><a href="#cb114-2781" aria-hidden="true" tabindex="-1"></a>    model_temp <span class="op">=</span> lgb.train(</span>
<span id="cb114-2782"><a href="#cb114-2782" aria-hidden="true" tabindex="-1"></a>        study.best_params,</span>
<span id="cb114-2783"><a href="#cb114-2783" aria-hidden="true" tabindex="-1"></a>        train_dataset,</span>
<span id="cb114-2784"><a href="#cb114-2784" aria-hidden="true" tabindex="-1"></a>        num_boost_round<span class="op">=</span><span class="dv">200</span>,</span>
<span id="cb114-2785"><a href="#cb114-2785" aria-hidden="true" tabindex="-1"></a>        valid_sets<span class="op">=</span>[train_dataset],</span>
<span id="cb114-2786"><a href="#cb114-2786" aria-hidden="true" tabindex="-1"></a>        callbacks<span class="op">=</span>[log_evaluation(period<span class="op">=</span><span class="dv">100</span>)] </span>
<span id="cb114-2787"><a href="#cb114-2787" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb114-2788"><a href="#cb114-2788" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2789"><a href="#cb114-2789" aria-hidden="true" tabindex="-1"></a>    <span class="co"># SHAP importance</span></span>
<span id="cb114-2790"><a href="#cb114-2790" aria-hidden="true" tabindex="-1"></a>    explainer <span class="op">=</span> shap.TreeExplainer(model_temp)</span>
<span id="cb114-2791"><a href="#cb114-2791" aria-hidden="true" tabindex="-1"></a>    shap_values <span class="op">=</span> explainer.shap_values(X_train_raw)</span>
<span id="cb114-2792"><a href="#cb114-2792" aria-hidden="true" tabindex="-1"></a>    shap_df <span class="op">=</span> pd.DataFrame(np.<span class="bu">abs</span>(shap_values), columns<span class="op">=</span>X_train_raw.columns)</span>
<span id="cb114-2793"><a href="#cb114-2793" aria-hidden="true" tabindex="-1"></a>    shap_importance <span class="op">=</span> shap_df.mean().sort_values(ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb114-2794"><a href="#cb114-2794" aria-hidden="true" tabindex="-1"></a>    shap_cumsum <span class="op">=</span> shap_importance.cumsum() <span class="op">/</span> shap_importance.<span class="bu">sum</span>()</span>
<span id="cb114-2795"><a href="#cb114-2795" aria-hidden="true" tabindex="-1"></a>    top_shap <span class="op">=</span> shap_cumsum[shap_cumsum <span class="op">&lt;=</span> <span class="fl">0.95</span>].index.tolist()</span>
<span id="cb114-2796"><a href="#cb114-2796" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2797"><a href="#cb114-2797" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Gain importance</span></span>
<span id="cb114-2798"><a href="#cb114-2798" aria-hidden="true" tabindex="-1"></a>    gain_importance <span class="op">=</span> pd.Series(model_temp.feature_importance(importance_type<span class="op">=</span><span class="st">'gain'</span>), index<span class="op">=</span>X_train_raw.columns)</span>
<span id="cb114-2799"><a href="#cb114-2799" aria-hidden="true" tabindex="-1"></a>    gain_sorted <span class="op">=</span> gain_importance.sort_values(ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb114-2800"><a href="#cb114-2800" aria-hidden="true" tabindex="-1"></a>    gain_cumsum <span class="op">=</span> gain_sorted.cumsum() <span class="op">/</span> gain_sorted.<span class="bu">sum</span>()</span>
<span id="cb114-2801"><a href="#cb114-2801" aria-hidden="true" tabindex="-1"></a>    top_gain <span class="op">=</span> gain_cumsum[gain_cumsum <span class="op">&lt;=</span> <span class="fl">0.95</span>].index.tolist()</span>
<span id="cb114-2802"><a href="#cb114-2802" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2803"><a href="#cb114-2803" aria-hidden="true" tabindex="-1"></a>    selected_features <span class="op">=</span> <span class="bu">list</span>(<span class="bu">set</span>(top_shap).union(<span class="bu">set</span>(top_gain)))</span>
<span id="cb114-2804"><a href="#cb114-2804" aria-hidden="true" tabindex="-1"></a>    selected_feature_sets.append(selected_features)</span>
<span id="cb114-2805"><a href="#cb114-2805" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2806"><a href="#cb114-2806" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 4: Final Feature Union ===</span></span>
<span id="cb114-2807"><a href="#cb114-2807" aria-hidden="true" tabindex="-1"></a>final_union_features <span class="op">=</span> <span class="bu">list</span>(<span class="bu">set</span>().union(<span class="op">*</span>selected_feature_sets))</span>
<span id="cb114-2808"><a href="#cb114-2808" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Final Union Feature Count:"</span>, <span class="bu">len</span>(final_union_features))</span>
<span id="cb114-2809"><a href="#cb114-2809" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2810"><a href="#cb114-2810" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter only those categorical columns that are in final features</span></span>
<span id="cb114-2811"><a href="#cb114-2811" aria-hidden="true" tabindex="-1"></a>filtered_cat_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> cat_cols <span class="cf">if</span> col <span class="kw">in</span> final_union_features]</span>
<span id="cb114-2812"><a href="#cb114-2812" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2813"><a href="#cb114-2813" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 5: Final Model on Selected Features ===</span></span>
<span id="cb114-2814"><a href="#cb114-2814" aria-hidden="true" tabindex="-1"></a>X_full_selected <span class="op">=</span> X_full[final_union_features]</span>
<span id="cb114-2815"><a href="#cb114-2815" aria-hidden="true" tabindex="-1"></a>X_test_selected <span class="op">=</span> X_test[final_union_features]</span>
<span id="cb114-2816"><a href="#cb114-2816" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2817"><a href="#cb114-2817" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2818"><a href="#cb114-2818" aria-hidden="true" tabindex="-1"></a>final_dataset <span class="op">=</span> lgb.Dataset(X_full_selected, label<span class="op">=</span>y_full, categorical_feature<span class="op">=</span>filtered_cat_cols)</span>
<span id="cb114-2819"><a href="#cb114-2819" aria-hidden="true" tabindex="-1"></a>final_model <span class="op">=</span> lgb.train(</span>
<span id="cb114-2820"><a href="#cb114-2820" aria-hidden="true" tabindex="-1"></a>    study.best_params,</span>
<span id="cb114-2821"><a href="#cb114-2821" aria-hidden="true" tabindex="-1"></a>    final_dataset,</span>
<span id="cb114-2822"><a href="#cb114-2822" aria-hidden="true" tabindex="-1"></a>    num_boost_round<span class="op">=</span><span class="dv">1000</span>,</span>
<span id="cb114-2823"><a href="#cb114-2823" aria-hidden="true" tabindex="-1"></a>    valid_sets<span class="op">=</span>[final_dataset],</span>
<span id="cb114-2824"><a href="#cb114-2824" aria-hidden="true" tabindex="-1"></a>    valid_names<span class="op">=</span>[<span class="st">"train"</span>],</span>
<span id="cb114-2825"><a href="#cb114-2825" aria-hidden="true" tabindex="-1"></a>    callbacks<span class="op">=</span>[log_evaluation(period<span class="op">=</span><span class="dv">100</span>)]</span>
<span id="cb114-2826"><a href="#cb114-2826" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb114-2827"><a href="#cb114-2827" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2828"><a href="#cb114-2828" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 6: Predict on Test Set ===</span></span>
<span id="cb114-2829"><a href="#cb114-2829" aria-hidden="true" tabindex="-1"></a>test_preds <span class="op">=</span> final_model.predict(X_test_selected, num_iteration<span class="op">=</span>final_model.best_iteration)</span>
<span id="cb114-2830"><a href="#cb114-2830" aria-hidden="true" tabindex="-1"></a>np.save(<span class="st">"test_preds_lgbm_shap.npy"</span>, test_preds)</span>
<span id="cb114-2831"><a href="#cb114-2831" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Saved: test_preds_lgbm_shap.npy"</span>)</span>
<span id="cb114-2832"><a href="#cb114-2832" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2833"><a href="#cb114-2833" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 7: Save Submission ===</span></span>
<span id="cb114-2834"><a href="#cb114-2834" aria-hidden="true" tabindex="-1"></a>submission <span class="op">=</span> pd.DataFrame({</span>
<span id="cb114-2835"><a href="#cb114-2835" aria-hidden="true" tabindex="-1"></a>    <span class="st">'ACCOUNT'</span>: acct_test.values.ravel(),  <span class="co"># Replace with your ID col</span></span>
<span id="cb114-2836"><a href="#cb114-2836" aria-hidden="true" tabindex="-1"></a>    <span class="st">'TARGET'</span>: test_preds</span>
<span id="cb114-2837"><a href="#cb114-2837" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb114-2838"><a href="#cb114-2838" aria-hidden="true" tabindex="-1"></a>submission.to_csv(<span class="st">"submission_lgbm_shap.csv"</span>, index<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb114-2839"><a href="#cb114-2839" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Submission saved: submission_lgbm_shap.csv"</span>)</span>
<span id="cb114-2840"><a href="#cb114-2840" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-2841"><a href="#cb114-2841" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2844"><a href="#cb114-2844" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-2845"><a href="#cb114-2845" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb114-2846"><a href="#cb114-2846" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb114-2847"><a href="#cb114-2847" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> optuna</span>
<span id="cb114-2848"><a href="#cb114-2848" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> xgboost <span class="im">import</span> XGBRegressor</span>
<span id="cb114-2849"><a href="#cb114-2849" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> KFold</span>
<span id="cb114-2850"><a href="#cb114-2850" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> root_mean_squared_error</span>
<span id="cb114-2851"><a href="#cb114-2851" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> optuna.integration <span class="im">import</span> XGBoostPruningCallback</span>
<span id="cb114-2852"><a href="#cb114-2852" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> shap <span class="im">import</span> TreeExplainer</span>
<span id="cb114-2853"><a href="#cb114-2853" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2854"><a href="#cb114-2854" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 0: Prepare Data ===</span></span>
<span id="cb114-2855"><a href="#cb114-2855" aria-hidden="true" tabindex="-1"></a>X_full <span class="op">=</span> train_merged.copy()</span>
<span id="cb114-2856"><a href="#cb114-2856" aria-hidden="true" tabindex="-1"></a>y_full <span class="op">=</span> pd.Series(y_train)</span>
<span id="cb114-2857"><a href="#cb114-2857" aria-hidden="true" tabindex="-1"></a>X_test <span class="op">=</span> test_merged.copy()</span>
<span id="cb114-2858"><a href="#cb114-2858" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2859"><a href="#cb114-2859" aria-hidden="true" tabindex="-1"></a>bin_cols <span class="op">=</span> [</span>
<span id="cb114-2860"><a href="#cb114-2860" aria-hidden="true" tabindex="-1"></a>    <span class="st">'building_value_growth_bin'</span>,</span>
<span id="cb114-2861"><a href="#cb114-2861" aria-hidden="true" tabindex="-1"></a>    <span class="st">'assessed_growth_bin'</span>,</span>
<span id="cb114-2862"><a href="#cb114-2862" aria-hidden="true" tabindex="-1"></a>    <span class="st">'land_value_growth_bin'</span>,<span class="st">'year_built_bin'</span></span>
<span id="cb114-2863"><a href="#cb114-2863" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb114-2864"><a href="#cb114-2864" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2865"><a href="#cb114-2865" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> bin_cols:</span>
<span id="cb114-2866"><a href="#cb114-2866" aria-hidden="true" tabindex="-1"></a>    X_full[col] <span class="op">=</span> X_full[col].cat.codes</span>
<span id="cb114-2867"><a href="#cb114-2867" aria-hidden="true" tabindex="-1"></a>    X_test[col] <span class="op">=</span> X_test[col].cat.codes</span>
<span id="cb114-2868"><a href="#cb114-2868" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2869"><a href="#cb114-2869" aria-hidden="true" tabindex="-1"></a>categorical_cols <span class="op">=</span> X_full.select_dtypes(include<span class="op">=</span><span class="st">'object'</span>).columns.tolist()</span>
<span id="cb114-2870"><a href="#cb114-2870" aria-hidden="true" tabindex="-1"></a>X_full[categorical_cols] <span class="op">=</span> X_full[categorical_cols].astype(<span class="st">'category'</span>)</span>
<span id="cb114-2871"><a href="#cb114-2871" aria-hidden="true" tabindex="-1"></a>X_test[categorical_cols] <span class="op">=</span> X_test[categorical_cols].astype(<span class="st">'category'</span>)</span>
<span id="cb114-2872"><a href="#cb114-2872" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2873"><a href="#cb114-2873" aria-hidden="true" tabindex="-1"></a><span class="co"># === Global OOF Tracker ===</span></span>
<span id="cb114-2874"><a href="#cb114-2874" aria-hidden="true" tabindex="-1"></a>global_oof_preds <span class="op">=</span> np.zeros(<span class="bu">len</span>(X_full))</span>
<span id="cb114-2875"><a href="#cb114-2875" aria-hidden="true" tabindex="-1"></a>best_score <span class="op">=</span> <span class="bu">float</span>(<span class="st">"inf"</span>)</span>
<span id="cb114-2876"><a href="#cb114-2876" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2877"><a href="#cb114-2877" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 1: Optuna Objective Function (No SHAP during tuning) ===</span></span>
<span id="cb114-2878"><a href="#cb114-2878" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> objective(trial):</span>
<span id="cb114-2879"><a href="#cb114-2879" aria-hidden="true" tabindex="-1"></a>    <span class="kw">global</span> global_oof_preds, best_score</span>
<span id="cb114-2880"><a href="#cb114-2880" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2881"><a href="#cb114-2881" aria-hidden="true" tabindex="-1"></a>    params <span class="op">=</span> {</span>
<span id="cb114-2882"><a href="#cb114-2882" aria-hidden="true" tabindex="-1"></a>        <span class="st">"objective"</span>: <span class="st">"reg:squarederror"</span>,</span>
<span id="cb114-2883"><a href="#cb114-2883" aria-hidden="true" tabindex="-1"></a>        <span class="st">"eval_metric"</span>: <span class="st">"rmse"</span>,</span>
<span id="cb114-2884"><a href="#cb114-2884" aria-hidden="true" tabindex="-1"></a>        <span class="st">"tree_method"</span>: <span class="st">"hist"</span>,</span>
<span id="cb114-2885"><a href="#cb114-2885" aria-hidden="true" tabindex="-1"></a>        <span class="st">"learning_rate"</span>: trial.suggest_float(<span class="st">"learning_rate"</span>, <span class="fl">0.047</span>, <span class="fl">0.05</span>, log<span class="op">=</span><span class="va">True</span>),</span>
<span id="cb114-2886"><a href="#cb114-2886" aria-hidden="true" tabindex="-1"></a>        <span class="st">"max_depth"</span>: <span class="dv">6</span>,</span>
<span id="cb114-2887"><a href="#cb114-2887" aria-hidden="true" tabindex="-1"></a>        <span class="st">"min_child_weight"</span>: trial.suggest_int(<span class="st">"min_child_weight"</span>, <span class="dv">11</span>, <span class="dv">12</span>),</span>
<span id="cb114-2888"><a href="#cb114-2888" aria-hidden="true" tabindex="-1"></a>        <span class="st">"subsample"</span>: trial.suggest_float(<span class="st">"subsample"</span>, <span class="fl">0.87</span>, <span class="fl">0.89</span>),</span>
<span id="cb114-2889"><a href="#cb114-2889" aria-hidden="true" tabindex="-1"></a>        <span class="st">"colsample_bytree"</span>: trial.suggest_float(<span class="st">"colsample_bytree"</span>, <span class="fl">0.7</span>, <span class="fl">0.74</span>),</span>
<span id="cb114-2890"><a href="#cb114-2890" aria-hidden="true" tabindex="-1"></a>        <span class="st">"reg_alpha"</span>: trial.suggest_float(<span class="st">"reg_alpha"</span>, <span class="fl">0.30</span>, <span class="fl">0.56</span>, log<span class="op">=</span><span class="va">True</span>),</span>
<span id="cb114-2891"><a href="#cb114-2891" aria-hidden="true" tabindex="-1"></a>        <span class="st">"reg_lambda"</span>: trial.suggest_float(<span class="st">"reg_lambda"</span>, <span class="fl">0.05</span>, <span class="fl">0.11</span>, log<span class="op">=</span><span class="va">True</span>),</span>
<span id="cb114-2892"><a href="#cb114-2892" aria-hidden="true" tabindex="-1"></a>        <span class="st">"gamma"</span>: trial.suggest_float(<span class="st">"gamma"</span>, <span class="fl">1.1</span>, <span class="fl">4.3</span>),</span>
<span id="cb114-2893"><a href="#cb114-2893" aria-hidden="true" tabindex="-1"></a>        <span class="st">"n_estimators"</span>: <span class="dv">1000</span>,</span>
<span id="cb114-2894"><a href="#cb114-2894" aria-hidden="true" tabindex="-1"></a>        <span class="st">"n_jobs"</span>: <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb114-2895"><a href="#cb114-2895" aria-hidden="true" tabindex="-1"></a>        <span class="st">"enable_categorical"</span>: <span class="va">True</span>,</span>
<span id="cb114-2896"><a href="#cb114-2896" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb114-2897"><a href="#cb114-2897" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2898"><a href="#cb114-2898" aria-hidden="true" tabindex="-1"></a>    kf <span class="op">=</span> KFold(n_splits<span class="op">=</span><span class="dv">3</span>, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb114-2899"><a href="#cb114-2899" aria-hidden="true" tabindex="-1"></a>    oof_preds <span class="op">=</span> np.zeros(<span class="bu">len</span>(X_full))</span>
<span id="cb114-2900"><a href="#cb114-2900" aria-hidden="true" tabindex="-1"></a>    fold_rmse <span class="op">=</span> []</span>
<span id="cb114-2901"><a href="#cb114-2901" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2902"><a href="#cb114-2902" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> fold, (train_idx, val_idx) <span class="kw">in</span> <span class="bu">enumerate</span>(kf.split(X_full)):</span>
<span id="cb114-2903"><a href="#cb114-2903" aria-hidden="true" tabindex="-1"></a>        X_train, y_train_fold <span class="op">=</span> X_full.iloc[train_idx], y_full.iloc[train_idx]</span>
<span id="cb114-2904"><a href="#cb114-2904" aria-hidden="true" tabindex="-1"></a>        X_val, y_val <span class="op">=</span> X_full.iloc[val_idx], y_full.iloc[val_idx]</span>
<span id="cb114-2905"><a href="#cb114-2905" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2906"><a href="#cb114-2906" aria-hidden="true" tabindex="-1"></a>        model <span class="op">=</span> XGBRegressor(</span>
<span id="cb114-2907"><a href="#cb114-2907" aria-hidden="true" tabindex="-1"></a>            <span class="op">**</span>params,</span>
<span id="cb114-2908"><a href="#cb114-2908" aria-hidden="true" tabindex="-1"></a>            early_stopping_rounds<span class="op">=</span><span class="dv">100</span>,</span>
<span id="cb114-2909"><a href="#cb114-2909" aria-hidden="true" tabindex="-1"></a>            callbacks<span class="op">=</span>[XGBoostPruningCallback(trial, <span class="st">"validation_0-rmse"</span>),</span>
<span id="cb114-2910"><a href="#cb114-2910" aria-hidden="true" tabindex="-1"></a>                       ]</span>
<span id="cb114-2911"><a href="#cb114-2911" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb114-2912"><a href="#cb114-2912" aria-hidden="true" tabindex="-1"></a>        model.fit(X_train, y_train_fold, eval_set<span class="op">=</span>[(X_val, y_val)], verbose<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb114-2913"><a href="#cb114-2913" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2914"><a href="#cb114-2914" aria-hidden="true" tabindex="-1"></a>        val_pred <span class="op">=</span> model.predict(X_val)</span>
<span id="cb114-2915"><a href="#cb114-2915" aria-hidden="true" tabindex="-1"></a>        oof_preds[val_idx] <span class="op">=</span> val_pred</span>
<span id="cb114-2916"><a href="#cb114-2916" aria-hidden="true" tabindex="-1"></a>        fold_rmse.append(root_mean_squared_error(y_val, val_pred))</span>
<span id="cb114-2917"><a href="#cb114-2917" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2918"><a href="#cb114-2918" aria-hidden="true" tabindex="-1"></a>    mean_rmse <span class="op">=</span> np.mean(fold_rmse)</span>
<span id="cb114-2919"><a href="#cb114-2919" aria-hidden="true" tabindex="-1"></a>    trial.set_user_attr(<span class="st">"cv_rmse"</span>, mean_rmse)</span>
<span id="cb114-2920"><a href="#cb114-2920" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2921"><a href="#cb114-2921" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> mean_rmse <span class="op">&lt;</span> best_score:</span>
<span id="cb114-2922"><a href="#cb114-2922" aria-hidden="true" tabindex="-1"></a>        best_score <span class="op">=</span> mean_rmse</span>
<span id="cb114-2923"><a href="#cb114-2923" aria-hidden="true" tabindex="-1"></a>        global_oof_preds[:] <span class="op">=</span> oof_preds</span>
<span id="cb114-2924"><a href="#cb114-2924" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2925"><a href="#cb114-2925" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f" Trial </span><span class="sc">{</span>trial<span class="sc">.</span>number<span class="sc">}</span><span class="ss"> | CV RMSE: </span><span class="sc">{</span>mean_rmse<span class="sc">:,.2f}</span><span class="ss">"</span>)</span>
<span id="cb114-2926"><a href="#cb114-2926" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mean_rmse</span>
<span id="cb114-2927"><a href="#cb114-2927" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2928"><a href="#cb114-2928" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 2: Run Optuna ===</span></span>
<span id="cb114-2929"><a href="#cb114-2929" aria-hidden="true" tabindex="-1"></a>study <span class="op">=</span> optuna.create_study(</span>
<span id="cb114-2930"><a href="#cb114-2930" aria-hidden="true" tabindex="-1"></a>    direction<span class="op">=</span><span class="st">'minimize'</span>,</span>
<span id="cb114-2931"><a href="#cb114-2931" aria-hidden="true" tabindex="-1"></a>    study_name<span class="op">=</span><span class="st">'xgbreg_optuna_final_no_shap'</span>,</span>
<span id="cb114-2932"><a href="#cb114-2932" aria-hidden="true" tabindex="-1"></a>    pruner<span class="op">=</span>optuna.pruners.SuccessiveHalvingPruner(min_resource<span class="op">=</span><span class="dv">100</span>, reduction_factor<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb114-2933"><a href="#cb114-2933" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb114-2934"><a href="#cb114-2934" aria-hidden="true" tabindex="-1"></a>study.optimize(objective, n_trials<span class="op">=</span><span class="dv">25</span>, show_progress_bar<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-2935"><a href="#cb114-2935" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2936"><a href="#cb114-2936" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Best RMSE:"</span>, study.best_value)</span>
<span id="cb114-2937"><a href="#cb114-2937" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Best Parameters:"</span>, study.best_params)</span>
<span id="cb114-2938"><a href="#cb114-2938" aria-hidden="true" tabindex="-1"></a>np.save(<span class="st">"oof_preds_xgbreg.npy"</span>, global_oof_preds)</span>
<span id="cb114-2939"><a href="#cb114-2939" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Saved: oof_preds_xgbreg.npy"</span>)</span>
<span id="cb114-2940"><a href="#cb114-2940" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2941"><a href="#cb114-2941" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 3: Post-Optuna SHAP + Gain Feature Selection ===</span></span>
<span id="cb114-2942"><a href="#cb114-2942" aria-hidden="true" tabindex="-1"></a>kf <span class="op">=</span> KFold(n_splits<span class="op">=</span><span class="dv">3</span>, shuffle<span class="op">=</span><span class="va">True</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb114-2943"><a href="#cb114-2943" aria-hidden="true" tabindex="-1"></a>selected_feature_sets <span class="op">=</span> []</span>
<span id="cb114-2944"><a href="#cb114-2944" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2945"><a href="#cb114-2945" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> fold, (train_idx, val_idx) <span class="kw">in</span> <span class="bu">enumerate</span>(kf.split(X_full)):</span>
<span id="cb114-2946"><a href="#cb114-2946" aria-hidden="true" tabindex="-1"></a>    X_train_raw, y_train_fold <span class="op">=</span> X_full.iloc[train_idx], y_full.iloc[train_idx]</span>
<span id="cb114-2947"><a href="#cb114-2947" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2948"><a href="#cb114-2948" aria-hidden="true" tabindex="-1"></a>    model_temp <span class="op">=</span> XGBRegressor(<span class="op">**</span>study.best_params, n_estimators<span class="op">=</span><span class="dv">200</span>)</span>
<span id="cb114-2949"><a href="#cb114-2949" aria-hidden="true" tabindex="-1"></a>    model_temp.fit(X_train_raw, y_train_fold)</span>
<span id="cb114-2950"><a href="#cb114-2950" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2951"><a href="#cb114-2951" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === SHAP Importance ===</span></span>
<span id="cb114-2952"><a href="#cb114-2952" aria-hidden="true" tabindex="-1"></a>    explainer <span class="op">=</span> TreeExplainer(model_temp)</span>
<span id="cb114-2953"><a href="#cb114-2953" aria-hidden="true" tabindex="-1"></a>    shap_values <span class="op">=</span> explainer.shap_values(X_train_raw)</span>
<span id="cb114-2954"><a href="#cb114-2954" aria-hidden="true" tabindex="-1"></a>    shap_df <span class="op">=</span> pd.DataFrame(np.<span class="bu">abs</span>(shap_values), columns<span class="op">=</span>X_train_raw.columns)</span>
<span id="cb114-2955"><a href="#cb114-2955" aria-hidden="true" tabindex="-1"></a>    shap_importance <span class="op">=</span> shap_df.mean().sort_values(ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb114-2956"><a href="#cb114-2956" aria-hidden="true" tabindex="-1"></a>    shap_cumsum <span class="op">=</span> shap_importance.cumsum() <span class="op">/</span> shap_importance.<span class="bu">sum</span>()</span>
<span id="cb114-2957"><a href="#cb114-2957" aria-hidden="true" tabindex="-1"></a>    top_shap <span class="op">=</span> shap_cumsum[shap_cumsum <span class="op">&lt;=</span> <span class="fl">0.95</span>].index.tolist()</span>
<span id="cb114-2958"><a href="#cb114-2958" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2959"><a href="#cb114-2959" aria-hidden="true" tabindex="-1"></a>    <span class="co"># === Gain Importance ===</span></span>
<span id="cb114-2960"><a href="#cb114-2960" aria-hidden="true" tabindex="-1"></a>    gain_importance <span class="op">=</span> pd.Series(model_temp.feature_importances_, index<span class="op">=</span>X_train_raw.columns)</span>
<span id="cb114-2961"><a href="#cb114-2961" aria-hidden="true" tabindex="-1"></a>    gain_sorted <span class="op">=</span> gain_importance.sort_values(ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb114-2962"><a href="#cb114-2962" aria-hidden="true" tabindex="-1"></a>    gain_cumsum <span class="op">=</span> gain_sorted.cumsum() <span class="op">/</span> gain_sorted.<span class="bu">sum</span>()</span>
<span id="cb114-2963"><a href="#cb114-2963" aria-hidden="true" tabindex="-1"></a>    top_gain <span class="op">=</span> gain_cumsum[gain_cumsum <span class="op">&lt;=</span> <span class="fl">0.95</span>].index.tolist()</span>
<span id="cb114-2964"><a href="#cb114-2964" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2965"><a href="#cb114-2965" aria-hidden="true" tabindex="-1"></a>    selected_features <span class="op">=</span> <span class="bu">list</span>(<span class="bu">set</span>(top_shap).union(<span class="bu">set</span>(top_gain)))</span>
<span id="cb114-2966"><a href="#cb114-2966" aria-hidden="true" tabindex="-1"></a>    selected_feature_sets.append(selected_features)</span>
<span id="cb114-2967"><a href="#cb114-2967" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2968"><a href="#cb114-2968" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 4: Final Feature Union ===</span></span>
<span id="cb114-2969"><a href="#cb114-2969" aria-hidden="true" tabindex="-1"></a>final_union_features <span class="op">=</span> <span class="bu">list</span>(<span class="bu">set</span>().union(<span class="op">*</span>selected_feature_sets))</span>
<span id="cb114-2970"><a href="#cb114-2970" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Final Union Feature Count:"</span>, <span class="bu">len</span>(final_union_features))</span>
<span id="cb114-2971"><a href="#cb114-2971" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2972"><a href="#cb114-2972" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 5: Train Final Model with Early Stopping on Union Features ===</span></span>
<span id="cb114-2973"><a href="#cb114-2973" aria-hidden="true" tabindex="-1"></a>X_full_selected <span class="op">=</span> X_full[final_union_features]</span>
<span id="cb114-2974"><a href="#cb114-2974" aria-hidden="true" tabindex="-1"></a>X_test_selected <span class="op">=</span> X_test[final_union_features]</span>
<span id="cb114-2975"><a href="#cb114-2975" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2976"><a href="#cb114-2976" aria-hidden="true" tabindex="-1"></a>final_model <span class="op">=</span> XGBRegressor(<span class="op">**</span>study.best_params)</span>
<span id="cb114-2977"><a href="#cb114-2977" aria-hidden="true" tabindex="-1"></a>final_model.set_params(n_estimators<span class="op">=</span><span class="dv">1000</span>, verbosity<span class="op">=</span><span class="dv">1</span>, early_stopping_rounds<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb114-2978"><a href="#cb114-2978" aria-hidden="true" tabindex="-1"></a>final_model.fit(X_full_selected, y_full, eval_set<span class="op">=</span>[(X_full_selected, y_full)], verbose<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb114-2979"><a href="#cb114-2979" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2980"><a href="#cb114-2980" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 6: Predict on Test Set ===</span></span>
<span id="cb114-2981"><a href="#cb114-2981" aria-hidden="true" tabindex="-1"></a>test_preds <span class="op">=</span> final_model.predict(X_test_selected)</span>
<span id="cb114-2982"><a href="#cb114-2982" aria-hidden="true" tabindex="-1"></a>np.save(<span class="st">"test_preds_xgbreg.npy"</span>, test_preds)</span>
<span id="cb114-2983"><a href="#cb114-2983" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Saved: test_preds_xgbreg.npy"</span>)</span>
<span id="cb114-2984"><a href="#cb114-2984" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2985"><a href="#cb114-2985" aria-hidden="true" tabindex="-1"></a><span class="co"># === STEP 7: Create Submission File ===</span></span>
<span id="cb114-2986"><a href="#cb114-2986" aria-hidden="true" tabindex="-1"></a>account_ids <span class="op">=</span> acct_test.values.ravel()  <span class="co"># Replace with actual ID column</span></span>
<span id="cb114-2987"><a href="#cb114-2987" aria-hidden="true" tabindex="-1"></a>submission <span class="op">=</span> pd.DataFrame({</span>
<span id="cb114-2988"><a href="#cb114-2988" aria-hidden="true" tabindex="-1"></a>    <span class="st">'ACCOUNT'</span>: account_ids,</span>
<span id="cb114-2989"><a href="#cb114-2989" aria-hidden="true" tabindex="-1"></a>    <span class="st">'TARGET'</span>: test_preds</span>
<span id="cb114-2990"><a href="#cb114-2990" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb114-2991"><a href="#cb114-2991" aria-hidden="true" tabindex="-1"></a>submission.to_csv(<span class="st">"submission_xgbreg.csv"</span>, index<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb114-2992"><a href="#cb114-2992" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" Submission saved: submission_xgbreg.csv"</span>)</span>
<span id="cb114-2993"><a href="#cb114-2993" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2994"><a href="#cb114-2994" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-2995"><a href="#cb114-2995" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-2998"><a href="#cb114-2998" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-2999"><a href="#cb114-2999" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb114-3000"><a href="#cb114-3000" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb114-3001"><a href="#cb114-3001" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb114-3002"><a href="#cb114-3002" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb114-3003"><a href="#cb114-3003" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3004"><a href="#cb114-3004" aria-hidden="true" tabindex="-1"></a><span class="co"># === Compute Residuals ===</span></span>
<span id="cb114-3005"><a href="#cb114-3005" aria-hidden="true" tabindex="-1"></a>residuals <span class="op">=</span> y_full <span class="op">-</span> global_oof_preds</span>
<span id="cb114-3006"><a href="#cb114-3006" aria-hidden="true" tabindex="-1"></a>res_df <span class="op">=</span> X_full.copy()</span>
<span id="cb114-3007"><a href="#cb114-3007" aria-hidden="true" tabindex="-1"></a>res_df[<span class="st">"actual"</span>] <span class="op">=</span> y_full</span>
<span id="cb114-3008"><a href="#cb114-3008" aria-hidden="true" tabindex="-1"></a>res_df[<span class="st">"predicted"</span>] <span class="op">=</span> global_oof_preds</span>
<span id="cb114-3009"><a href="#cb114-3009" aria-hidden="true" tabindex="-1"></a>res_df[<span class="st">"residual"</span>] <span class="op">=</span> residuals</span>
<span id="cb114-3010"><a href="#cb114-3010" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3011"><a href="#cb114-3011" aria-hidden="true" tabindex="-1"></a><span class="co"># === Protest Count (2015‚Äì2018) ===</span></span>
<span id="cb114-3012"><a href="#cb114-3012" aria-hidden="true" tabindex="-1"></a>protest_cols <span class="op">=</span> [<span class="ss">f"protested_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2019</span>)]</span>
<span id="cb114-3013"><a href="#cb114-3013" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">all</span>(col <span class="kw">in</span> res_df.columns <span class="cf">for</span> col <span class="kw">in</span> protest_cols):</span>
<span id="cb114-3014"><a href="#cb114-3014" aria-hidden="true" tabindex="-1"></a>    res_df[<span class="st">"protest_count"</span>] <span class="op">=</span> res_df[protest_cols].<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb114-3015"><a href="#cb114-3015" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3016"><a href="#cb114-3016" aria-hidden="true" tabindex="-1"></a><span class="co"># === Plot 1: Residuals vs Actual Value ===</span></span>
<span id="cb114-3017"><a href="#cb114-3017" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb114-3018"><a href="#cb114-3018" aria-hidden="true" tabindex="-1"></a>sns.scatterplot(data<span class="op">=</span>res_df, x<span class="op">=</span><span class="st">"actual"</span>, y<span class="op">=</span><span class="st">"residual"</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb114-3019"><a href="#cb114-3019" aria-hidden="true" tabindex="-1"></a>plt.axhline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">"red"</span>, linestyle<span class="op">=</span><span class="st">"--"</span>)</span>
<span id="cb114-3020"><a href="#cb114-3020" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Residuals vs. Actual Value"</span>)</span>
<span id="cb114-3021"><a href="#cb114-3021" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Actual Value"</span>)</span>
<span id="cb114-3022"><a href="#cb114-3022" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Residual (Actual - Predicted)"</span>)</span>
<span id="cb114-3023"><a href="#cb114-3023" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb114-3024"><a href="#cb114-3024" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">"residuals_vs_actual_value.png"</span>, dpi<span class="op">=</span><span class="dv">300</span>)</span>
<span id="cb114-3025"><a href="#cb114-3025" aria-hidden="true" tabindex="-1"></a>plt.close()</span>
<span id="cb114-3026"><a href="#cb114-3026" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3027"><a href="#cb114-3027" aria-hidden="true" tabindex="-1"></a><span class="co"># === Plot 2: Residuals by Protest Count ===</span></span>
<span id="cb114-3028"><a href="#cb114-3028" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">"protest_count"</span> <span class="kw">in</span> res_df.columns:</span>
<span id="cb114-3029"><a href="#cb114-3029" aria-hidden="true" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb114-3030"><a href="#cb114-3030" aria-hidden="true" tabindex="-1"></a>    sns.boxplot(x<span class="op">=</span><span class="st">"protest_count"</span>, y<span class="op">=</span><span class="st">"residual"</span>, data<span class="op">=</span>res_df)</span>
<span id="cb114-3031"><a href="#cb114-3031" aria-hidden="true" tabindex="-1"></a>    plt.axhline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">"red"</span>, linestyle<span class="op">=</span><span class="st">"--"</span>)</span>
<span id="cb114-3032"><a href="#cb114-3032" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="st">"Residuals by Protest Count (2015‚Äì2018)"</span>)</span>
<span id="cb114-3033"><a href="#cb114-3033" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">"Number of Years Protested"</span>)</span>
<span id="cb114-3034"><a href="#cb114-3034" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">"Residual"</span>)</span>
<span id="cb114-3035"><a href="#cb114-3035" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb114-3036"><a href="#cb114-3036" aria-hidden="true" tabindex="-1"></a>    plt.savefig(<span class="st">"residuals_by_protest_count.png"</span>, dpi<span class="op">=</span><span class="dv">300</span>)</span>
<span id="cb114-3037"><a href="#cb114-3037" aria-hidden="true" tabindex="-1"></a>    plt.close()</span>
<span id="cb114-3038"><a href="#cb114-3038" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3039"><a href="#cb114-3039" aria-hidden="true" tabindex="-1"></a><span class="co"># === Plot 3: Residuals vs. Neighborhood Frequency ===</span></span>
<span id="cb114-3040"><a href="#cb114-3040" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">"neighborhood_freq"</span> <span class="kw">in</span> res_df.columns:</span>
<span id="cb114-3041"><a href="#cb114-3041" aria-hidden="true" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb114-3042"><a href="#cb114-3042" aria-hidden="true" tabindex="-1"></a>    sns.scatterplot(x<span class="op">=</span><span class="st">"neighborhood_freq"</span>, y<span class="op">=</span><span class="st">"residual"</span>, data<span class="op">=</span>res_df, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb114-3043"><a href="#cb114-3043" aria-hidden="true" tabindex="-1"></a>    plt.axhline(<span class="dv">0</span>, color<span class="op">=</span><span class="st">"red"</span>, linestyle<span class="op">=</span><span class="st">"--"</span>)</span>
<span id="cb114-3044"><a href="#cb114-3044" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="st">"Residuals vs. Neighborhood Frequency"</span>)</span>
<span id="cb114-3045"><a href="#cb114-3045" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">"Neighborhood Frequency"</span>)</span>
<span id="cb114-3046"><a href="#cb114-3046" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">"Residual"</span>)</span>
<span id="cb114-3047"><a href="#cb114-3047" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb114-3048"><a href="#cb114-3048" aria-hidden="true" tabindex="-1"></a>    plt.savefig(<span class="st">"residuals_vs_neighborhood_freq.png"</span>, dpi<span class="op">=</span><span class="dv">300</span>)</span>
<span id="cb114-3049"><a href="#cb114-3049" aria-hidden="true" tabindex="-1"></a>    plt.close()</span>
<span id="cb114-3050"><a href="#cb114-3050" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3051"><a href="#cb114-3051" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-3052"><a href="#cb114-3052" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3055"><a href="#cb114-3055" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-3056"><a href="#cb114-3056" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb114-3057"><a href="#cb114-3057" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb114-3058"><a href="#cb114-3058" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> shap</span>
<span id="cb114-3059"><a href="#cb114-3059" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb114-3060"><a href="#cb114-3060" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3061"><a href="#cb114-3061" aria-hidden="true" tabindex="-1"></a><span class="co"># === SHAP Setup ===</span></span>
<span id="cb114-3062"><a href="#cb114-3062" aria-hidden="true" tabindex="-1"></a>explainer <span class="op">=</span> shap.TreeExplainer(final_model)</span>
<span id="cb114-3063"><a href="#cb114-3063" aria-hidden="true" tabindex="-1"></a>shap_values <span class="op">=</span> explainer.shap_values(X_full_selected)</span>
<span id="cb114-3064"><a href="#cb114-3064" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3065"><a href="#cb114-3065" aria-hidden="true" tabindex="-1"></a><span class="co"># === SHAP DataFrame ===</span></span>
<span id="cb114-3066"><a href="#cb114-3066" aria-hidden="true" tabindex="-1"></a>shap_df <span class="op">=</span> pd.DataFrame(np.<span class="bu">abs</span>(shap_values), columns<span class="op">=</span>X_full_selected.columns)</span>
<span id="cb114-3067"><a href="#cb114-3067" aria-hidden="true" tabindex="-1"></a>shap_means <span class="op">=</span> shap_df.mean().sort_values(ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb114-3068"><a href="#cb114-3068" aria-hidden="true" tabindex="-1"></a>shap_importance_df <span class="op">=</span> shap_means.reset_index()</span>
<span id="cb114-3069"><a href="#cb114-3069" aria-hidden="true" tabindex="-1"></a>shap_importance_df.columns <span class="op">=</span> [<span class="st">"feature"</span>, <span class="st">"mean_shap"</span>]</span>
<span id="cb114-3070"><a href="#cb114-3070" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3071"><a href="#cb114-3071" aria-hidden="true" tabindex="-1"></a><span class="co"># === SHAP Summary Plot: Top 30 ===</span></span>
<span id="cb114-3072"><a href="#cb114-3072" aria-hidden="true" tabindex="-1"></a>plt.figure()</span>
<span id="cb114-3073"><a href="#cb114-3073" aria-hidden="true" tabindex="-1"></a>shap.summary_plot(shap_values, X_full_selected, max_display<span class="op">=</span><span class="dv">30</span>, show<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb114-3074"><a href="#cb114-3074" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb114-3075"><a href="#cb114-3075" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">"shap_summary_top30_union.png"</span>, dpi<span class="op">=</span><span class="dv">300</span>)</span>
<span id="cb114-3076"><a href="#cb114-3076" aria-hidden="true" tabindex="-1"></a>plt.close()</span>
<span id="cb114-3077"><a href="#cb114-3077" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3078"><a href="#cb114-3078" aria-hidden="true" tabindex="-1"></a><span class="co"># === SHAP Summary Plot: Bottom 30 ===</span></span>
<span id="cb114-3079"><a href="#cb114-3079" aria-hidden="true" tabindex="-1"></a>bottom_features <span class="op">=</span> shap_importance_df.tail(<span class="dv">30</span>)[<span class="st">"feature"</span>].tolist()</span>
<span id="cb114-3080"><a href="#cb114-3080" aria-hidden="true" tabindex="-1"></a>shap.summary_plot(</span>
<span id="cb114-3081"><a href="#cb114-3081" aria-hidden="true" tabindex="-1"></a>    shap_values[:, [X_full_selected.columns.get_loc(f) <span class="cf">for</span> f <span class="kw">in</span> bottom_features]],</span>
<span id="cb114-3082"><a href="#cb114-3082" aria-hidden="true" tabindex="-1"></a>    X_full_selected[bottom_features],</span>
<span id="cb114-3083"><a href="#cb114-3083" aria-hidden="true" tabindex="-1"></a>    show<span class="op">=</span><span class="va">False</span></span>
<span id="cb114-3084"><a href="#cb114-3084" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb114-3085"><a href="#cb114-3085" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb114-3086"><a href="#cb114-3086" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">"shap_summary_bottom30_union.png"</span>, dpi<span class="op">=</span><span class="dv">300</span>)</span>
<span id="cb114-3087"><a href="#cb114-3087" aria-hidden="true" tabindex="-1"></a>plt.close()</span>
<span id="cb114-3088"><a href="#cb114-3088" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3089"><a href="#cb114-3089" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-3090"><a href="#cb114-3090" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3091"><a href="#cb114-3091" aria-hidden="true" tabindex="-1"></a><span class="fu"># RMSE Optimization</span></span>
<span id="cb114-3092"><a href="#cb114-3092" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3095"><a href="#cb114-3095" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-3096"><a href="#cb114-3096" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb114-3097"><a href="#cb114-3097" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3098"><a href="#cb114-3098" aria-hidden="true" tabindex="-1"></a><span class="co"># ===== Load Data =====</span></span>
<span id="cb114-3099"><a href="#cb114-3099" aria-hidden="true" tabindex="-1"></a>folder_path <span class="op">=</span> <span class="st">'/Users/Srijith97/Downloads/STA 9890 Housing Data/'</span></span>
<span id="cb114-3100"><a href="#cb114-3100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3101"><a href="#cb114-3101" aria-hidden="true" tabindex="-1"></a>building_years <span class="op">=</span> []</span>
<span id="cb114-3102"><a href="#cb114-3102" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2015</span>, <span class="dv">2020</span>):</span>
<span id="cb114-3103"><a href="#cb114-3103" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.read_csv(folder_path <span class="op">+</span> <span class="ss">f'building_details_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">.csv'</span>)</span>
<span id="cb114-3104"><a href="#cb114-3104" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'year'</span>] <span class="op">=</span> year</span>
<span id="cb114-3105"><a href="#cb114-3105" aria-hidden="true" tabindex="-1"></a>    building_years.append(df)</span>
<span id="cb114-3106"><a href="#cb114-3106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3107"><a href="#cb114-3107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3108"><a href="#cb114-3108" aria-hidden="true" tabindex="-1"></a>building_all <span class="op">=</span> pd.concat(building_years, ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb114-3109"><a href="#cb114-3109" aria-hidden="true" tabindex="-1"></a>building_all <span class="op">=</span> building_all.drop_duplicates(subset<span class="op">=</span>[<span class="st">'acct'</span>, <span class="st">'year'</span>], keep<span class="op">=</span><span class="st">'first'</span>)</span>
<span id="cb114-3110"><a href="#cb114-3110" aria-hidden="true" tabindex="-1"></a>pivoted <span class="op">=</span> building_all.pivot(index<span class="op">=</span><span class="st">'acct'</span>, columns<span class="op">=</span><span class="st">'year'</span>)</span>
<span id="cb114-3111"><a href="#cb114-3111" aria-hidden="true" tabindex="-1"></a>pivoted.columns <span class="op">=</span> [<span class="ss">f'</span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> col, year <span class="kw">in</span> pivoted.columns]</span>
<span id="cb114-3112"><a href="#cb114-3112" aria-hidden="true" tabindex="-1"></a>pivoted <span class="op">=</span> pivoted.reset_index()</span>
<span id="cb114-3113"><a href="#cb114-3113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3114"><a href="#cb114-3114" aria-hidden="true" tabindex="-1"></a>train <span class="op">=</span> pd.read_csv(folder_path <span class="op">+</span> <span class="st">'assessment_history_train.csv'</span>)</span>
<span id="cb114-3115"><a href="#cb114-3115" aria-hidden="true" tabindex="-1"></a>test <span class="op">=</span> pd.read_csv(folder_path <span class="op">+</span> <span class="st">'assessment_history_test.csv'</span>)</span>
<span id="cb114-3116"><a href="#cb114-3116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3117"><a href="#cb114-3117" aria-hidden="true" tabindex="-1"></a>train_merged <span class="op">=</span> train.merge(pivoted, on<span class="op">=</span><span class="st">'acct'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb114-3118"><a href="#cb114-3118" aria-hidden="true" tabindex="-1"></a>test_merged <span class="op">=</span> test.merge(pivoted, on<span class="op">=</span><span class="st">'acct'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb114-3119"><a href="#cb114-3119" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-3120"><a href="#cb114-3120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3123"><a href="#cb114-3123" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-3124"><a href="#cb114-3124" aria-hidden="true" tabindex="-1"></a>acct_test <span class="op">=</span> test_merged[[<span class="st">'acct'</span>]].copy() <span class="cf">if</span> <span class="st">'acct'</span> <span class="kw">in</span> test_merged.columns <span class="cf">else</span> <span class="va">None</span></span>
<span id="cb114-3125"><a href="#cb114-3125" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-3126"><a href="#cb114-3126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3129"><a href="#cb114-3129" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-3130"><a href="#cb114-3130" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb114-3131"><a href="#cb114-3131" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb114-3132"><a href="#cb114-3132" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> optuna</span>
<span id="cb114-3133"><a href="#cb114-3133" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> logging</span>
<span id="cb114-3134"><a href="#cb114-3134" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> root_mean_squared_error</span>
<span id="cb114-3135"><a href="#cb114-3135" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb114-3136"><a href="#cb114-3136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3137"><a href="#cb114-3137" aria-hidden="true" tabindex="-1"></a><span class="co"># === Setup Logging ===</span></span>
<span id="cb114-3138"><a href="#cb114-3138" aria-hidden="true" tabindex="-1"></a>logging.basicConfig(level<span class="op">=</span>logging.INFO, <span class="bu">format</span><span class="op">=</span><span class="st">"</span><span class="sc">%(asctime)s</span><span class="st"> [</span><span class="sc">%(levelname)s</span><span class="st">] </span><span class="sc">%(message)s</span><span class="st">"</span>)</span>
<span id="cb114-3139"><a href="#cb114-3139" aria-hidden="true" tabindex="-1"></a>logger <span class="op">=</span> logging.getLogger(<span class="st">"OptunaBlender"</span>)</span>
<span id="cb114-3140"><a href="#cb114-3140" aria-hidden="true" tabindex="-1"></a>optuna.logging.set_verbosity(optuna.logging.INFO)</span>
<span id="cb114-3141"><a href="#cb114-3141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3142"><a href="#cb114-3142" aria-hidden="true" tabindex="-1"></a><span class="co"># === Load base model predictions ===</span></span>
<span id="cb114-3143"><a href="#cb114-3143" aria-hidden="true" tabindex="-1"></a>oof_xgb <span class="op">=</span> np.load(<span class="st">"oof_preds_xgbreg.npy"</span>)</span>
<span id="cb114-3144"><a href="#cb114-3144" aria-hidden="true" tabindex="-1"></a>ridge_oof <span class="op">=</span> np.load(<span class="st">"ridgecv_oof_preds.npy"</span>)</span>
<span id="cb114-3145"><a href="#cb114-3145" aria-hidden="true" tabindex="-1"></a>oof_lgb<span class="op">=</span>np.load(<span class="st">"oof_preds_lgbm.npy"</span>)</span>
<span id="cb114-3146"><a href="#cb114-3146" aria-hidden="true" tabindex="-1"></a>test_xgb <span class="op">=</span> np.load(<span class="st">"test_preds_xgbreg.npy"</span>)</span>
<span id="cb114-3147"><a href="#cb114-3147" aria-hidden="true" tabindex="-1"></a>ridge_test_preds <span class="op">=</span> np.load(<span class="st">"ridgecv_test_preds.npy"</span>)</span>
<span id="cb114-3148"><a href="#cb114-3148" aria-hidden="true" tabindex="-1"></a>test_lgb<span class="op">=</span>np.load(<span class="st">"test_preds_lgbm_shap.npy"</span>)</span>
<span id="cb114-3149"><a href="#cb114-3149" aria-hidden="true" tabindex="-1"></a><span class="co"># === Targets and prediction stack ===</span></span>
<span id="cb114-3150"><a href="#cb114-3150" aria-hidden="true" tabindex="-1"></a>y_meta <span class="op">=</span> train[<span class="st">'TARGET'</span>].values</span>
<span id="cb114-3151"><a href="#cb114-3151" aria-hidden="true" tabindex="-1"></a>X_base <span class="op">=</span> np.vstack([oof_xgb, ridge_oof,oof_lgb]).T</span>
<span id="cb114-3152"><a href="#cb114-3152" aria-hidden="true" tabindex="-1"></a>X_test_base <span class="op">=</span> np.vstack([test_xgb, ridge_test_preds,test_lgb]).T</span>
<span id="cb114-3153"><a href="#cb114-3153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3154"><a href="#cb114-3154" aria-hidden="true" tabindex="-1"></a><span class="co"># === Holdout split ===</span></span>
<span id="cb114-3155"><a href="#cb114-3155" aria-hidden="true" tabindex="-1"></a>X_train, X_holdout, y_train, y_holdout <span class="op">=</span> train_test_split(X_base, y_meta, test_size<span class="op">=</span><span class="fl">0.2</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb114-3156"><a href="#cb114-3156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3157"><a href="#cb114-3157" aria-hidden="true" tabindex="-1"></a><span class="co"># === Objective Function ===</span></span>
<span id="cb114-3158"><a href="#cb114-3158" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> objective(trial):</span>
<span id="cb114-3159"><a href="#cb114-3159" aria-hidden="true" tabindex="-1"></a>    weights <span class="op">=</span> [trial.suggest_float(<span class="ss">f"w</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">"</span>, <span class="dv">0</span>, <span class="dv">1</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(X_train.shape[<span class="dv">1</span>])]</span>
<span id="cb114-3160"><a href="#cb114-3160" aria-hidden="true" tabindex="-1"></a>    weights <span class="op">=</span> np.array(weights)</span>
<span id="cb114-3161"><a href="#cb114-3161" aria-hidden="true" tabindex="-1"></a>    weights <span class="op">/=</span> weights.<span class="bu">sum</span>()  <span class="co"># normalize</span></span>
<span id="cb114-3162"><a href="#cb114-3162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3163"><a href="#cb114-3163" aria-hidden="true" tabindex="-1"></a>    preds <span class="op">=</span> X_holdout <span class="op">@</span> weights</span>
<span id="cb114-3164"><a href="#cb114-3164" aria-hidden="true" tabindex="-1"></a>    rmse <span class="op">=</span> root_mean_squared_error(y_holdout, preds)</span>
<span id="cb114-3165"><a href="#cb114-3165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3166"><a href="#cb114-3166" aria-hidden="true" tabindex="-1"></a>    logger.info(<span class="ss">f"Trial </span><span class="sc">{</span>trial<span class="sc">.</span>number<span class="sc">}</span><span class="ss"> | Weights: </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">round</span>(weights, <span class="dv">3</span>)<span class="sc">.</span>tolist()<span class="sc">}</span><span class="ss"> | RMSE: </span><span class="sc">{</span>rmse<span class="sc">:,.4f}</span><span class="ss">"</span>)</span>
<span id="cb114-3167"><a href="#cb114-3167" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> rmse</span>
<span id="cb114-3168"><a href="#cb114-3168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3169"><a href="#cb114-3169" aria-hidden="true" tabindex="-1"></a><span class="co"># === Run Study ===</span></span>
<span id="cb114-3170"><a href="#cb114-3170" aria-hidden="true" tabindex="-1"></a>logger.info(<span class="st">" Starting Optuna optimization for weighted blending..."</span>)</span>
<span id="cb114-3171"><a href="#cb114-3171" aria-hidden="true" tabindex="-1"></a>study <span class="op">=</span> optuna.create_study(direction<span class="op">=</span><span class="st">"minimize"</span>)</span>
<span id="cb114-3172"><a href="#cb114-3172" aria-hidden="true" tabindex="-1"></a>study.optimize(objective, n_trials<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb114-3173"><a href="#cb114-3173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3174"><a href="#cb114-3174" aria-hidden="true" tabindex="-1"></a><span class="co"># === Best weights ===</span></span>
<span id="cb114-3175"><a href="#cb114-3175" aria-hidden="true" tabindex="-1"></a>best_weights <span class="op">=</span> np.array([study.best_trial.params[<span class="ss">f"w</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">"</span>] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(X_base.shape[<span class="dv">1</span>])])</span>
<span id="cb114-3176"><a href="#cb114-3176" aria-hidden="true" tabindex="-1"></a>best_weights <span class="op">/=</span> best_weights.<span class="bu">sum</span>()</span>
<span id="cb114-3177"><a href="#cb114-3177" aria-hidden="true" tabindex="-1"></a>logger.info(<span class="ss">f" Best weights: </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">round</span>(best_weights, <span class="dv">4</span>)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-3178"><a href="#cb114-3178" aria-hidden="true" tabindex="-1"></a>logger.info(<span class="ss">f" Best RMSE: </span><span class="sc">{</span>study<span class="sc">.</span>best_value<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb114-3179"><a href="#cb114-3179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3180"><a href="#cb114-3180" aria-hidden="true" tabindex="-1"></a><span class="co"># === Final test prediction ===</span></span>
<span id="cb114-3181"><a href="#cb114-3181" aria-hidden="true" tabindex="-1"></a>meta_preds <span class="op">=</span> X_test_base <span class="op">@</span> best_weights</span>
<span id="cb114-3182"><a href="#cb114-3182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3183"><a href="#cb114-3183" aria-hidden="true" tabindex="-1"></a><span class="co"># === Save predictions ===</span></span>
<span id="cb114-3184"><a href="#cb114-3184" aria-hidden="true" tabindex="-1"></a>np.save(<span class="st">"test_preds_optuna_blended.npy"</span>, meta_preds)</span>
<span id="cb114-3185"><a href="#cb114-3185" aria-hidden="true" tabindex="-1"></a>account_ids <span class="op">=</span> acct_test.values.ravel()</span>
<span id="cb114-3186"><a href="#cb114-3186" aria-hidden="true" tabindex="-1"></a>submission <span class="op">=</span> pd.DataFrame({</span>
<span id="cb114-3187"><a href="#cb114-3187" aria-hidden="true" tabindex="-1"></a>    <span class="st">"ACCOUNT"</span>: account_ids,</span>
<span id="cb114-3188"><a href="#cb114-3188" aria-hidden="true" tabindex="-1"></a>    <span class="st">"TARGET"</span>: meta_preds</span>
<span id="cb114-3189"><a href="#cb114-3189" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb114-3190"><a href="#cb114-3190" aria-hidden="true" tabindex="-1"></a>submission.to_csv(<span class="st">"submission_optuna_blended.csv"</span>, index<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb114-3191"><a href="#cb114-3191" aria-hidden="true" tabindex="-1"></a>logger.info(<span class="st">" Saved: test_preds_optuna_blended.npy and submission_optuna_blended.csv"</span>)</span>
<span id="cb114-3192"><a href="#cb114-3192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3193"><a href="#cb114-3193" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb114-3194"><a href="#cb114-3194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3197"><a href="#cb114-3197" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb114-3198"><a href="#cb114-3198" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb114-3199"><a href="#cb114-3199" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> ElasticNetCV</span>
<span id="cb114-3200"><a href="#cb114-3200" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.pipeline <span class="im">import</span> make_pipeline</span>
<span id="cb114-3201"><a href="#cb114-3201" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb114-3202"><a href="#cb114-3202" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb114-3203"><a href="#cb114-3203" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> root_mean_squared_error</span>
<span id="cb114-3204"><a href="#cb114-3204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3205"><a href="#cb114-3205" aria-hidden="true" tabindex="-1"></a><span class="co"># === Load OOF + Test Predictions ===</span></span>
<span id="cb114-3206"><a href="#cb114-3206" aria-hidden="true" tabindex="-1"></a>oof_xgb <span class="op">=</span> np.load(<span class="st">"oof_preds_xgbreg.npy"</span>)</span>
<span id="cb114-3207"><a href="#cb114-3207" aria-hidden="true" tabindex="-1"></a>test_xgb <span class="op">=</span> np.load(<span class="st">"test_preds_xgbreg.npy"</span>)</span>
<span id="cb114-3208"><a href="#cb114-3208" aria-hidden="true" tabindex="-1"></a>ridge_oof<span class="op">=</span>np.load(<span class="st">"ridgecv_oof_preds.npy"</span>)</span>
<span id="cb114-3209"><a href="#cb114-3209" aria-hidden="true" tabindex="-1"></a>ridge_test_preds<span class="op">=</span>np.load(<span class="st">"ridgecv_test_preds.npy"</span>)</span>
<span id="cb114-3210"><a href="#cb114-3210" aria-hidden="true" tabindex="-1"></a>oof_lgb<span class="op">=</span>np.load(<span class="st">"oof_preds_lgbm.npy"</span>)</span>
<span id="cb114-3211"><a href="#cb114-3211" aria-hidden="true" tabindex="-1"></a>test_lgb<span class="op">=</span>np.load(<span class="st">"test_preds_lgbm_shap.npy"</span>)</span>
<span id="cb114-3212"><a href="#cb114-3212" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3213"><a href="#cb114-3213" aria-hidden="true" tabindex="-1"></a><span class="co"># === 3. Combine full meta-input feature set ===</span></span>
<span id="cb114-3214"><a href="#cb114-3214" aria-hidden="true" tabindex="-1"></a>X_meta <span class="op">=</span> np.hstack([</span>
<span id="cb114-3215"><a href="#cb114-3215" aria-hidden="true" tabindex="-1"></a>    oof_xgb.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>),</span>
<span id="cb114-3216"><a href="#cb114-3216" aria-hidden="true" tabindex="-1"></a>    ridge_oof.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>),</span>
<span id="cb114-3217"><a href="#cb114-3217" aria-hidden="true" tabindex="-1"></a>    oof_lgb.reshape(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>)</span>
<span id="cb114-3218"><a href="#cb114-3218" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb114-3219"><a href="#cb114-3219" aria-hidden="true" tabindex="-1"></a>y_meta <span class="op">=</span> train[<span class="st">'TARGET'</span>].values</span>
<span id="cb114-3220"><a href="#cb114-3220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3221"><a href="#cb114-3221" aria-hidden="true" tabindex="-1"></a>X_meta_test <span class="op">=</span> np.hstack([</span>
<span id="cb114-3222"><a href="#cb114-3222" aria-hidden="true" tabindex="-1"></a>    test_xgb.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>),</span>
<span id="cb114-3223"><a href="#cb114-3223" aria-hidden="true" tabindex="-1"></a>    ridge_test_preds.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>),</span>
<span id="cb114-3224"><a href="#cb114-3224" aria-hidden="true" tabindex="-1"></a>    test_lgb.reshape(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>)</span>
<span id="cb114-3225"><a href="#cb114-3225" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb114-3226"><a href="#cb114-3226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3227"><a href="#cb114-3227" aria-hidden="true" tabindex="-1"></a><span class="co"># === 4. Train ElasticNetCV meta-learner ===</span></span>
<span id="cb114-3228"><a href="#cb114-3228" aria-hidden="true" tabindex="-1"></a>meta_model <span class="op">=</span> make_pipeline(</span>
<span id="cb114-3229"><a href="#cb114-3229" aria-hidden="true" tabindex="-1"></a>    StandardScaler(),</span>
<span id="cb114-3230"><a href="#cb114-3230" aria-hidden="true" tabindex="-1"></a>    ElasticNetCV(</span>
<span id="cb114-3231"><a href="#cb114-3231" aria-hidden="true" tabindex="-1"></a>        l1_ratio<span class="op">=</span>[<span class="fl">0.1</span>, <span class="fl">0.5</span>, <span class="fl">0.9</span>, <span class="dv">1</span>],</span>
<span id="cb114-3232"><a href="#cb114-3232" aria-hidden="true" tabindex="-1"></a>        alphas<span class="op">=</span>np.logspace(<span class="op">-</span><span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">100</span>),</span>
<span id="cb114-3233"><a href="#cb114-3233" aria-hidden="true" tabindex="-1"></a>        cv<span class="op">=</span><span class="dv">3</span>,</span>
<span id="cb114-3234"><a href="#cb114-3234" aria-hidden="true" tabindex="-1"></a>        max_iter<span class="op">=</span><span class="dv">5000</span>,</span>
<span id="cb114-3235"><a href="#cb114-3235" aria-hidden="true" tabindex="-1"></a>        n_jobs<span class="op">=-</span><span class="dv">1</span></span>
<span id="cb114-3236"><a href="#cb114-3236" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb114-3237"><a href="#cb114-3237" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb114-3238"><a href="#cb114-3238" aria-hidden="true" tabindex="-1"></a>meta_model.fit(X_meta, y_meta)</span>
<span id="cb114-3239"><a href="#cb114-3239" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3240"><a href="#cb114-3240" aria-hidden="true" tabindex="-1"></a><span class="co"># === 5. Predict and evaluate (optional holdout split) ===</span></span>
<span id="cb114-3241"><a href="#cb114-3241" aria-hidden="true" tabindex="-1"></a><span class="co"># You can skip this section if you're blending on full train</span></span>
<span id="cb114-3242"><a href="#cb114-3242" aria-hidden="true" tabindex="-1"></a>X_train, X_holdout, y_train, y_holdout <span class="op">=</span> train_test_split(X_meta, y_meta, test_size<span class="op">=</span><span class="fl">0.2</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb114-3243"><a href="#cb114-3243" aria-hidden="true" tabindex="-1"></a>meta_model.fit(X_train, y_train)</span>
<span id="cb114-3244"><a href="#cb114-3244" aria-hidden="true" tabindex="-1"></a>holdout_preds <span class="op">=</span> meta_model.predict(X_holdout)</span>
<span id="cb114-3245"><a href="#cb114-3245" aria-hidden="true" tabindex="-1"></a>rmse <span class="op">=</span> root_mean_squared_error(y_holdout, holdout_preds)</span>
<span id="cb114-3246"><a href="#cb114-3246" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"ElasticNetCV Blended Meta Holdout RMSE: </span><span class="sc">{</span>rmse<span class="sc">:,.2f}</span><span class="ss">"</span>)</span>
<span id="cb114-3247"><a href="#cb114-3247" aria-hidden="true" tabindex="-1"></a>best_alpha <span class="op">=</span> meta_model.named_steps[<span class="st">'elasticnetcv'</span>].alpha_</span>
<span id="cb114-3248"><a href="#cb114-3248" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f" Best alpha selected: </span><span class="sc">{</span>best_alpha<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb114-3249"><a href="#cb114-3249" aria-hidden="true" tabindex="-1"></a><span class="co"># === 6. Final predictions for test set ===</span></span>
<span id="cb114-3250"><a href="#cb114-3250" aria-hidden="true" tabindex="-1"></a>meta_preds <span class="op">=</span> meta_model.predict(X_meta_test)</span>
<span id="cb114-3251"><a href="#cb114-3251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3252"><a href="#cb114-3252" aria-hidden="true" tabindex="-1"></a><span class="co"># === 7. Save blended test predictions ===</span></span>
<span id="cb114-3253"><a href="#cb114-3253" aria-hidden="true" tabindex="-1"></a>np.save(<span class="st">"test_preds_elasticnet_blended.npy"</span>, meta_preds)</span>
<span id="cb114-3254"><a href="#cb114-3254" aria-hidden="true" tabindex="-1"></a>account_ids <span class="op">=</span> acct_test.values.ravel() </span>
<span id="cb114-3255"><a href="#cb114-3255" aria-hidden="true" tabindex="-1"></a>submission <span class="op">=</span> pd.DataFrame({</span>
<span id="cb114-3256"><a href="#cb114-3256" aria-hidden="true" tabindex="-1"></a>    <span class="st">"ACCOUNT"</span>: account_ids,  <span class="co"># Replace with your actual ID column</span></span>
<span id="cb114-3257"><a href="#cb114-3257" aria-hidden="true" tabindex="-1"></a>    <span class="st">"TARGET"</span>: meta_preds</span>
<span id="cb114-3258"><a href="#cb114-3258" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb114-3259"><a href="#cb114-3259" aria-hidden="true" tabindex="-1"></a>submission.to_csv(<span class="st">"submission_elasticnet_blended.csv"</span>, index<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb114-3260"><a href="#cb114-3260" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">" ElasticNetCV blended stacking submission saved."</span>)</span>
<span id="cb114-3261"><a href="#cb114-3261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3262"><a href="#cb114-3262" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
</code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>